{"version":3,"sources":["../src/index.js","../node_modules/tsup/assets/cjs_shims.js","../src/helpers/index.js","../src/helpers/dateCompareAsc.js","../src/helpers/dateCompareDesc.js","../src/helpers/defaultNumeric.js","../src/helpers/defaultValue.js","../src/helpers/isInstanceOf.js","../src/helpers/isNumber.js","../src/helpers/isObject.js","../src/utils/index.js","../src/utils/assign.js","../src/utils/base64From.js","../src/utils/base64FromBase64URLSafe.js","../src/utils/toString.js","../src/utils/base64To.js","../src/utils/base64FromBuffer.js","../src/utils/base64ToBuffer.js","../src/utils/base64URLEncode.js","../src/utils/bufferCompare.js","../src/utils/bufferConcatenate.js","../src/utils/bufferFromString.js","../src/utils/bufferToString.js","../src/utils/calculateSecondsInTime.js","../src/utils/cleanObject.js","../src/utils/currencyBRToFloat.js","../src/constants.js","../src/utils/dateToFormat.js","../src/utils/dateFirstHourOfDay.js","../src/utils/dateLastHourOfDay.js","../src/utils/debouncer.js","../src/utils/deleteKeys.js","../src/utils/generateSimpleId.js","../src/utils/generateRandomString.js","../src/utils/getExecutionTime.js","../src/utils/JSONFrom.js","../src/utils/JSONTo.js","../src/crypto/getCrypto.js","../src/crypto/importCryptoKey.js","../src/crypto/encryptBuffer.js","../src/utils/messageEncryptToChunks.js","../src/crypto/decryptBuffer.js","../src/utils/messageDecryptFromChunks.js","../src/utils/normalize.js","../src/utils/pickKeys.js","../src/utils/pushLogMessage.js","../src/utils/regexDigitsOnly.js","../src/utils/regexReplaceTrim.js","../src/utils/regexLettersOnly.js","../src/utils/removeDuplicatedStrings.js","../src/utils/sleep.js","../src/utils/split.js","../src/utils/stringCompress.js","../src/utils/stringDecompress.js","../src/utils/stringToDate.js","../src/utils/stringToDateToFormat.js","../src/utils/stringToFormat.js","../src/utils/stringZLibCompress.js","../src/utils/stringZLibDecompress.js","../src/utils/throttle.js","../src/utils/timestamp.js","../src/utils/uint8ArrayFromString.js","../src/utils/uint8ArrayToString.js","../src/validators/index.js","../src/validators/validateCADICMSPR.js","../src/validators/validateCEP.js","../src/validators/validateCNPJ.js","../src/validators/validateCPF.js","../src/validators/validateEmail.js","../src/validators/validateChavePix.js","../src/validators/validateCNH.js","../src/validators/validatePISPASEPNIT.js","../src/validators/validateRenavam.js","../src/validators/validateTituloEleitor.js","../src/validators/validateRG.js","../src/crypto/index.js","../src/crypto/decrypt.js","../src/crypto/encrypt.js","../src/crypto/digest.js","../src/crypto/verifySignature.js","../src/auth/webauthn/index.js","../src/auth/webauthn/convertECDSAASN1Signature.js","../src/auth/webauthn/getAuthenticationAuthData.js","../src/auth/webauthn/getRegistrationAuthData.js","../src/auth/webauthn/getWebAuthnAuthenticationAssertion.js","../src/auth/webauthn/getWebAuthnRegistrationCredential.js","../src/auth/webauthn/validateRPID.js","../src/auth/webauthn/validateAuthentication.js","../src/auth/webauthn/validateRegistration.js","../src/custom/db/sequelize/index.js","../src/custom/db/sequelize/setConditionsBetweenDates.js","../src/custom/db/sequelize/setConditionsBetweenValues.js","../src/custom/db/sequelize/setConditionStringLike.js","../src/custom/bulkProcessor.js","../src/custom/waitPlugin.js","../src/custom/index.js"],"sourcesContent":["// src/index.js\n\n// --- PASSO 1: Exportações Nomeadas para Funções Individuais ---\n// Re-exporta todas as funções de cada sub-módulo.\n// Isso garante que `import { assign, validateCPF } from 'misc-helpers'` funcione.\nexport * from \"./helpers/index.js\";\nexport * from \"./utils/index.js\";\nexport * from \"./validators/index.js\";\nexport * from \"./crypto/index.js\";\nexport * from \"./auth/webauthn/index.js\";\nexport * from \"./custom/db/sequelize/index.js\";\nexport { default as bulkProcessor } from \"./custom/bulkProcessor.js\";\nexport { default as waitPlugin } from \"./custom/waitPlugin.js\";\n\n// --- PASSO 2: Exportações Nomeadas para Categorias ---\n// Importa cada categoria e a exporta como um objeto nomeado.\n// Isso garante que `import { custom, helpers } from 'misc-helpers'` funcione.\nimport * as authNamespace from \"./auth/webauthn/index.js\";\nimport * as constantsNamespace from \"./constants.js\";\nimport * as cryptoNamespace from \"./crypto/index.js\";\nimport * as customNamespace from \"./custom/index.js\";\nimport * as helpersNamespace from \"./helpers/index.js\";\nimport * as utilsNamespace from \"./utils/index.js\";\nimport * as validatorsNamespace from \"./validators/index.js\";\n\nexport const auth = { webAuthn: authNamespace };\nexport const constants = constantsNamespace;\nexport const crypto = cryptoNamespace;\nexport const custom = {\n  db: {\n    sequelize: {\n      ...customNamespace.db,\n    },\n  },\n  waitPlugin: customNamespace.waitPlugin,\n  bulkProcessor: customNamespace.bulkProcessor,\n};\nexport const helpers = helpersNamespace;\nexport const utils = utilsNamespace;\nexport const validators = validatorsNamespace;\n\n// --- PASSO 3: Exportação Padrão (Default) ---\n// Agrupa tudo em um único objeto para a exportação padrão.\n// Isso garante que `import miscHelpers from 'misc-helpers'` funcione.\nconst miscHelpers = {\n  auth: authNamespace,\n  constants: constantsNamespace,\n  crypto: cryptoNamespace,\n  custom: customNamespace,\n  helpers: helpersNamespace,\n  utils: utilsNamespace,\n  validators: validatorsNamespace,\n};\n\nexport default miscHelpers;","// Shim globals in cjs bundle\n// There's a weird bug that esbuild will always inject importMetaUrl\n// if we export it as `const importMetaUrl = ... __filename ...`\n// But using a function will not cause this issue\n\nconst getImportMetaUrl = () =>\n  typeof document === 'undefined'\n    ? new URL(`file:${__filename}`).href\n    : (document.currentScript && document.currentScript.src) ||\n      new URL('main.js', document.baseURI).href\n\nexport const importMetaUrl = /* @__PURE__ */ getImportMetaUrl()\n","import dateCompareAsc from \"./dateCompareAsc.js\";\nimport dateCompareDesc from \"./dateCompareDesc.js\";\nimport defaultNumeric from \"./defaultNumeric.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport isInstanceOf from \"./isInstanceOf.js\";\nimport isNumber from \"./isNumber.js\";\nimport isObject from \"./isObject.js\";\n\n// Named exports para importação individual\nexport {\n  dateCompareAsc,\n  dateCompareDesc,\n  defaultNumeric,\n  defaultValue,\n  isInstanceOf,\n  isNumber,\n  isObject\n};\n\n// Default export para compatibilidade\nexport default {\n  dateCompareAsc,\n  dateCompareDesc,\n  defaultNumeric,\n  defaultValue,\n  isInstanceOf,\n  isNumber,\n  isObject,\n};","/**\n * @fileoverview Fornece uma função para comparar se uma data é anterior a outra.\n * O código é compatível com ambientes Node.js e navegadores.\n */\n\n/**\n * Compara duas datas para determinar se a primeira (dateA) é anterior à segunda (dateB).\n *\n * @summary Verifica se a data A é anterior à data B.\n * @description Esta função compara duas instâncias de Date. Ela oferece opções para\n * ignorar a parte de horas/minutos/segundos, incluir datas iguais na validação e\n * controlar o comportamento em caso de erro.\n *\n * @param {Date} dateA A data que se espera ser a mais antiga.\n * @param {Date} dateB A data que se espera ser a mais recente.\n * @param {object} [options={}] Opções para customizar o comportamento da comparação.\n * @param {boolean} [options.considerHMS=false] Se `true`, a comparação inclui horas, minutos e segundos. Se `false`, apenas ano, mês e dia são considerados.\n * @param {boolean} [options.considerEquals=false] Se `true`, a função retorna `true` caso as datas sejam idênticas. Se `false`, retorna `false`.\n * @param {boolean} [options.ignoreErrors=false] Se `true`, retorna `null` caso os parâmetros não sejam instâncias de Date. Se `false`, lança um erro.\n * @returns {boolean|null} Retorna `true` se `dateA` for anterior (ou igual, se `considerEquals` for `true`) a `dateB`. Retorna `null` em caso de erro com `ignoreErrors` ativado.\n * @throws {TypeError} Lança um erro se `dateA` ou `dateB` não forem objetos Date e `ignoreErrors` for `false`.\n */\nfunction dateCompareAsc(dateA, dateB, options = {}) {\n  // 1. Configuração e Validação dos Parâmetros\n  const finalOptions = {\n    considerHMS: false,\n    ignoreErrors: false,\n    considerEquals: false,\n    ...options,\n  };\n\n  if (!(dateA instanceof Date) || !(dateB instanceof Date)) {\n    if (finalOptions.ignoreErrors) {\n      return null;\n    }\n    // Lança um erro mais específico (TypeError) para o tipo de problema.\n    const paramName = !(dateA instanceof Date) ? \"dateA\" : \"dateB\";\n    throw new TypeError(\n      `dateCompareAsc Function: ${paramName} provided is not a Date Object`\n    );\n  }\n\n  // 2. Lógica de Comparação\n  // O bloco try/catch é mantido para lidar com datas inválidas (ex: new Date('string-invalida')),\n  // que são instâncias de Date, mas cujos métodos (getFullYear, etc.) lançam erros.\n  try {\n    let timeA;\n    let timeB;\n\n    // Remove a parte de horas, minutos e segundos, se a opção estiver desativada.\n    if (!finalOptions.considerHMS) {\n      timeA = new Date(\n        dateA.getFullYear(),\n        dateA.getMonth(),\n        dateA.getDate()\n      ).getTime();\n      timeB = new Date(\n        dateB.getFullYear(),\n        dateB.getMonth(),\n        dateB.getDate()\n      ).getTime();\n    } else {\n      timeA = dateA.getTime();\n      timeB = dateB.getTime();\n    }\n\n    // A expressão booleana combina as duas condições para um retorno verdadeiro.\n    // 1. timeA é estritamente menor que timeB.\n    // 2. timeA é igual a timeB E a opção 'considerEquals' está ativada.\n    return timeA < timeB || (timeA === timeB && finalOptions.considerEquals);\n  } catch (error) {\n    if (finalOptions.ignoreErrors) {\n      return null;\n    }\n    // Re-lança o erro original se a opção de ignorar não estiver ativa.\n    throw error;\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\nexport default dateCompareAsc;\n// ------------------------------------------------------------------------------------------------\n","/**\n * @fileoverview Fornece uma função para comparar se uma data é posterior a outra.\n * O código é compatível com ambientes Node.js e navegadores.\n */\n\n/**\n * Compara duas datas para determinar se a primeira (dateA) é posterior à segunda (dateB).\n *\n * @summary Verifica se a data A é posterior à data B.\n * @description Esta função compara duas instâncias de Date. Ela oferece opções para\n * ignorar a parte de horas/minutos/segundos, incluir datas iguais na validação e\n * controlar o comportamento em caso de erro.\n *\n * @param {Date} dateA A data que se espera ser a mais recente.\n * @param {Date} dateB A data que se espera ser a mais antiga.\n * @param {object} [options={}] Opções para customizar o comportamento da comparação.\n * @param {boolean} [options.considerHMS=false] Se `true`, a comparação inclui horas, minutos e segundos. Se `false`, apenas ano, mês e dia são considerados.\n * @param {boolean} [options.considerEquals=false] Se `true`, a função retorna `true` caso as datas sejam idênticas. Se `false`, retorna `false`.\n * @param {boolean} [options.ignoreErrors=false] Se `true`, retorna `null` caso os parâmetros não sejam instâncias de Date. Se `false`, lança um erro.\n * @returns {boolean|null} Retorna `true` se `dateA` for posterior (ou igual, se `considerEquals` for `true`) a `dateB`. Retorna `null` em caso de erro com `ignoreErrors` ativado.\n * @throws {Error} Lança um erro se `dateA` ou `dateB` não forem objetos Date e `ignoreErrors` for `false`.\n */\nfunction dateCompareDesc(dateA, dateB, options = {}) {\n  // 1. Configuração e Validação dos Parâmetros\n  const finalOptions = {\n    considerHMS: false,\n    ignoreErrors: false,\n    considerEquals: false,\n    ...options,\n  };\n\n  // Valida 'dateA' e mantém a mensagem de erro original.\n  if (!(dateA instanceof Date)) {\n    if (finalOptions.ignoreErrors) {\n      return null;\n    }\n    throw new Error(\n      \"dateCompareDesc Function: dateA provided is not a Date Object\"\n    );\n  }\n\n  // Valida 'dateB' e mantém a mensagem de erro original.\n  if (!(dateB instanceof Date)) {\n    if (finalOptions.ignoreErrors) {\n      return null;\n    }\n    throw new Error(\n      \"dateCompareDesc Function: dateB provided is not a Date Object\"\n    );\n  }\n\n  // 2. Lógica de Comparação\n  try {\n    let timeA;\n    let timeB;\n\n    // Remove a parte de horas, minutos e segundos, se a opção estiver desativada.\n    if (!finalOptions.considerHMS) {\n      timeA = new Date(\n        dateA.getFullYear(),\n        dateA.getMonth(),\n        dateA.getDate()\n      ).getTime();\n      timeB = new Date(\n        dateB.getFullYear(),\n        dateB.getMonth(),\n        dateB.getDate()\n      ).getTime();\n    } else {\n      timeA = dateA.getTime();\n      timeB = dateB.getTime();\n    }\n\n    // A expressão booleana combina as duas condições para um retorno verdadeiro.\n    // 1. timeA é estritamente maior que timeB.\n    // 2. timeA é igual a timeB E a opção 'considerEquals' está ativada.\n    return timeA > timeB || (timeA === timeB && finalOptions.considerEquals);\n  } catch (error) {\n    if (finalOptions.ignoreErrors) {\n      return null;\n    }\n    // Re-lança o erro original se a opção de ignorar não estiver ativa.\n    throw error;\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\nexport default dateCompareDesc;\n// ------------------------------------------------------------------------------------------------\n","/**\n * @fileoverview Fornece uma função para retornar um valor numérico válido ou um valor\n * padrão caso o valor principal seja inválido.\n */\n\n/**\n * Retorna um valor numérico válido ou o valor padrão (`defaultValue`) caso o valor\n * verificado (`checkValue`) não seja um número finito ou seja menor que 1.\n *\n * @summary Retorna um valor numérico válido ou o valor padrão fornecido.\n * @description Esta função garante que o valor retornado seja um número inteiro, finito\n * e maior ou igual a 1. Caso contrário, retorna o valor padrão fornecido. É útil para\n * cenários onde limites, quantidades ou índices não podem ser negativos, nulos, NaN ou infinitos.\n *\n * @param {*} checkValue - O valor a ser verificado.\n * @param {number} defaultValue - O valor padrão a ser retornado caso `checkValue` seja inválido.\n * @returns {number} Retorna o número validado ou `defaultValue` caso `checkValue` seja inválido.\n * @example\n * // Casos de substituição\n * defaultNumeric(\"abc\", 10);     // Retorna 10\n * defaultNumeric(NaN, 5);        // Retorna 5\n * defaultNumeric(-3, 1);         // Retorna 1\n * defaultNumeric(Infinity, 2);   // Retorna 2\n *\n * // Casos válidos\n * defaultNumeric(7, 1);          // Retorna 7\n * defaultNumeric(\"12\", 1);       // Retorna 12\n * defaultNumeric(1.9, 1);        // Retorna 1 (arredondado para baixo)\n */\nfunction defaultNumeric(checkValue, defaultValue) {\n  const num = Number(checkValue);\n  return Number.isFinite(num) && !isNaN(num) ? num : defaultValue;\n}\n\n// ------------------------------------------------------------------------------------------------\nexport default defaultNumeric;\n// ------------------------------------------------------------------------------------------------\n","/**\n * @fileoverview Fornece uma função para retornar um valor padrão caso o valor\n * principal seja nulo ou indefinido.\n */\n\n/**\n * Retorna um valor padrão (`defaultValue`) se o valor verificado (`checkValue`) for `null` ou `undefined`.\n *\n * @summary Retorna um valor padrão para valores nulos ou indefinidos.\n * @description Esta função é um substituto seguro para o operador `||` em casos onde valores\n * como `0`, `false` ou `''` (string vazia) são considerados válidos e não devem ser\n * substituídos pelo valor padrão.\n *\n * @param {*} checkValue - O valor a ser verificado.\n * @param {*} defaultValue - O valor padrão a ser retornado caso `checkValue` seja `null` ou `undefined`.\n * @returns {*} Retorna `checkValue` se ele não for nulo ou indefinido; caso contrário, retorna `defaultValue`.\n * @example\n * // Casos de substituição\n * defaultValue(null, \"padrão\");       // Retorna \"padrão\"\n * defaultValue(undefined, 100);    // Retorna 100\n *\n * // Casos de não substituição (valores \"falsy\" válidos)\n * defaultValue(0, 10);               // Retorna 0\n * defaultValue(\"\", \"texto\");         // Retorna \"\"\n * defaultValue(false, true);         // Retorna false\n *\n * // Caso com valor válido\n * defaultValue(\"olá\", \"mundo\");      // Retorna \"olá\"\n */\nfunction defaultValue(checkValue, defaultValue) {\n  // O operador de coalescência nula (??) executa a mesma lógica da função original\n  // de forma nativa, concisa e performática.\n  return checkValue ?? defaultValue;\n}\n\n// ------------------------------------------------------------------------------------------------\nexport default defaultValue;\n// ------------------------------------------------------------------------------------------------\n","/**\n * @fileoverview Fornece uma função utilitária que encapsula o operador nativo \"instanceof\".\n */\n\n/**\n * Verifica se um objeto é uma instância de um determinado tipo (construtor).\n *\n * @summary Verifica se um objeto pertence a uma determinada classe ou tipo.\n * @description Esta função é um encapsulamento direto do operador `instanceof` do JavaScript.\n * Ele verifica se a propriedade `prototype` de um construtor aparece em algum lugar\n * na cadeia de protótipos de um objeto.\n *\n * @param {*} object - O objeto a ser verificado.\n * @param {Function} instanceType - O construtor (classe) contra o qual o objeto será verificado.\n * @returns {boolean} Retorna `true` se o objeto for uma instância do tipo fornecido; caso contrário, `false`.\n * @throws {TypeError} Lança um erro se `instanceType` não for um objeto com um construtor\n * (ex: `null`, `undefined`), replicando o comportamento nativo do operador `instanceof`.\n *\n * @example\n * // Usando construtores nativos\n * isInstanceOf(new Date(), Date);     // Retorna true\n * isInstanceOf([], Array);           // Retorna true\n * isInstanceOf(\"texto\", String);     // Retorna false (primitivas não são instâncias diretas)\n *\n * // Usando classes personalizadas\n * class Carro {}\n * const meuCarro = new Carro();\n * isInstanceOf(meuCarro, Carro);      // Retorna true\n */\nfunction isInstanceOf(object, instanceType) {\n  // A função é um encapsulamento direto do operador nativo 'instanceof'.\n  // Esta é a forma mais performática e direta de realizar a verificação.\n  return object instanceof instanceType;\n}\n\n// ------------------------------------------------------------------------------------------------\nexport default isInstanceOf;\n// ------------------------------------------------------------------------------------------------\n","/**\n * @fileoverview Fornece uma função para verificar se um valor é um número finito.\n */\n\n/**\n * Verifica se um valor fornecido é um número finito.\n *\n * @summary Verifica se um valor é um número real e finito.\n * @description Esta função determina se o valor fornecido é do tipo `number` e não é\n * `NaN`, `Infinity` ou `-Infinity`. Diferente de outras verificações como `!isNaN()`,\n * esta função não tenta converter a entrada para um número, sendo mais rigorosa e segura.\n *\n * @param {*} value - O valor a ser verificado.\n * @returns {boolean} Retorna `true` se o valor for um número finito; caso contrário, `false`.\n * @example\n * // Casos verdadeiros\n * isNumber(123);      // true\n * isNumber(-1.23);    // true\n * isNumber(0);        // true\n *\n * // Casos falsos\n * isNumber(Infinity); // false\n * isNumber(NaN);      // false\n * isNumber('123');    // false (não converte string)\n * isNumber(null);     // false\n * isNumber({});       // false\n */\nfunction isNumber(value) {\n  // A função estática Number.isFinite() já realiza as três verificações do código\n  // original de forma nativa:\n  // 1. Garante que o tipo seja 'number'.\n  // 2. Garante que não seja NaN.\n  // 3. Garante que não seja Infinity ou -Infinity.\n  return Number.isFinite(value);\n}\n\n// ------------------------------------------------------------------------------------------------\nexport default isNumber;\n// ------------------------------------------------------------------------------------------------","/**\n * @fileoverview Fornece uma função para verificar se um valor é um objeto.\n */\n\n/**\n * Verifica se um valor fornecido é um objeto, excluindo `null`.\n *\n * @summary Verifica se um valor é um objeto (mas não nulo).\n * @description Esta função retorna `true` para qualquer valor que o JavaScript considera\n * um objeto (`typeof valor === 'object'`), com a exceção explícita de `null`.\n * Note que, devido à natureza do JavaScript, isso inclui arrays e instâncias de outras\n * classes (como `Date`), mas não inclui tipos primitivos.\n *\n * @param {*} object - O valor a ser verificado.\n * @returns {boolean} Retorna `true` se o valor for um objeto e não for `null`; caso contrário, `false`.\n * @example\n * // Casos verdadeiros\n * isObject({});               // true\n * isObject({ a: 1 });       // true\n * isObject([]);               // true (arrays são objetos)\n * isObject(new Date());       // true (instâncias de classe são objetos)\n *\n * // Casos falsos\n * isObject(null);             // false (a principal exceção)\n * isObject(undefined);        // false\n * isObject(\"texto\");          // false (primitivo)\n * isObject(123);              // false (primitivo)\n * isObject(() => {});         // false (funções têm typeof 'function')\n */\nfunction isObject(object) {\n  // A verificação `object !== null` é crucial porque `typeof null` retorna 'object'.\n  // Esta linha combina as duas verificações da função original de forma mais concisa.\n  return object !== null && typeof object === \"object\";\n}\n\n// ------------------------------------------------------------------------------------------------\nexport default isObject;\n// ------------------------------------------------------------------------------------------------\n","import assign from \"./assign.js\";\nimport base64From from \"./base64From.js\";\nimport base64FromBase64URLSafe from \"./base64FromBase64URLSafe.js\";\nimport base64FromBuffer from \"./base64FromBuffer.js\";\nimport base64To from \"./base64To.js\";\nimport base64ToBuffer from \"./base64ToBuffer.js\";\nimport base64URLEncode from \"./base64URLEncode.js\";\nimport bufferCompare from \"./bufferCompare.js\";\nimport bufferConcatenate from \"./bufferConcatenate.js\";\nimport bufferFromString from \"./bufferFromString.js\";\nimport bufferToString from \"./bufferToString.js\";\nimport calculateSecondsInTime from \"./calculateSecondsInTime.js\";\nimport cleanObject from \"./cleanObject.js\";\nimport currencyBRToFloat from \"./currencyBRToFloat.js\";\nimport dateToFormat from \"./dateToFormat.js\";\nimport dateFirstHourOfDay from \"./dateFirstHourOfDay.js\";\nimport dateLastHourOfDay from \"./dateLastHourOfDay.js\";\nimport debouncer from \"./debouncer.js\";\nimport deleteKeys from \"./deleteKeys.js\";\nimport generateSimpleId from \"./generateSimpleId.js\";\nimport generateRandomString from \"./generateRandomString.js\";\nimport getExecutionTime from \"./getExecutionTime.js\";\nimport JSONFrom from \"./JSONFrom.js\";\nimport JSONTo from \"./JSONTo.js\";\nimport messageEncryptToChunks from \"./messageEncryptToChunks.js\";\nimport messageDecryptFromChunks from \"./messageDecryptFromChunks.js\";\nimport normalize from \"./normalize.js\";\nimport pickKeys from \"./pickKeys.js\";\nimport pushLogMessage from \"./pushLogMessage.js\";\nimport regexDigitsOnly from \"./regexDigitsOnly.js\";\nimport regexReplaceTrim from \"./regexReplaceTrim.js\";\nimport regexLettersOnly from \"./regexLettersOnly.js\";\nimport removeDuplicatedStrings from \"./removeDuplicatedStrings.js\";\nimport sleep from \"./sleep.js\";\nimport split from \"./split.js\";\nimport stringCompress from \"./stringCompress.js\";\nimport stringDecompress from \"./stringDecompress.js\";\nimport stringToDate from \"./stringToDate.js\";\nimport stringToDateToFormat from \"./stringToDateToFormat.js\";\nimport stringToFormat from \"./stringToFormat.js\";\nimport stringZLibCompress from \"./stringZLibCompress.js\";\nimport stringZLibDecompress from \"./stringZLibDecompress.js\";\nimport throttle from \"./throttle.js\";\nimport timestamp from \"./timestamp.js\";\nimport toString from \"./toString.js\";\nimport uint8ArrayFromString from \"./uint8ArrayFromString.js\";\nimport uint8ArrayToString from \"./uint8ArrayToString.js\";\n\n// Named exports para importação individual\nexport {\n  assign,\n  base64From,\n  base64FromBase64URLSafe,\n  base64FromBuffer,\n  base64To,\n  base64ToBuffer,\n  base64URLEncode,\n  bufferCompare,\n  bufferConcatenate,\n  bufferFromString,\n  bufferToString,\n  calculateSecondsInTime,\n  cleanObject,\n  currencyBRToFloat,\n  dateToFormat,\n  dateFirstHourOfDay,\n  dateLastHourOfDay,\n  debouncer,\n  deleteKeys,\n  generateSimpleId,\n  generateRandomString,\n  getExecutionTime,\n  JSONFrom,\n  JSONTo,\n  messageEncryptToChunks,\n  messageDecryptFromChunks,\n  normalize,\n  pickKeys,\n  pushLogMessage,\n  regexDigitsOnly,\n  regexReplaceTrim,\n  regexLettersOnly,\n  removeDuplicatedStrings,\n  sleep,\n  split,\n  stringCompress,\n  stringDecompress,\n  stringToDate,\n  stringToDateToFormat,\n  stringToFormat,\n  stringZLibCompress,\n  stringZLibDecompress,\n  throttle,\n  timestamp,\n  toString,\n  uint8ArrayFromString,\n  uint8ArrayToString\n};\n\n// Default export para compatibilidade\nexport default {\n  assign,\n  base64From,\n  base64FromBase64URLSafe,\n  base64FromBuffer,\n  base64To,\n  base64ToBuffer,\n  base64URLEncode,\n  bufferCompare,\n  bufferConcatenate,\n  bufferFromString,\n  bufferToString,\n  calculateSecondsInTime,\n  cleanObject,\n  currencyBRToFloat,\n  dateToFormat,\n  dateFirstHourOfDay,\n  dateLastHourOfDay,\n  debouncer,\n  deleteKeys,\n  generateSimpleId,\n  generateRandomString,\n  getExecutionTime,\n  JSONFrom,\n  JSONTo,\n  messageEncryptToChunks,\n  messageDecryptFromChunks,\n  normalize,\n  pickKeys,\n  pushLogMessage,\n  regexDigitsOnly,\n  regexReplaceTrim,\n  regexLettersOnly,\n  removeDuplicatedStrings,\n  sleep,\n  split,\n  stringCompress,\n  stringDecompress,\n  stringToDate,\n  stringToDateToFormat,\n  stringToFormat,\n  stringZLibCompress,\n  stringZLibDecompress,\n  throttle,\n  timestamp,\n  toString,\n  uint8ArrayFromString,\n  uint8ArrayToString,\n};","/**\n * @file Módulo para mesclar objetos de forma imutável.\n */\n\n/**\n * Cria uma cópia profunda (deep clone) de um valor.\n * Esta função auxiliar é a base para garantir a imutabilidade.\n * Ela lida com objetos, arrays e referências circulares.\n *\n * @param {*} source - O valor a ser clonado.\n * @param {WeakMap} [map=new WeakMap()] - Usado internamente para rastrear\n * referências e evitar loops infinitos em estruturas circulares.\n * @returns {*} Uma cópia profunda do valor de entrada.\n * @private\n */\nfunction deepClone(source, map = new WeakMap()) {\n  // Retorna valores primitivos e nulos, que não precisam ser clonados.\n  if (source === null || typeof source !== 'object') {\n    return source;\n  }\n\n  // Se este objeto já foi clonado (em caso de referência circular),\n  // retorna a referência do clone já existente para evitar recursão infinita.\n  if (map.has(source)) {\n    return map.get(source);\n  }\n\n  // Lida com Arrays.\n  if (Array.isArray(source)) {\n    const clone = [];\n    // Armazena o clone no mapa antes da recursão para lidar com\n    // arrays que contenham referências a si mesmos.\n    map.set(source, clone);\n    for (let i = 0; i < source.length; i++) {\n      clone[i] = deepClone(source[i], map);\n    }\n    return clone;\n  }\n\n  // Lida com Objetos.\n  const clone = {};\n  // Armazena o clone no mapa antes da recursão para lidar com\n  // objetos que contenham referências a si mesmos.\n  map.set(source, clone);\n  for (const key in source) {\n    // Garante que estamos copiando apenas as propriedades do próprio objeto.\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      clone[key] = deepClone(source[key], map);\n    }\n  }\n\n  return clone;\n}\n\n\n/**\n * Realiza uma clonagem profunda de dois objetos e, em seguida, mescla as propriedades\n * do objeto `source` no objeto `target`.\n *\n * @description\n * Esta função garante imutabilidade, pois opera em clones dos objetos de entrada,\n * deixando os originais intactos. A mesclagem em si é superficial (similar ao\n * `Object.assign`), o que significa que se uma propriedade existir em ambos os objetos,\n * a propriedade do `source` substituirá completamente a do `target`.\n *\n * @param {object} [target={}] - O objeto de destino. Suas propriedades serão a base\n * para o novo objeto.\n * @param {object} [source={}] - O objeto de origem. Suas propriedades serão mescladas\n * e irão sobrescrever as propriedades do `target` em caso de conflito.\n * @param {boolean} [throwsError=true] - Se `true`, a função lançará exceções em caso\n * de parâmetros inválidos. Se `false`, retornará `null`.\n *\n * @returns {object | null} Um novo objeto resultante da mesclagem ou `null` se\n * `throwsError` for `false` e ocorrer um erro.\n *\n * @throws {TypeError} Lançado se `target` ou `source` não forem objetos.\n * @throws {Error} Lançado se ocorrer um erro durante a operação (ex: stack overflow\n * em objetos excessivamente aninhados).\n *\n * @example\n * const defaults = { settings: { theme: 'dark', notifications: true }, user: 'admin' };\n * const userConfig = { settings: { notifications: false, timezone: 'UTC-3' } };\n *\n * const merged = assign(defaults, userConfig);\n * // Resultado:\n * // {\n * //   settings: { notifications: false, timezone: 'UTC-3' },\n * //   user: 'admin'\n * // }\n *\n * console.log(defaults.settings.theme); // 'dark' (original não foi modificado)\n */\nfunction assign(target = {}, source = {}, throwsError = true) {\n  // Validação rigorosa dos parâmetros de entrada.\n  // A verificação `param === null` é crucial, pois `typeof null` retorna 'object'.\n  if (target === null || typeof target !== 'object') {\n    if (throwsError) {\n      throw new TypeError(\"Assign Function: The target provided is not an object\");\n    }\n    return null;\n  }\n\n  if (source === null || typeof source !== 'object') {\n    if (throwsError) {\n      throw new TypeError(\"Assign Function: The source provided is not an object\");\n    }\n    return null;\n  }\n\n  try {\n    // Utiliza nossa implementação de clonagem profunda customizada e compatível.\n    // Isso garante que os objetos originais (`target` e `source`) não sejam modificados (imutabilidade).\n    const clonedTarget = deepClone(target);\n    const clonedSource = deepClone(source);\n\n    // `Object.assign` realiza a mesclagem superficial das propriedades do clone\n    // de `source` para o clone de `target`. Esta é a forma mais eficiente de\n    // combinar as propriedades no nível superior dos objetos.\n    return Object.assign(clonedTarget, clonedSource);\n  } catch (error) {\n    if (throwsError) {\n      // Repassa o erro original para fornecer um contexto de depuração mais rico.\n      throw error;\n    }\n    // Retorna null se a captura de erros estiver desativada e ocorrer uma falha.\n    return null;\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\n// Garante compatibilidade com o sistema de módulos CommonJS (Node.js).\nexport default assign;\n\n// ------------------------------------------------------------------------------------------------","/**\n * @summary Decodifica uma string Base64 para texto de forma isomórfica.\n *\n * @description\n * Esta função detecta o ambiente de execução (Node.js ou Navegador) para decodificar\n * uma string no formato Base64.\n *\n * - **No Node.js:** A função decodifica a string Base64 para uma string de texto no formato UTF-8,\n * lidando corretamente com acentuação e caracteres especiais.\n * - **No Navegador:** A função utiliza `atob()`, que decodifica a string Base64 para uma\n * \"string binária\". Cada caractere na string de saída representa um byte dos dados originais.\n *\n *\n * @param {string} [text=\"\"] - A string no formato Base64 a ser decodificada.\n * @returns {string} Uma string decodificada. No Node.js, será uma string UTF-8. No navegador,\n * será uma \"string binária\". Retorna uma string vazia se a entrada for inválida.\n */\nfunction base64From(text = \"\") {\n  if (typeof text != \"string\" || !text) {\n    return \"\";\n  }\n  if (typeof window === \"undefined\") {\n    return Buffer.from(text, \"base64\").toString(\"utf-8\");\n  }\n  return atob(text);\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default base64From;","/**\n * @file Utilitário para conversão de Base64URL para Base64 padrão.\n */\n\n/**\n * @summary Converte uma string do formato Base64URL para o formato Base64 padrão.\n *\n * @description\n * O formato Base64URL é uma variação do Base64 projetada para ser segura em URLs e nomes de arquivo.\n * Ele substitui os caracteres `+` e `/` por `-` e `_`, respectivamente, e geralmente omite o\n * preenchimento (`=`) no final da string.\n *\n * Esta função reverte essas substituições e restaura o preenchimento (`=`)\n * necessário para que a string seja uma representação Base64 válida, cujo comprimento\n * deve ser um múltiplo de 4.\n *\n * @param {string} [urlSafeBase64=\"\"] - A string em formato Base64URL a ser convertida.\n *\n * @returns {string} A string convertida para o formato Base64 padrão.\n *\n * @example\n * // Exemplo com uma string que precisa de preenchimento\n * const urlSafeString = 'rqXRQrq_mSFhX4c2wSZJrA';\n * const standardBase64 = base64FromBase64URLSafe(urlSafeString);\n * console.log(standardBase64); // \"rqXRQrq/mSFhX4c2wSZJrA==\"\n *\n * // Exemplo com uma string que não precisa de preenchimento\n * const anotherUrlSafeString = 'Zm9vYg';\n * const anotherStandardBase64 = base64FromBase64URLSafe(anotherUrlSafeString);\n * console.log(anotherStandardBase64); // \"Zm9vYg==\"\n */\nfunction base64FromBase64URLSafe(urlSafeBase64 = \"\") {\n  // Validação explícita para garantir que a entrada é uma string não vazia.\n  if (typeof urlSafeBase64 !== 'string' || urlSafeBase64.length === 0) {\n    return \"\";\n  }\n\n  // 1. Substitui os caracteres específicos do Base64URL pelos do Base64 padrão.\n  // O uso da flag /g garante que todas as ocorrências sejam substituídas.\n  const base64 = urlSafeBase64.replace(/-/g, \"+\").replace(/_/g, \"/\");\n\n  // 2. Calcula e adiciona o preenchimento ('=') de forma eficiente.\n  // O método `padEnd` é mais performático e declarativo que um loop `while`.\n  // Ele calcula quantos caracteres `=` são necessários e os adiciona de uma só vez.\n  const requiredPadding = (4 - (base64.length % 4)) % 4;\n  return base64.padEnd(base64.length + requiredPadding, \"=\");\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default base64FromBase64URLSafe;","/**\n * @file Utilitário seguro e robusto para conversão de valores para string.\n */\n\n/**\n * @summary Converte um valor de qualquer tipo para uma string de forma segura.\n *\n * @description\n * Esta função é uma versão mais robusta do construtor `String()`. Ela prioriza o método\n * `.toString()` customizado de um objeto. Apenas se um objeto não tiver um `.toString()`\n * customizado (resultando no padrão `\"[object Object]\"`), a função tentará convertê-lo\n * para uma string JSON.\n *\n * @param {*} [textObj=\"\"] - O valor a ser convertido para string.\n * @param {boolean} [objectToJSON=true] - Se `true` e a entrada for um objeto sem `.toString()`\n * customizado, tenta convertê-lo para uma string JSON.\n *\n * @returns {string} A representação do valor como string.\n *\n * @example\n * const custom = { toString: () => 'Custom!' };\n * toString(custom);           // 'Custom!'\n *\n * toString({ a: 1 });         // '{\"a\":1}'\n * toString({ a: 1 }, false);  // '[object Object]'\n * toString(123);              // '123'\n * toString(null);             // ''\n */\nfunction toString(textObj = \"\", objectToJSON = true) {\n  // 1. Lida com `null` e `undefined` primeiro, retornando uma string vazia.\n  if (textObj == null) {\n    return \"\";\n  }\n\n  // 2. Realiza a conversão inicial para string.\n  // O construtor `String()` invoca corretamente o método `.toString()` do objeto.\n  const initialString = String(textObj);\n\n  // 3. Verifica se a conversão inicial resultou na string genérica de objeto.\n  // O `typeof` previne que a string literal \"[object Object]\" seja convertida para JSON.\n  if (\n    objectToJSON &&\n    initialString === '[object Object]' &&\n    typeof textObj === 'object'\n  ) {\n    try {\n      // Se for um objeto genérico, tenta uma conversão JSON mais informativa.\n      return JSON.stringify(textObj);\n    } catch (error) {\n      // Se o JSON falhar (ex: referência circular), retorna a string genérica.\n      return initialString;\n    }\n  }\n\n  // 4. Se não for um objeto genérico (ou se for um primitivo, array, ou objeto customizado),\n  // a conversão inicial já é a correta.\n  return initialString;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default toString;","import isNumber from \"../helpers/isNumber\";\nimport toString from \"./toString\";\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @summary Codifica uma string para o formato Base64 sem padding, de forma isomórfica.\n *\n * @description\n * Esta função detecta o ambiente de execução (Node.js ou Navegador) e codifica\n * o texto de entrada para uma string Base64, removendo os caracteres de padding (`=`) no final.\n *\n * - **No Node.js:** A função é mais robusta, utilizando `Buffer.from()`. Ela pode converter\n * números para strings e aceita um `fromFormat` para especificar a codificação do texto\n * de entrada (ex: 'utf-8').\n * - **No Navegador:** A função utiliza `btoa()`, que opera sobre \"strings binárias\".\n *\n *\n * @param {string|number} [text=\"\"] - O texto a ser codificado. Se for um número, será convertido para string (apenas no Node.js).\n * @param {string} [fromFormat] - A codificação do texto de entrada (ex: 'utf-8', 'binary').\n * **Este parâmetro é utilizado apenas no ambiente Node.js.**\n * @returns {string} A string codificada em Base64, sem os caracteres de padding (`=`).\n */\nfunction base64To(text = \"\", fromFormat) {\n  let b64;\n  if (typeof window === \"undefined\") {\n    if (isNumber(text)) {\n      text = toString(text);\n    }\n    b64 = Buffer.from(text, fromFormat).toString(\"base64\");\n  } else {\n    b64 = btoa(text);\n  }\n  return b64.replaceAll(\"=\", \"\");\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default base64To;","import base64To from \"./base64To\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário para conversão de ArrayBuffer para Base64.\n */\n\n/**\n * @summary Converte um ArrayBuffer em uma string Base64.\n *\n * @description\n * Esta função é cross-environment, funcionando de forma otimizada tanto em Node.js quanto\n * em navegadores. Ela lida com a conversão de dados binários brutos de um ArrayBuffer\n * para sua representação textual em Base64.\n *\n * No navegador, a função processa o buffer em blocos (chunks) para evitar erros de\n * \"Maximum call stack size exceeded\", garantindo a conversão segura de buffers grandes.\n *\n * @param {ArrayBuffer} buffer - O ArrayBuffer a ser convertido.\n *\n * @returns {string} A representação da string em Base64. Retorna uma string vazia\n * se a entrada não for um ArrayBuffer válido.\n *\n * @example\n * const data = new Uint8Array([0, 1, 2, 3, 253, 254, 255]);\n * const base64String = base64FromBuffer(data.buffer);\n * console.log(base64String); // \"AAECA/3+/w==\"\n */\nfunction base64FromBuffer(buffer) {\n  // Adiciona validação para garantir que a entrada é do tipo esperado.\n  if (!(buffer instanceof ArrayBuffer)) {\n    return \"\";\n  }\n\n  // **Ambiente Node.js:**\n  // A verificação `typeof window` é a forma padrão de diferenciar os ambientes.\n  if (typeof window === \"undefined\") {\n    // A forma mais eficiente no Node: converte o ArrayBuffer para um Buffer nativo\n    // e delega para a função de encoding, que é otimizada para isso.\n    return base64To(Buffer.from(buffer));\n  }\n\n  // **Ambiente do Navegador (implementação robusta):**\n  const bytes = new Uint8Array(buffer);\n  const CHUNK_SIZE = 8192; // Define um tamanho de bloco seguro (8KB)\n  const chunks = [];\n\n  // Itera sobre o buffer em blocos para evitar estouro de pilha.\n  for (let i = 0; i < bytes.length; i += CHUNK_SIZE) {\n    // Pega um \"pedaço\" do buffer. `subarray` é eficiente pois não cria uma nova cópia dos dados.\n    const chunk = bytes.subarray(i, i + CHUNK_SIZE);\n\n    // Converte o bloco de bytes em uma string binária e a armazena.\n    // Usar um array e `join` no final é geralmente mais performático que concatenação com `+=`.\n    chunks.push(String.fromCharCode.apply(null, chunk));\n  }\n\n  // Junta os blocos de string em um só e passa para a função de encoding (que usará btoa).\n  return base64To(chunks.join(\"\"));\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default base64FromBuffer;","/**\n * @file Utilitário para decodificar Base64 para um ArrayBuffer.\n */\n\n/**\n * @summary Converte uma string Base64 em um ArrayBuffer, compatível com ambos ambientes.\n *\n * @description\n * Esta função decodifica uma string Base64 para sua representação binária em um ArrayBuffer.\n * A implementação é cross-environment, garantindo um comportamento consistente e\n * retornando sempre um `ArrayBuffer` tanto no Node.js quanto em navegadores.\n *\n * @param {string} [base64String=\"\"] - A string em formato Base64 a ser decodificada.\n *\n * @returns {ArrayBuffer} O `ArrayBuffer` decodificado. Retorna um `ArrayBuffer` vazio\n * (de 0 bytes) se a entrada for inválida, vazia ou se ocorrer um erro de decodificação.\n *\n * @example\n * const b64 = 'AAECAwQFBgcICQoLDA0ODw=='; // Bytes 0-15\n * const buffer = base64ToBuffer(b64);\n *\n * // `buffer` é sempre um ArrayBuffer.\n * const view = new Uint8Array(buffer);\n * console.log(view[10]); // 10\n */\nfunction base64ToBuffer(base64String = \"\") {\n  // Valida a entrada para garantir que é uma string.\n  if (typeof base64String !== 'string' || base64String.length === 0) {\n    // Retorna um ArrayBuffer vazio para entradas inválidas, conforme esperado pelos testes.\n    return new ArrayBuffer(0);\n  }\n\n  try {\n    // **Ambiente Node.js:**\n    if (typeof window === 'undefined') {\n      // Cria um Buffer do Node.js a partir da string Base64.\n      const nodeBuffer = Buffer.from(base64String, 'base64');\n\n      // Extrai o ArrayBuffer subjacente do Buffer do Node.js para manter a consistência do retorno.\n      // O `slice` é crucial para garantir que obtenhamos a porção exata da memória\n      // que corresponde a este buffer, já que o Node.js pode reutilizar pools de memória maiores.\n      return nodeBuffer.buffer.slice(\n        nodeBuffer.byteOffset,\n        nodeBuffer.byteOffset + nodeBuffer.byteLength\n      );\n    }\n\n    // **Ambiente do Navegador:**\n    // Decodifica a string Base64 para uma \"string binária\".\n    const binaryString = window.atob(base64String);\n    const len = binaryString.length;\n\n    // Cria um Uint8Array (uma visão de dados sobre um ArrayBuffer) com o tamanho necessário.\n    const bytes = new Uint8Array(len);\n\n    // Popula o array de bytes com os valores numéricos correspondentes a cada caractere.\n    for (let i = 0; i < len; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n\n    // Retorna o `ArrayBuffer` subjacente, que contém os dados binários brutos.\n    return bytes.buffer;\n\n  } catch (error) {\n    // Retorna um ArrayBuffer vazio em caso de erro\n    return new ArrayBuffer(0);\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default base64ToBuffer;","import toString from \"./toString\";\nimport base64To from \"./base64To\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário para codificação no formato Base64URL.\n */\n\n/**\n * @summary Codifica uma entrada para o formato Base64URL.\n *\n * @description\n * Esta função converte qualquer valor de entrada para uma string no formato Base64URL.\n * O Base64URL é uma variação do Base64 padrão, segura para uso em URLs e nomes de arquivo,\n * pois substitui os caracteres `+` e `/` por `-` e `_`, respectivamente, e omite o\n * preenchimento final (`=`). A função é cross-environment, funcionando em Node.js e navegadores.\n *\n * @param {*} [text=\"\"] - O valor a ser codificado. Será convertido para string antes do processo.\n * @param {BufferEncoding} [fromFormat=\"utf8\"] - **(Apenas Node.js)** A codificação da entrada,\n * se for uma string em um formato diferente de UTF-8 (ex: 'hex').\n *\n * @returns {string} A string resultante no formato Base64URL.\n *\n * @example\n * // A string \"subjects?_id=1&_id=2\" contém caracteres que não são seguros em URLs.\n * const queryString = 'subjects?_id=1&_id=2';\n * const encodedQuery = base64URLEncode(queryString);\n * console.log(encodedQuery); // \"c3ViamVjdHM_X2lkPTEmX2lkPTI\"\n *\n * // A saída pode ser usada com segurança em uma URL:\n * // https://example.com/q=c3ViamVjdHM_X2lkPTEmX2lkPTI\n */\nfunction base64URLEncode(text = \"\", fromFormat = \"utf8\") {\n  // 1. Delega a conversão para string e a codificação Base64 para a função `base64To`.\n  // A função `base64To` já lida com diferentes tipos de entrada e remove o preenchimento (`=`).\n  const standardBase64 = base64To(toString(text), fromFormat);\n\n  // 2. Converte a saída do Base64 padrão para o formato URL-safe.\n  // Substitui os caracteres '+' por '-' e '/' por '_'.\n  return standardBase64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default base64URLEncode;","/**\n * @file Utilitário para comparação binária de ArrayBuffers.\n */\n\n/**\n * @summary Compara dois ArrayBuffers para verificar se contêm os mesmos bytes.\n *\n * @description\n * Realiza uma comparação binária eficiente de dois ArrayBuffers. A função é otimizada\n * para diferentes ambientes: no Node.js, utiliza o método nativo e rápido `Buffer.equals()`,\n * enquanto no navegador, emprega uma técnica de comparação por blocos para acelerar o processo.\n *\n * @param {ArrayBuffer} buffer1 - O primeiro ArrayBuffer para a comparação.\n * @param {ArrayBuffer} buffer2 - O segundo ArrayBuffer para a comparação.\n *\n * @returns {boolean} Retorna `true` se os buffers forem idênticos, caso contrário, `false`.\n *\n * @example\n * const buf1 = new Uint8Array([1, 2, 3, 4, 5]).buffer;\n * const buf2 = new Uint8Array([1, 2, 3, 4, 5]).buffer;\n * const buf3 = new Uint8Array([1, 2, 3, 4, 9]).buffer;\n *\n * console.log(bufferCompare(buf1, buf2)); // true\n * console.log(bufferCompare(buf1, buf3)); // false\n */\nfunction bufferCompare(buffer1, buffer2) {\n  if (!buffer1 || !buffer2 || buffer1.byteLength !== buffer2.byteLength) {\n    return false;\n  }\n\n  const view1 = new Uint8Array(buffer1);\n  const view2 = new Uint8Array(buffer2);\n  for (let i = 0; i < view1.length; i++) {\n    if (view1[i] !== view2[i]) return false;\n  }\n  return true;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default bufferCompare;","/**\n * @file Utilitário para concatenação de objetos \"buffer-like\".\n */\n\n/**\n * @summary Concatena dois objetos \"buffer-like\" em um novo ArrayBuffer.\n *\n * @description\n * Esta função une dois objetos que se comportam como buffers (ex: ArrayBuffer,\n * Node.js Buffer, Uint8Array). Ela cria um novo ArrayBuffer contendo os bytes\n * do primeiro buffer seguidos pelos bytes do segundo. A implementação é robusta,\n * segura e universalmente compatível com Node.js e navegadores.\n *\n * @param {ArrayBuffer | Buffer | Uint8Array | null} buffer1 - O primeiro objeto buffer-like.\n * @param {ArrayBuffer | Buffer | Uint8Array | null} buffer2 - O segundo objeto buffer-like.\n *\n * @returns {ArrayBuffer | null} Um novo ArrayBuffer contendo a concatenação dos dois,\n * ou `null` se alguma das entradas for `null` ou se ocorrer um erro.\n *\n * @example\n * const buf1 = new Uint8Array([1, 2]).buffer;\n * const buf2 = new Uint8Array([3, 4]);\n * const combined = bufferConcatenate(buf1, buf2); // -> Retorna ArrayBuffer com [1, 2, 3, 4]\n *\n * const invalid = bufferConcatenate(buf1, null); // -> Retorna null\n */\nfunction bufferConcatenate(buffer1, buffer2) {\n  // 1. Validação explícita para `null` ou `undefined`.\n  // A verificação `== null` é uma forma concisa de tratar ambos os casos.\n  if (buffer1 == null || buffer2 == null) {\n    return buffer1 || buffer2 || null;\n  }\n\n  try {\n    // 2. Implementação Universal com Uint8Array.\n    // O construtor do `Uint8Array` lida nativamente com diversos tipos de buffer.\n    const view1 = new Uint8Array(buffer1);\n    const view2 = new Uint8Array(buffer2);\n\n    // Cria uma nova visão com o tamanho combinado.\n    const resultView = new Uint8Array(view1.length + view2.length);\n\n    // Copia os bytes de forma eficiente para a nova visão.\n    resultView.set(view1, 0);\n    resultView.set(view2, view1.length);\n\n    // Retorna o ArrayBuffer subjacente.\n    return resultView.buffer;\n  } catch (error) {\n    // Captura quaisquer outros erros que possam ocorrer com tipos de entrada inesperados\n    // e retorna `null` para indicar a falha.\n    return null;\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default bufferConcatenate;","/**\n * @file Utilitário para converter uma string para um buffer de bytes.\n */\n\n/**\n * @summary Converte uma string para um buffer de bytes (`Uint8Array`).\n *\n * @description\n * Esta função converte uma string de texto para sua representação binária, retornando um `Uint8Array`.\n * A função é universalmente compatível, usando `Buffer` no Node.js e `TextEncoder` no navegador.\n *\n * O objeto `Buffer` do Node.js é uma subclasse de `Uint8Array`, então o tipo de retorno\n * é consistente e interoperável entre os dois ambientes.\n *\n * @param {string} txtString - A string a ser convertida para um buffer.\n * @param {BufferEncoding} [encoding=\"utf-8\"] - **(Apenas Node.js)** A codificação a ser usada.\n * **No ambiente do navegador, este parâmetro é ignorado e a codificação será sempre UTF-8**,\n * devido a limitações da API `TextEncoder`.\n *\n * @returns {Uint8Array | null} Um `Uint8Array` representando os bytes da string.\n * Retorna `null` se a entrada não for uma string.\n *\n * @example\n * const buffer = bufferFromString('Olá, Mundo! 👋');\n *\n * // `buffer` será um `Buffer` no Node.js e um `Uint8Array` no navegador,\n * // mas ambos se comportam como um Uint8Array.\n * console.log(buffer.length); // 17\n * console.log(buffer[0]); // 79 ('O')\n * console.log(buffer[12]); // 240 (primeiro byte do emoji 👋)\n */\nfunction bufferFromString(txtString, encoding = \"utf-8\") {\n  // 1. Validação de tipo: garante que a entrada é uma string.\n  if (typeof txtString !== 'string') {\n    return null;\n  }\n\n  // **Ambiente Node.js:**\n  if (typeof window === 'undefined') {\n    // `Buffer.from` é a forma otimizada de criar um buffer no Node.js e\n    // respeita o parâmetro `encoding`. O Buffer resultante já é uma instância de Uint8Array.\n    return Buffer.from(txtString, encoding);\n  }\n\n  // **Ambiente do Navegador:**\n  // `TextEncoder` é a API padrão da web para converter strings em bytes.\n  // O método `.encode()` retorna diretamente um `Uint8Array`.\n  return new TextEncoder().encode(txtString).buffer;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default bufferFromString;","/**\n * @file Utilitário para converter um buffer de bytes para uma string.\n */\n\n/**\n * @summary Converte um buffer de bytes (`ArrayBuffer`, `Buffer`, etc.) para uma string.\n *\n * @description\n * Esta função converte dados binários para sua representação como string de texto.\n * A função é universalmente compatível, usando o método `toString()` do `Buffer` no Node.js\n * e a API `TextDecoder` no navegador.\n *\n * @param {ArrayBuffer | Buffer | Uint8Array} buffer - O buffer a ser convertido para string.\n * @param {BufferEncoding} [encoding=\"utf-8\"] - **(Apenas Node.js)** A codificação a ser usada\n * para interpretar os bytes. Exemplos: 'utf-8', 'hex', 'base64', 'latin1'.\n * **No ambiente do navegador, este parâmetro é ignorado e a decodificação será sempre UTF-8**,\n * devido a limitações da API `TextDecoder`.\n *\n * @returns {string} A string resultante da decodificação do buffer. Retorna uma string vazia\n * se a entrada for inválida ou vazia.\n *\n * @example\n * // Criando um buffer a partir de uma string (exemplo)\n * const myBuffer = new TextEncoder().encode('Olá, Mundo! 👋');\n *\n * const text = bufferToString(myBuffer);\n * console.log(text); // \"Olá, Mundo! 👋\"\n *\n * // Exemplo específico do Node.js com 'hex'\n * // const hexBuffer = Buffer.from('4f6c612c204d756e646f2120f09f918b', 'hex');\n * // const textFromHex = bufferToString(hexBuffer, 'utf-8'); // \"Olá, Mundo! 👋\"\n */\nfunction bufferToString(buffer, encoding = \"utf-8\") {\n  // 1. Validação da entrada: retorna string vazia para entradas nulas ou indefinidas.\n  if (buffer == null) {\n    return \"\";\n  }\n\n  // **Ambiente Node.js:**\n  if (typeof window === 'undefined') {\n    // Garante que estamos trabalhando com um Buffer do Node.js para usar seu método `toString`.\n    const nodeBuffer = Buffer.isBuffer(buffer) ? buffer : Buffer.from(buffer);\n    // Usa o método nativo do Buffer, que é otimizado e suporta múltiplos encodings.\n    return nodeBuffer.toString(encoding);\n  }\n\n  // **Ambiente do Navegador:**\n  try {\n    // `TextDecoder` é a API padrão da web para converter bytes em string.\n    // Ela sempre decodifica como UTF-8, ignorando o parâmetro `encoding`.\n    return new TextDecoder().decode(buffer);\n  } catch (error) {\n    // Retorna uma string vazia se o buffer de entrada for inválido para a API.\n    return \"\";\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default bufferToString;","/**\n * @file Utilitário para calcular timestamps baseados em segundos.\n */\n\n/**\n * @summary Calcula um timestamp futuro ou passado a partir do tempo atual.\n *\n * @description\n * Esta função adiciona ou subtrai um determinado número de segundos do tempo atual\n * (`Date.now()`) e retorna o resultado como um timestamp numérico (milissegundos\n * desde a Época Unix). A operação é puramente aritmética, garantindo alta performance.\n *\n * @param {number} seconds - O número de segundos a ser adicionado ou subtraído.\n * Deve ser um número finito.\n * @param {boolean} [add=true] - Determina a operação. Se `true`, os segundos são\n * adicionados (calculando um tempo futuro). Se `false`, são subtraídos\n * (calculando um tempo passado).\n *\n * @returns {number | null} O timestamp calculado em milissegundos, ou `null` se\n * o valor de `seconds` for inválido.\n *\n * @example\n * // Calcula o timestamp para 5 minutos (300 segundos) no futuro\n * const fiveMinutesFromNow = calculateSecondsInTime(300);\n * console.log(`Timestamp em 5 minutos: ${fiveMinutesFromNow}`);\n *\n * // Calcula o timestamp para 1 hora (3600 segundos) no passado\n * const oneHourAgo = calculateSecondsInTime(3600, false);\n * console.log(`Timestamp de 1 hora atrás: ${oneHourAgo}`);\n */\nfunction calculateSecondsInTime(seconds, add = true) {\n  // 1. Validação: garante que `seconds` é um número válido e finito.\n  // `isFinite` trata casos como `Infinity`, `-Infinity` e `NaN`.\n  if (typeof seconds !== 'number' || !isFinite(seconds)) {\n    return null;\n  }\n\n  // 2. Converte a entrada de segundos para milissegundos.\n  const offsetInMilliseconds = seconds * 1000;\n\n  // 3. Aplica a operação e retorna o timestamp final.\n  // Esta abordagem é mais direta e performática do que criar um novo objeto `Date`.\n  if (add) {\n    return Date.now() + offsetInMilliseconds;\n  }\n\n  return Date.now() - offsetInMilliseconds;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default calculateSecondsInTime;","/**\n * @fileoverview Fornece uma função para \"limpar\" um objeto, removendo chaves\n * com valores considerados vazios, nulos ou indesejados.\n */\n\n/**\n * @summary Cria uma cópia \"limpa\" de um objeto, removendo chaves com valores vazios de forma segura e performática.\n *\n * @description\n * Itera sobre as chaves de um objeto (incluindo `Symbol`s) e retorna uma nova cópia contendo apenas as\n * chaves com valores considerados \"válidos\". Por padrão, `undefined`, `null`, strings vazias, arrays\n * vazios e objetos que se tornam vazios após a limpeza são removidos.\n * Tipos complexos como `Date` e `RegExp` são preservados como valores válidos.\n *\n * A função é segura contra referências circulares; estruturas cíclicas são interrompidas\n * e as propriedades que causam o ciclo são removidas do resultado final.\n *\n * @param {any} sourceObject - O objeto a ser limpo. Se não for um objeto \"simples\" (plain object), será retornado diretamente.\n * @param {object} [options={}] - Opções para customizar o comportamento da limpeza.\n * @property {boolean} [options.recursive=true] - Se `true`, a função será aplicada recursivamente a\n * objetos aninhados. Se `false`, objetos aninhados são mantidos como estão.\n * @property {boolean} [options.considerNullValue=false] - Se `false` (padrão), chaves com valor `null`\n * são removidas. Se `true`, são mantidas.\n * @property {boolean} [options.considerFalseValue=true] - Se `true` (padrão), chaves com valor `false`\n * são mantidas. Se `false`, são removidas.\n *\n * @returns {object|any} Um novo objeto \"limpo\" ou o valor original se a entrada não for um objeto.\n *\n * @example\n * // Exemplo com Symbol e RegExp\n * const sym = Symbol('id');\n * const complexObj = {\n * [sym]: 'valor-do-symbol',\n * regex: /abc/g,\n * a: 1,\n * b: null\n * };\n * const cleanedComplex = cleanObject(complexObj);\n * // Retorna: { [sym]: 'valor-do-symbol', regex: /abc/g, a: 1 }\n * console.log(cleanedComplex);\n */\nfunction cleanObject(sourceObject, options = {}) {\n  // O WeakMap rastreia os objetos já visitados para evitar ciclos infinitos.\n  const cache = new WeakMap();\n\n  // Função interna recursiva que faz o trabalho principal.\n  function _clean(currentObject) {\n    // Valores que não são \"plain objects\" (como Date, RegExp, arrays, primitivos)\n    // são tratados como valores finais e não devem ser iterados.\n    if (\n      currentObject === null ||\n      typeof currentObject !== 'object' ||\n      currentObject.constructor !== Object\n    ) {\n      return currentObject;\n    }\n    \n    // Se o objeto já foi visitado nesta chamada, é uma referência circular.\n    // Retorna 'undefined' para que a chave que aponta para ele seja removida.\n    if (cache.has(currentObject)) {\n      return undefined;\n    }\n\n    const {\n      recursive = true,\n      considerNullValue = false,\n      considerFalseValue = true,\n    } = options || {};\n\n    const newObj = {};\n    // Adiciona o objeto ao cache antes de iterar para detectar ciclos que apontem para ele mesmo.\n    cache.set(currentObject, newObj);\n\n    // Usa-se Reflect.ownKeys para garantir que chaves do tipo Symbol sejam incluídas,\n    // ao contrário de Object.keys ou for...in.\n    for (const key of Reflect.ownKeys(currentObject)) {\n      let value = currentObject[key];\n\n      if (recursive) {\n        value = _clean(value);\n      }\n\n      const isUndefined = value === undefined;\n      const isNullAndIgnored = value === null && !considerNullValue;\n      const isFalseAndIgnored = value === false && !considerFalseValue;\n      const isEmptyString = value === '';\n      const isEmptyArray = Array.isArray(value) && value.length === 0;\n      \n      // Um objeto que se tornou vazio após a limpeza recursiva também deve ser removido.\n      const isEmptyObjectAfterCleaning = \n        value !== null &&\n        typeof value === 'object' &&\n        value.constructor === Object &&\n        Reflect.ownKeys(value).length === 0;\n\n      if (\n        !isUndefined &&\n        !isNullAndIgnored &&\n        !isFalseAndIgnored &&\n        !isEmptyString &&\n        !isEmptyArray &&\n        !isEmptyObjectAfterCleaning\n      ) {\n        newObj[key] = value;\n      }\n    }\n    \n    // Se o objeto resultante não tiver chaves, ele é considerado vazio.\n    // Retorna `undefined` para que a chave que aponta para ele seja removida no nível pai.\n    return Reflect.ownKeys(newObj).length > 0 ? newObj : undefined;\n  }\n\n  const result = _clean(sourceObject);\n\n  // CORREÇÃO: Se o resultado final da limpeza do objeto de nível superior for `undefined`\n  // (ou seja, ele ficou vazio), retorna `{}`, conforme esperado pelos testes.\n  if (result === undefined && sourceObject?.constructor === Object) {\n    return {};\n  }\n\n  return result;\n}\n\n// ------------------------------------------------------------------------------------------------\nexport default cleanObject;\n// ------------------------------------------------------------------------------------------------","import toString from \"./toString.js\";\nimport isNumber from \"../helpers/isNumber.js\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário para converter strings de moeda brasileira (BRL) para um número.\n */\n\n/**\n * @summary Converte uma string de moeda no formato brasileiro (BRL) para um número de ponto flutuante.\n *\n * @description\n * Esta função analisa uma string que representa um valor monetário em Reais (ex: \"R$ 1.234,56\")\n * e a converte para um número puro (ex: 1234.56). Se a entrada já for um número válido,\n * ela é retornada diretamente.\n *\n * @param {string | number} moneyValue - O valor monetário a ser convertido.\n *\n * @returns {number | false} O número de ponto flutuante correspondente, ou `false` se a\n * conversão falhar ou a entrada for inválida.\n *\n * @example\n * currencyBRToFloat(\"R$ 1.234,56\"); // Retorna 1234.56\n * currencyBRToFloat(\"1A23,45\");      // Retorna false\n * currencyBRToFloat(\"\");            // Retorna false\n * currencyBRToFloat(150.75);        // Retorna 150.75\n */\nfunction currencyBRToFloat(moneyValue) {\n  // 1. Validação de Entrada\n  // Retorna `false` para entradas nulas ou indefinidas.\n  if (moneyValue == null) {\n    return false;\n  }\n\n  // Se a entrada já for um número válido, retorna-o diretamente.\n  if (isNumber(moneyValue)) {\n    return moneyValue;\n  }\n\n  // 2. Limpeza e Formatação da String\n  const cleanedString = toString(moneyValue)\n    // Remove o símbolo 'R$', espaços em branco e pontos (separador de milhar).\n    .replace(/R\\$|\\s|\\./g, \"\")\n    // Substitui a vírgula (separador decimal brasileiro) por um ponto.\n    .replace(\",\", \".\");\n\n  // 3. Validação de Caracteres Inválidos\n  // Esta verificação impede que `parseFloat` interprete parcialmente uma string\n  // inválida (ex: \"1A2B\" se tornaria 1). A regex `/[^0-9.]/` procura por\n  // qualquer caractere que não seja um dígito (0-9) ou um ponto (.).\n  if (/[^0-9.]/.test(cleanedString)) {\n    return false;\n  }\n\n  // Se a string ficar vazia ou contiver apenas um ponto após a limpeza, é inválida.\n  if (cleanedString === \"\" || cleanedString === \".\") {\n    return false;\n  }\n  \n  // 4. Conversão e Validação Final\n  const result = parseFloat(cleanedString);\n\n  // Verifica se o resultado do `parseFloat` é um número finito.\n  if (isNumber(result)) {\n    return result;\n  }\n\n  // Se a conversão falhou, retorna `false`.\n  return false;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default currencyBRToFloat;","/**\n * @fileoverview Centraliza constantes de formatação e padrões para uso geral na aplicação.\n * @description Este módulo exporta formatos de data, máscaras para documentos brasileiros, e\n * expressões regulares (Regex) para validações de formato.\n */\n\n// ==============================================================================================\n// SEÇÃO: Formatos de Data (para bibliotecas como date-fns, dayjs, etc.)\n// ==============================================================================================\n\n// ----------------------------------------------------------------------------------------------\n// Padrões de Data ISO 8601\n\n/**\n * Formato de data ISO 8601 completo com timezone (UTC/Zulu).\n * @example \"2025-08-18T20:49:08.123Z\"\n */\nexport const DATE_ISO_FORMAT_TZ = `yyyy-MM-dd'T'HH:mm:ss.SSS'Z'`;\n\n/**\n * Formato de data ISO 8601 sem informação de timezone.\n * @example \"2025-08-18T20:49:08.123\"\n */\nexport const DATE_ISO_FORMAT = `yyyy-MM-dd'T'HH:mm:ss.SSS`;\n\n// ----------------------------------------------------------------------------------------------\n// Padrões de Data Brasileiros\n\n/**\n * Formato de data brasileiro (dia-mês-ano) separado por hífen.\n * @example \"18-08-2025\"\n */\nexport const DATE_BR_FORMAT_D = `dd-MM-yyyy`;\n\n/**\n * Formato de data brasileiro (dia/mês/ano) separado por barra.\n * @example \"18/08/2025\"\n */\nexport const DATE_BR_FORMAT_FS = `dd/MM/yyyy`;\n\n/**\n * Formato de data e hora brasileiro separado por hífen.\n * @example \"18-08-2025 20:49:08\"\n */\nexport const DATE_BR_HOUR_FORMAT_D = `dd-MM-yyyy HH:mm:ss`;\n\n/**\n * Formato de data e hora brasileiro separado por barra.\n * @example \"18/08/2025 20:49:08\"\n */\nexport const DATE_BR_HOUR_FORMAT_FS = `dd/MM/yyyy HH:mm:ss`;\n\n/**\n * Formato de data brasileiro (mês-ano) separado por hífen.\n * @example \"08-2025\"\n */\nexport const DATE_BR_MONTH_FORMAT_D = `MM-yyyy`;\n\n/**\n * Formato de data brasileiro (mês/ano) separado por barra.\n * @example \"08/2025\"\n */\nexport const DATE_BR_MONTH_FORMAT_FS = `MM/yyyy`;\n\n// ----------------------------------------------------------------------------------------------\n// Padrões de Data Americanos\n\n/**\n * Formato de data americano (ano-mês-dia) separado por hífen.\n * @example \"2025-08-18\"\n */\nexport const DATE_EUA_FORMAT_D = `yyyy-MM-dd`;\n\n/**\n * Formato de data americano (ano/mês/dia) separado por barra.\n * @example \"2025/08/18\"\n */\nexport const DATE_EUA_FORMAT_FS = `yyyy/MM/dd`;\n\n/**\n * Formato de data e hora americano separado por hífen.\n * @example \"2025-08-18 20:49:08\"\n */\nexport const DATE_EUA_HOUR_FORMAT_D = `yyyy-MM-dd HH:mm:ss`;\n\n/**\n * Formato de data e hora americano separado por barra.\n * @example \"2025/08/18 20:49:08\"\n */\nexport const DATE_EUA_HOUR_FORMAT_FS = `yyyy/MM/dd HH:mm:ss`;\n\n/**\n * Formato de data americano (ano-mês) separado por hífen.\n * @example \"2025-08\"\n */\nexport const DATE_EUA_MONTH_FORMAT_D = `yyyy-MM`;\n\n/**\n * Formato de data americano (ano/mês) separado por barra.\n * @example \"2025/08\"\n */\nexport const DATE_EUA_MONTH_FORMAT_FS = `yyyy/MM`;\n\n// ==============================================================================================\n// SEÇÃO: Máscaras de Formatação (para bibliotecas de input mask)\n// ==============================================================================================\n\n/**\n * Máscara para CAD/ICMS do estado do Paraná (PR).\n * @example \"90312851-11\"\n */\nexport const STRING_FORMAT_CADICMSPR = \"########-##\";\n\n/**\n * Máscara para CNPJ alfanumérico.\n * 'S' representa um caractere alfanumérico [A-Z0-9] e '#' um dígito [0-9].\n * @example \"AB.123.CD4/567E-89\"\n */\nexport const STRING_FORMAT_CNPJ = \"##.###.###/####-##\";\n\n/**\n * Máscara para CNPJ Raiz alfanumérico.\n * 'S' representa um caractere alfanumérico [A-Z0-9] e '#' um dígito [0-9].\n * @example \"AB.123.CD4\"\n */\nexport const STRING_FORMAT_CNPJ_RAIZ = \"##.###.###\";\n\n/**\n * Máscara para CPF.\n * @example \"123.456.789-00\"\n */\nexport const STRING_FORMAT_CPF = \"###.###.###-##\";\n\n/**\n * Máscara para Protocolo do estado do Paraná (PR).\n * @example \"123.456.789.1\"\n */\nexport const STRING_FORMAT_PROTOCOLPR = \"###.###.###.#\";\n\n/**\n * Máscara para CEP (Código de Endereçamento Postal).\n * @example \"80000-000\"\n */\nexport const STRING_FORMAT_CEP = \"#####-###\";\n\n/**\n * Máscara para Telefone Celular com 9 dígitos + DDD.\n * @example \"(41) 98888-8888\"\n */\nexport const STRING_FORMAT_PHONE = \"(##) # ####-####\";\n\n// ==============================================================================================\n// SEÇÃO: Expressões Regulares (Regex) para Validação de Formato\n// ==============================================================================================\n\n/**\n * Regex para validar a estrutura de um CNPJ alfanumérico.\n * Verifica 12 caracteres alfanuméricos seguidos de 2 dígitos numéricos. Case-insensitive.\n */\nexport const REGEX_CNPJ_ALPHANUMERIC = /^([A-Z\\d]){12}(\\d){2}$/i;\n\n/**\n * Regex para validar um e-mail em formato padrão.\n */\nexport const REGEX_EMAIL = /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n\n/**\n * Regex para validar um UUID v4 (usado em Chave Aleatória PIX).\n */\nexport const REGEX_UUID_V4 = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n\n/**\n * Regex para validar um número de telefone brasileiro, com ou sem o código do país (+55).\n * Aceita números de 10 (fixo) ou 11 (celular) dígitos, além do DDI.\n * @example /^(?:\\+55)?\\d{10,11}$/\n */\nexport const REGEX_PHONE_BR = /^(?:\\+55)?\\d{10,11}$/;\n\n// ==============================================================================================\n// SEÇÃO: Dados Geográficos - Brasil\n// ==============================================================================================\n\n/**\n * Objeto (chave-valor) com as siglas e nomes de todos os estados brasileiros e o Distrito Federal.\n * @example { \"PR\": \"Paraná\", \"SP\": \"São Paulo\", ... }\n */\nexport const BRAZILIAN_STATES = {\n  AC: \"Acre\",\n  AL: \"Alagoas\",\n  AP: \"Amapá\",\n  AM: \"Amazonas\",\n  BA: \"Bahia\",\n  CE: \"Ceará\",\n  DF: \"Distrito Federal\",\n  ES: \"Espírito Santo\",\n  GO: \"Goiás\",\n  MA: \"Maranhão\",\n  MT: \"Mato Grosso\",\n  MS: \"Mato Grosso do Sul\",\n  MG: \"Minas Gerais\",\n  PA: \"Pará\",\n  PB: \"Paraíba\",\n  PR: \"Paraná\",\n  PE: \"Pernambuco\",\n  PI: \"Piauí\",\n  RJ: \"Rio de Janeiro\",\n  RN: \"Rio Grande do Norte\",\n  RS: \"Rio Grande do Sul\",\n  RO: \"Rondônia\",\n  RR: \"Roraima\",\n  SC: \"Santa Catarina\",\n  SP: \"São Paulo\",\n  SE: \"Sergipe\",\n  TO: \"Tocantins\",\n};\n\n/**\n * Array com as siglas de todos os estados brasileiros e o Distrito Federal.\n * Útil para popular seletores (dropdowns) ou para validações.\n * @example [\"AC\", \"AL\", \"AP\", ...]\n */\nexport const BRAZILIAN_STATES_ABBR = [\n  \"AC\",\n  \"AL\",\n  \"AP\",\n  \"AM\",\n  \"BA\",\n  \"CE\",\n  \"DF\",\n  \"ES\",\n  \"GO\",\n  \"MA\",\n  \"MT\",\n  \"MS\",\n  \"MG\",\n  \"PA\",\n  \"PB\",\n  \"PR\",\n  \"PE\",\n  \"PI\",\n  \"RJ\",\n  \"RN\",\n  \"RS\",\n  \"RO\",\n  \"RR\",\n  \"SC\",\n  \"SP\",\n  \"SE\",\n  \"TO\",\n];\n\n// Default export para compatibilidade\nexport default {\n  // Formatos de Data ISO 8601\n  DATE_ISO_FORMAT_TZ,\n  DATE_ISO_FORMAT,\n  \n  // Formatos de Data Brasileiros\n  DATE_BR_FORMAT_D,\n  DATE_BR_FORMAT_FS,\n  DATE_BR_HOUR_FORMAT_D,\n  DATE_BR_HOUR_FORMAT_FS,\n  DATE_BR_MONTH_FORMAT_D,\n  DATE_BR_MONTH_FORMAT_FS,\n  \n  // Formatos de Data Americanos\n  DATE_EUA_FORMAT_D,\n  DATE_EUA_FORMAT_FS,\n  DATE_EUA_HOUR_FORMAT_D,\n  DATE_EUA_HOUR_FORMAT_FS,\n  DATE_EUA_MONTH_FORMAT_D,\n  DATE_EUA_MONTH_FORMAT_FS,\n  \n  // Máscaras de Formatação\n  STRING_FORMAT_CADICMSPR,\n  STRING_FORMAT_CNPJ,\n  STRING_FORMAT_CNPJ_RAIZ,\n  STRING_FORMAT_CPF,\n  STRING_FORMAT_PROTOCOLPR,\n  STRING_FORMAT_CEP,\n  STRING_FORMAT_PHONE,\n  \n  // Expressões Regulares\n  REGEX_CNPJ_ALPHANUMERIC,\n  REGEX_EMAIL,\n  REGEX_UUID_V4,\n  REGEX_PHONE_BR,\n  \n  // Dados Geográficos\n  BRAZILIAN_STATES,\n  BRAZILIAN_STATES_ABBR,\n};","import { DATE_BR_FORMAT_D } from \"../constants.js\";\nimport { format } from \"date-fns/format\";\nimport isInstanceOf from \"../helpers/isInstanceOf.js\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário para formatar objetos Date em strings usando date-fns.\n */\n\n/**\n * @summary Formata um objeto Date em uma string, com base em um padrão de formato.\n *\n * @description\n * Esta função atua como um wrapper seguro para a função `format` da biblioteca `date-fns`.\n * Ela adiciona uma camada de validação robusta para garantir que apenas objetos `Date`\n * válidos sejam passados para a função de formatação, prevenindo erros.\n *\n * @param {Date} date - O objeto `Date` a ser formatado.\n * @param {string} [stringFormat=DATE_BR_FORMAT_D] - O padrão de formatação, compatível\n * com `date-fns`. O padrão no Brasil é 'dd/MM/yyyy'.\n *\n * @returns {string | false} A string da data formatada, ou `false` se a entrada\n * não for um objeto `Date` válido.\n *\n * @example\n * const myDate = new Date('2025-08-21T15:30:45');\n * dateToFormat(myDate); // \"21/08/2025\" (usando o padrão)\n * dateToFormat(myDate, 'yyyy-MM-dd HH:mm:ss.SSS'); // \"2025-08-21 15:30:45.000\"\n * dateToFormat('texto invalido'); // false\n */\nfunction dateToFormat(date, stringFormat = DATE_BR_FORMAT_D) {\n  // 1. Validação do tipo e do valor da data.\n  // A checagem `isNaN` trata casos como `new Date('data inválida')`.\n  if (!isInstanceOf(date, Date) || isNaN(date.getTime())) {\n    // Retorna o booleano `false` para manter a consistência com os testes do projeto.\n    return false;\n  }\n\n  // 2. Delega a formatação para a função `format` da biblioteca `date-fns`.\n  // Isso garante suporte completo a todos os tokens de formato que a biblioteca oferece.\n  return format(date, stringFormat);\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default dateToFormat;","import isInstanceOf from \"../helpers/isInstanceOf.js\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário para obter o início de um dia a partir de um objeto Date.\n */\n\n/**\n * @summary Retorna uma nova data representando o início do dia (00:00:00).\n *\n * @description\n * Esta função recebe um objeto `Date` e retorna um **novo** objeto `Date` ajustado para o\n * primeiro momento daquele dia (00:00:00.000), no fuso horário local.\n *\n * A função é **não-mutável**, o que significa que o objeto `Date` original passado como\n * argumento não é modificado.\n *\n * @param {Date} date - O objeto `Date` de referência.\n *\n * @returns {Date | false} Um novo objeto `Date` representando o início do dia, ou `false`\n * se a entrada não for um objeto `Date` válido.\n *\n * @example\n * const dataOriginal = new Date('2025-08-21T15:30:00');\n * const inicioDoDia = dateFirstHourOfDay(dataOriginal); // Retorna um novo objeto Date\n *\n * const invalido = dateFirstHourOfDay('não é uma data'); // Retorna false\n */\nfunction dateFirstHourOfDay(date) {\n  // 1. Validação do tipo e do valor da data.\n  // A checagem `isNaN` trata casos como `new Date('data inválida')`.\n  if (!isInstanceOf(date, Date) || isNaN(date.getTime())) {\n    // Retorna `false` para alinhar com o comportamento esperado pelos testes.\n    return false;\n  }\n\n  // 2. Cria uma nova instância da data para evitar a mutação do objeto original.\n  const newDate = new Date(date.getTime());\n\n  // 3. Define a hora, minutos, segundos e milissegundos para zero de uma só vez.\n  // `setHours(0, 0, 0, 0)` é uma forma concisa e eficiente de zerar o tempo do dia.\n  newDate.setHours(0, 0, 0, 0);\n\n  return newDate;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default dateFirstHourOfDay;","import isInstanceOf from \"../helpers/isInstanceOf.js\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário para obter o final de um dia a partir de um objeto Date.\n */\n\n/**\n * @summary Retorna uma nova data representando o final do dia (23:59:59.999).\n *\n * @description\n * Esta função recebe um objeto `Date` e retorna um **novo** objeto `Date` ajustado para o\n * último momento daquele dia (23:59:59.999), no fuso horário local.\n *\n * A função é **não-mutável**, o que significa que o objeto `Date` original passado como\n * argumento não é modificado.\n *\n * @param {Date} date - O objeto `Date` de referência.\n *\n * @returns {Date | false} Um novo objeto `Date` representando o final do dia, ou `false`\n * se a entrada não for um objeto `Date` válido.\n *\n * @example\n * const dataOriginal = new Date('2025-08-21T15:30:00');\n * const finalDoDia = dateLastHourOfDay(dataOriginal);\n *\n * // O objeto original permanece inalterado\n * console.log(dataOriginal.toLocaleTimeString()); // \"15:30:00\"\n *\n * // O novo objeto representa o final daquele dia\n * console.log(finalDoDia.toLocaleTimeString());  // \"23:59:59\"\n */\nfunction dateLastHourOfDay(date) {\n  // 1. Validação do tipo e do valor da data.\n  // A checagem `isNaN` trata casos como `new Date('data inválida')`.\n  if (!isInstanceOf(date, Date) || isNaN(date.getTime())) {\n    return false;\n  }\n\n  // 2. Cria uma nova instância da data para evitar a mutação do objeto original.\n  const newDate = new Date(date.getTime());\n\n  // 3. Define a hora para o último momento do dia.\n  // `setHours` pode receber todos os valores de tempo, tornando o código mais conciso.\n  newDate.setHours(23, 59, 59, 999);\n\n  return newDate;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default dateLastHourOfDay;","/**\n * @file Utilitário para criar uma função \"debounced\".\n */\n\n/**\n * @summary Cria uma versão \"debounced\" de uma função, que atrasa sua execução.\n *\n * @description\n * Debounce é uma técnica que agrupa uma sequência de chamadas de uma função que ocorrem\n * rapidamente, executando-a apenas uma vez após um determinado período de inatividade.\n * É útil para controlar eventos que disparam com muita frequência, como a digitação em um\n * campo de busca, o redimensionamento da janela ou o scroll da página.\n *\n * Esta função retorna uma nova função que, ao ser invocada, reinicia um temporizador.\n * A função original (`callback`) só será executada quando o temporizador não for mais\n * reiniciado por um período igual a `timeout`.\n *\n * @param {Function} callback - A função que terá sua execução atrasada. Pode ser síncrona ou assíncrona.\n * @param {number} [timeout=1000] - O período de inatividade em milissegundos que deve\n * aguardar antes de executar o `callback`.\n *\n * @returns {(...args: any[]) => void} Uma nova função \"debounced\" que pode ser chamada no lugar da original.\n *\n * @throws {TypeError} Lança um erro se o `callback` não for uma função ou se `timeout` não for um número.\n *\n * @example\n * // Simula uma barra de busca que só pesquisa após o usuário parar de digitar.\n * const searchAPI = (query) => {\n * console.log(`Pesquisando por: \"${query}\"...`);\n * };\n *\n * const debouncedSearch = debouncer(searchAPI, 500);\n *\n * debouncedSearch('g');\n * debouncedSearch('ga');\n * debouncedSearch('gam');\n * debouncedSearch('gami');\n * // Após 500ms de inatividade, o console irá logar: \"Pesquisando por: \"gami\"...\"\n */\nfunction debouncer(callback, timeout = 1000) {\n  // 1. Validação dos parâmetros na criação da função.\n  if (typeof callback !== 'function') {\n    throw new TypeError('O callback fornecido para o debouncer deve ser uma função.');\n  }\n  if (typeof timeout !== 'number') {\n    throw new TypeError('O timeout do debouncer deve ser um número.');\n  }\n\n  // 2. Closure para manter a referência do temporizador entre as chamadas.\n  let timer;\n\n  // 3. Retorna a nova função \"debounced\".\n  // Usa uma função regular `function(...args)` para preservar o contexto `this` de quem a chama.\n  return function(...args) {\n    // Captura o contexto (`this`) e os argumentos da chamada atual.\n    const context = this;\n\n    // Cancela o temporizador anterior para reiniciar a contagem.\n    // Isso garante que o callback só execute após o período de inatividade.\n    clearTimeout(timer);\n\n    // Inicia um novo temporizador.\n    timer = setTimeout(() => {\n      // Executa o callback original, aplicando o contexto e os argumentos corretos da última chamada.\n      callback.apply(context, args);\n    }, timeout);\n  };\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default debouncer;","import isObject from \"../helpers/isObject.js\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário para remover chaves de um objeto de forma não-mutável.\n */\n\n/**\n * @summary Cria um novo objeto omitindo um conjunto de chaves especificadas.\n *\n * @description\n * Esta função recebe um objeto e um array de chaves, e retorna um **novo** objeto\n * contendo todas as propriedades do objeto original, exceto aquelas especificadas\n * no array de chaves.\n *\n * A função é **não-mutável**, o que significa que o objeto original passado como\n * argumento não é modificado.\n *\n * @param {object} [object={}] - O objeto de origem.\n * @param {string[]} [keys=[]] - Um array com os nomes (string) das chaves a serem omitidas.\n *\n * @returns {object} Um novo objeto sem as chaves especificadas.\n *\n * @example\n * const user = {\n * id: 123,\n * name: 'Arthur',\n * email: 'arthur@example.com',\n * password: 'supersecret'\n * };\n *\n * const publicUser = deleteKeys(user, ['password', 'email']);\n *\n * console.log(publicUser); // { id: 123, name: 'Arthur' }\n * console.log(user);       // O objeto original permanece inalterado\n */\nfunction deleteKeys(object = {}, keys = []) {\n  // 1. Validação da entrada.\n  if (!isObject(object)) {\n    return object;\n  }\n  if (!Array.isArray(keys)) {\n    // Retorna uma cópia rasa se o array de chaves for inválido, garantindo a não-mutação.\n    return { ...object };\n  }\n\n  // 2. Cria uma cópia rasa do objeto para evitar a mutação do original.\n  const newObject = { ...object };\n\n  // 3. Itera sobre as chaves a serem removidas e as deleta da CÓPIA.\n  for (const key of keys) {\n    delete newObject[key];\n  }\n\n  // 4. Retorna o novo objeto modificado.\n  return newObject;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default deleteKeys;","import toString from \"./toString\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário para gerar um ID de string simples.\n */\n\n/**\n * @summary Gera um ID de string simples com alta probabilidade de ser único.\n *\n * @description\n * Esta função cria um ID combinando um prefixo opcional, o timestamp atual em\n * milissegundos, e uma sequência de bytes aleatórios e criptograficamente seguros\n * convertidos para hexadecimal.\n *\n * O formato do ID resultante é: `[prefixo<separador>]<timestamp><separador><bytesAleatoriosHex>`\n *\n * A utilização de `crypto.getRandomValues` torna a parte aleatória do ID muito menos\n * previsível do que `Math.random()`, aumentando a resistência a colisões.\n *\n * @param {string | number} [id] - Um prefixo opcional para o ID. Será convertido para string.\n * @param {string} [separator=\"_\"] - O separador a ser usado entre as partes do ID.\n *\n * @returns {string} O novo ID de string gerado.\n *\n * @example\n * // Gera um ID com o prefixo \"user\"\n * // Exemplo de saída: \"user_1724276767000_a1b2c3d4e5f6\"\n * const userId = generateSimpleId(\"user\");\n *\n * // Gera um ID sem prefixo\n * // Exemplo de saída: \"1724276767000_a1b2c3d4e5f6\"\n * const eventId = generateSimpleId();\n */\nfunction generateSimpleId(id, separator = \"_\") {\n  // 1. Gera a parte aleatória do ID de forma segura.\n  // Cria um array de 6 bytes, que resultará em 12 caracteres hexadecimais.\n  const randomBytes = new Uint8Array(6);\n  globalThis.crypto.getRandomValues(randomBytes);\n\n  // Converte os bytes para uma string hexadecimal, garantindo que cada byte seja representado por 2 caracteres.\n  const randomHex = Array.from(randomBytes)\n    .map(byte => byte.toString(16).padStart(2, '0'))\n    .join('');\n\n  // 2. Constrói as partes do ID em um array para maior clareza.\n  const parts = [];\n  const idString = toString(id);\n\n  // Adiciona o prefixo apenas se ele for fornecido e não for uma string vazia.\n  if (idString) {\n    parts.push(idString);\n  }\n\n  // Adiciona o timestamp e a parte aleatória segura.\n  parts.push(Date.now());\n  parts.push(randomHex);\n\n  // 3. Junta as partes com o separador e retorna o ID final.\n  return parts.join(separator);\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default generateSimpleId;","/**\n * @file Utilitário para gerar strings aleatórias seguras.\n */\n\n// Define os conjuntos de caracteres como constantes para clareza e reutilização.\nconst CHAR_SETS = {\n  LOWERCASE: 'abcdefghijklmnopqrstuvwxyz',\n  UPPERCASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n  ACCENTED: 'àáâãçèéêìíîðñòóôõùúûý',\n  DIGITS: '0123456789',\n  SYMBOLS: '!@#$%^&*-_+=;:,.<>?'\n};\n\n/**\n * @summary Gera uma string aleatória criptograficamente segura.\n *\n * @description\n * Esta função gera uma string aleatória com um tamanho especificado, usando um conjunto de\n * caracteres customizável. Ela utiliza a Web Crypto API (`crypto.getRandomValues`),\n * que está disponível em navegadores modernos e no Node.js, para garantir que os\n * caracteres sejam selecionados de forma segura e imprevisível, tornando-a adequada\n * para gerar senhas, tokens ou outros valores sensíveis.\n *\n * @param {number} [size=32] - O comprimento da string a ser gerada.\n * @param {object} [options={}] - Opções para customizar o conjunto de caracteres.\n * @param {boolean} [options.excludeLowerCaseChars=false] - Excluir caracteres minúsculos.\n * @param {boolean} [options.excludeUpperCaseChars=false] - Excluir caracteres maiúsculos.\n * @param {boolean} [options.excludeAccentedChars=false] - Excluir caracteres acentuados.\n * @param {boolean} [options.excludeDigits=false] - Excluir dígitos numéricos.\n * @param {boolean} [options.excludeSymbols=false] - Excluir símbolos padrão.\n * @param {string} [options.includeSymbols=\"\"] - Uma string com símbolos adicionais\n * para incluir no conjunto de caracteres.\n *\n * @returns {string} A string aleatória gerada.\n */\nfunction generateRandomString(size = 32, options = {}) {\n  // 1. Define as opções padrão e as mescla com as fornecidas pelo usuário.\n  // Isso garante que o envio de opções parciais (ex: { excludeDigits: true }) funcione corretamente.\n  const defaultOptions = {\n    excludeLowerCaseChars: false,\n    excludeUpperCaseChars: false,\n    excludeAccentedChars: false,\n    excludeDigits: false,\n    excludeSymbols: false,\n    includeSymbols: \"\"\n  };\n  const finalOptions = { ...defaultOptions, ...options };\n\n  // 2. Constrói a string de caracteres válidos com base nas opções.\n  let validChars = finalOptions.includeSymbols;\n  if (!finalOptions.excludeLowerCaseChars) validChars += CHAR_SETS.LOWERCASE;\n  if (!finalOptions.excludeUpperCaseChars) validChars += CHAR_SETS.UPPERCASE;\n  if (!finalOptions.excludeAccentedChars) validChars += CHAR_SETS.ACCENTED;\n  if (!finalOptions.excludeDigits) validChars += CHAR_SETS.DIGITS;\n  if (!finalOptions.excludeSymbols) validChars += CHAR_SETS.SYMBOLS;\n\n  // Se não houver caracteres válidos ou o tamanho for zero, retorna uma string vazia.\n  if (validChars.length === 0 || size <= 0) {\n    return \"\";\n  }\n\n  // 3. Gera a string aleatória usando uma fonte criptograficamente segura.\n  const randomValues = new Uint32Array(size);\n  // `crypto.getRandomValues` preenche o array com números aleatórios seguros.\n  // `globalThis` garante compatibilidade entre Node.js, navegadores e web workers.\n  globalThis.crypto.getRandomValues(randomValues);\n\n  let result = [];\n  for (let i = 0; i < size; i++) {\n    // Usa o operador de módulo para mapear o número aleatório a um índice válido.\n    const randomIndex = randomValues[i] % validChars.length;\n    result.push(validChars[randomIndex]);\n  }\n\n  return result.join('');\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default generateRandomString;","/**\n * @file Utilitário de alta precisão para medir o tempo de execução.\n */\n\n/**\n * @summary Mede o tempo de execução com alta precisão (em milissegundos).\n *\n * @description\n * Esta função é um cronômetro de alta precisão que funciona de duas maneiras:\n * 1. **Sem argumentos:** `getExecutionTime()` - Retorna um \"token\" de tempo de alta resolução,\n * servindo como um ponto de partida para a medição.\n * 2. **Com argumento:** `getExecutionTime(startTime)` - Retorna a diferença de tempo (em milissegundos)\n * entre o momento atual e o `startTime` fornecido.\n *\n * Utiliza `process.hrtime.bigint()` no Node.js e `performance.now()` no navegador\n * para garantir a maior precisão possível em cada ambiente.\n *\n * @param {number | bigint} [time] - Opcional. Um marcador de tempo obtido previamente ao\n * chamar esta mesma função sem argumentos.\n *\n * @returns {number | bigint | string} Se `time` não for fornecido, retorna o marcador inicial (`bigint` no Node.js,\n * `number` no navegador). Se `time` for fornecido, retorna o tempo decorrido como uma `string`\n * formatada com 3 casas decimais.\n *\n * @example\n * const startTime = getExecutionTime();\n *\n * // Simula uma operação que demora ~50ms\n * await new Promise(resolve => setTimeout(resolve, 50));\n *\n * const duration = getExecutionTime(startTime);\n * console.log(`A operação demorou ${duration} ms.`); // Ex: \"A operação demorou 50.123 ms.\"\n */\nfunction getExecutionTime(time) {\n  // **Ambiente Node.js:** usa `process.hrtime.bigint()` para precisão em nanossegundos.\n  if (typeof process !== 'undefined' && typeof process.hrtime === 'function') {\n    // Modo 1: Retorna o tempo atual em nanossegundos como um BigInt para ser o marcador inicial.\n    if (time === undefined) {\n      return process.hrtime.bigint();\n    }\n\n    // Validação para o marcador de tempo do Node.js.\n    if (typeof time !== 'bigint') {\n        return '0.000';\n    }\n\n    // Modo 2: Calcula a diferença em nanossegundos.\n    const diffNanos = process.hrtime.bigint() - time;\n    // Converte a diferença para milissegundos e formata.\n    const diffMillis = Number(diffNanos) / 1e6;\n    return diffMillis.toFixed(3);\n  }\n\n  // **Ambiente do Navegador:** usa `performance.now()` para precisão em milissegundos.\n  if (typeof performance !== 'undefined' && typeof performance.now === 'function') {\n    // Modo 1: Retorna o tempo atual em milissegundos como o marcador inicial.\n    if (time === undefined) {\n      return performance.now();\n    }\n\n    // Validação para o marcador de tempo do navegador.\n    if (typeof time !== 'number' || !isFinite(time)) {\n      return '0.000';\n    }\n\n    // Modo 2: Calcula a diferença e formata.\n    const diffMillis = performance.now() - time;\n    return diffMillis.toFixed(3);\n  }\n\n  // Fallback para ambientes muito antigos (raro). Retorna o tempo atual em ms.\n  // Este modo não suporta medição de diferença de forma precisa.\n  return (Date.now()).toFixed(3);\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default getExecutionTime;","/**\n * @file Utilitário seguro para analisar (parse) strings JSON.\n */\n\n/**\n * @summary Analisa uma string JSON de forma segura, com controle sobre o lançamento de erros.\n *\n * @description\n * Esta função é um wrapper para `JSON.parse()` que simplifica o tratamento de erros.\n * Em vez de precisar envolver cada chamada em um bloco `try...catch`, você pode\n * controlar o comportamento em caso de falha através do parâmetro `throwsError`.\n *\n * @param {string} text - A string JSON a ser analisada.\n * @param {boolean} [throwsError=true] - Se `true`, a função lançará uma exceção em caso de\n * JSON inválido (comportamento padrão de `JSON.parse`). Se `false`, retornará `null`.\n *\n * @returns {any | null} O valor ou objeto JavaScript resultante da análise, ou `null` se\n * a análise falhar e `throwsError` for `false`. `JSON.parse` pode retornar qualquer\n * tipo de dado JSON válido (objetos, arrays, strings, números, etc.).\n *\n * @throws {SyntaxError | TypeError} Lança um `TypeError` se a entrada não for uma string,\n * ou um `SyntaxError` se a string for um JSON inválido (e `throwsError` for `true`).\n *\n * @example\n * const jsonValido = '{\"id\": 1, \"name\": \"Arthur\"}';\n * const jsonInvalido = '{\"id\": 1, name: \"Arthur\"}'; // `name` sem aspas\n *\n * // Comportamento seguro (retorna null em caso de erro)\n * const resultado = JSONFrom(jsonInvalido, false);\n * console.log(resultado); // null\n *\n * // Comportamento padrão (lança erro)\n * try {\n * JSONFrom(jsonInvalido, true);\n * } catch (e) {\n * console.error(e.message); // Unexpected token n in JSON at position 11...\n * }\n *\n * const objeto = JSONFrom(jsonValido);\n * console.log(objeto.name); // \"Arthur\"\n */\nfunction JSONFrom(text, throwsError = true) {\n  // 1. Validação do tipo de entrada. `JSON.parse` espera uma string.\n  if (typeof text !== \"string\") {\n    if (throwsError) {\n      throw new TypeError(\"A entrada para JSONFrom deve ser uma string.\");\n    }\n    return null;\n  }\n\n  try {\n    // 2. Tenta analisar a string.\n    return JSON.parse(text);\n  } catch (error) {\n    // 3. Lida com erros de análise com base na opção fornecida.\n    if (throwsError) {\n      // Re-lança o erro original de `JSON.parse`.\n      throw error;\n    }\n\n    // Se os erros não devem ser lançados, retorna null.\n    return null;\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default JSONFrom;\n","/**\n * @file Utilitário seguro para converter valores JavaScript em strings JSON.\n */\n\n/**\n * @summary Converte um valor JavaScript para uma string JSON de forma segura.\n *\n * @description\n * Esta função é um wrapper para `JSON.stringify()` que simplifica o tratamento de erros.\n * `JSON.stringify` pode lançar uma exceção ao tentar serializar estruturas com\n * referências circulares ou valores `BigInt`. Esta função permite capturar esses erros\n * e retornar `null` em vez de quebrar a execução do programa.\n *\n * @param {any} object - O valor JavaScript (objeto, array, primitivo, etc.) a ser convertido.\n * @param {boolean} [throwsError=true] - Se `true`, a função lançará uma exceção em caso de\n * erro na serialização. Se `false`, retornará `null`.\n *\n * @returns {string | null} A string JSON resultante, ou `null` se a serialização falhar e\n * `throwsError` for `false`.\n *\n * @throws {TypeError} Lança um `TypeError` se o valor contiver referências circulares\n * ou um `BigInt` (e `throwsError` for `true`).\n *\n * @example\n * const user = { id: 1, name: 'Arthur' };\n * const jsonString = JSONTo(user);\n * console.log(jsonString); // '{\"id\":1,\"name\":\"Arthur\"}'\n *\n * // Exemplo com referência circular, que normalmente quebraria a aplicação\n * const obj = { name: 'obj' };\n * obj.self = obj;\n *\n * // Comportamento seguro (retorna null)\n * const resultado = JSONTo(obj, false);\n * console.log(resultado); // null\n *\n * // Comportamento padrão (lança erro)\n * try {\n * JSONTo(obj, true);\n * } catch (e) {\n * console.error(e.message); // Ex: \"Converting circular structure to JSON...\"\n * }\n */\nfunction JSONTo(object = {}, throwsError = true) {\n  try {\n    // 1. Tenta converter o valor para uma string JSON.\n    return JSON.stringify(object);\n  } catch (error) {\n    // 2. Lida com erros de serialização (ex: referências circulares).\n    if (throwsError) {\n      // Re-lança o erro original, mantendo o comportamento padrão do JavaScript.\n      throw error;\n    }\n\n    // Se os erros não devem ser lançados, retorna null.\n    return null;\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default JSONTo;","/**\n * Retrieves the appropriate cryptographic module for the current environment.\n *\n * This function performs environment detection to determine whether the code is executing\n * in a browser or Node.js environment, then returns the corresponding cryptographic module.\n * The function prioritizes browser environments when `window` is available, falling back\n * to Node.js crypto module when running in server-side environments.\n *\n * @returns {Crypto|Object} The cryptographic module appropriate for the current environment:\n *                          - Browser: Returns `window.crypto` (Web Crypto API)\n *                          - Node.js: Returns the native `crypto` module\n *\n * @throws {Error} When cryptographic capabilities are unavailable:\n *                 - Browser: When `window.crypto` is undefined (typically HTTP contexts)\n *                 - Node.js: When the `crypto` module cannot be loaded\n *\n * @example\n * // Browser environment - Web Crypto API usage\n * const crypto = getCrypto();\n * const encoder = new TextEncoder();\n * const data = encoder.encode('hello world');\n * crypto.subtle.digest('SHA-256', data).then(hash => {\n *   console.log(new Uint8Array(hash));\n * });\n *\n * @example\n * // Node.js environment - crypto module usage\n * const crypto = getCrypto();\n * const hash = crypto.createHash('sha256')\n *   .update('hello world', 'utf8')\n *   .digest('hex');\n * console.log(hash);\n *\n * @example\n * // Universal usage pattern with error handling\n * try {\n *   const crypto = getCrypto();\n *   // Use crypto based on environment capabilities\n * } catch (error) {\n *   console.error('Cryptographic module unavailable:', error.message);\n * }\n */\nfunction getCrypto() {\n  // Check for browser environment by testing window object availability\n  if (typeof window !== \"undefined\" && typeof window.crypto !== \"undefined\") {\n    // Return browser's Web Crypto API\n    return window.crypto;\n  }\n  \n  // Server-side environment detected - load Node.js crypto module\n  try {\n    // Try different methods to load crypto module for maximum compatibility\n    \n    // Method 1: Try global require (CommonJS or Node.js with createRequire)\n    if (typeof require !== 'undefined') {\n      return require('crypto');\n    }\n    \n    // ESM in Node.js (no require available)\n    if (typeof module !== \"undefined\" && module.createRequire) {\n      const require = module.createRequire(import.meta.url);\n      return require(\"crypto\");\n    }\n    \n    // If all methods fail, throw descriptive error\n    throw new Error('No method available to load crypto module in current environment');\n    \n  } catch (error) {\n    throw new Error(`Failed to load crypto module: ${error.message}`);\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\n// Export for ESM\nexport default getCrypto;","import getCrypto from './getCrypto.js';\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Imports cryptographic keys using the Web Crypto API in a cross-platform manner.\n *\n * This function provides a unified interface for importing cryptographic keys across\n * different environments (browser and Node.js). It handles the environment-specific\n * crypto module retrieval and delegates the actual key import operation to the\n * appropriate Web Crypto API implementation.\n *\n * The function supports all standard key formats and algorithms supported by the\n * Web Crypto API, including RSA, ECDSA, ECDH, AES, and HMAC keys.\n *\n * @param {string} format - The data format of the key to import. Supported values:\n *                          - 'raw': Raw key data (typically for symmetric keys)\n *                          - 'spki': SubjectPublicKeyInfo format (for public keys)\n *                          - 'pkcs8': PKCS #8 format (for private keys)\n *                          - 'jwk': JSON Web Key format\n *\n * @param {BufferSource|ArrayBuffer|Uint8Array|Object} keyData - The key material to import:\n *                          - For 'raw', 'spki', 'pkcs8': BufferSource (ArrayBuffer, Uint8Array, etc.)\n *                          - For 'jwk': JavaScript object representing the JSON Web Key\n *\n * @param {Object|string} algorithm - Algorithm specification for the key:\n *                          - Object: Detailed algorithm parameters (e.g., { name: 'RSA-PSS', hash: 'SHA-256' })\n *                          - String: Simple algorithm name (e.g., 'AES-GCM', 'RSA-OAEP')\n *\n * @param {boolean} extractable - Key extractability flag:\n *                          - true: Key can be exported using crypto.subtle.exportKey()\n *                          - false: Key cannot be extracted (more secure for sensitive keys)\n *\n * @param {string[]} keyUsages - Array of permitted key operations:\n *                          - 'encrypt', 'decrypt': For encryption/decryption operations\n *                          - 'sign', 'verify': For digital signature operations\n *                          - 'deriveKey', 'deriveBits': For key derivation operations\n *                          - 'wrapKey', 'unwrapKey': For key wrapping operations\n *\n * @returns {Promise<CryptoKey>} Promise resolving to the imported CryptoKey object.\n *                          The CryptoKey can be used with other Web Crypto API methods\n *                          for cryptographic operations based on the specified keyUsages.\n *\n * @throws {Error} Throws an error if:\n *                 - The crypto module is unavailable in the current environment\n *                 - Invalid key format or algorithm specification\n *                 - Key data is malformed or incompatible with the specified format\n *                 - Requested key usages are incompatible with the algorithm\n *                 - Environment doesn't support the specified algorithm\n *\n * @example\n * // Import RSA public key from SPKI format\n * const publicKeyData = new Uint8Array([...]); // DER-encoded SPKI data\n * const publicKey = await importCryptoKey(\n *   'spki',\n *   publicKeyData,\n *   {\n *     name: 'RSA-OAEP',\n *     hash: 'SHA-256'\n *   },\n *   false,\n *   ['encrypt']\n * );\n *\n * @example\n * // Import AES symmetric key from raw bytes\n * const keyBytes = crypto.getRandomValues(new Uint8Array(32)); // 256-bit key\n * const aesKey = await importCryptoKey(\n *   'raw',\n *   keyBytes,\n *   { name: 'AES-GCM' },\n *   true,\n *   ['encrypt', 'decrypt']\n * );\n *\n * @example\n * // Import key from JSON Web Key format\n * const jwkData = {\n *   kty: 'RSA',\n *   use: 'sig',\n *   n: '...', // base64url-encoded modulus\n *   e: 'AQAB', // base64url-encoded exponent\n *   // ... other JWK properties\n * };\n * const rsaKey = await importCryptoKey(\n *   'jwk',\n *   jwkData,\n *   { name: 'RSA-PSS', hash: 'SHA-256' },\n *   false,\n *   ['verify']\n * );\n */\nasync function importCryptoKey(format, keyData, algorithm, extractable, keyUsages) {\n  // Retrieve the appropriate crypto module for the current environment\n  const crypto = getCrypto();\n  \n  // Delegate key import operation to the Web Crypto API\n  // The subtle.importKey method handles the actual cryptographic key parsing and validation\n  return await crypto.subtle.importKey(\n    format,\n    keyData,\n    algorithm,\n    extractable,\n    keyUsages\n  );\n}\n\n// ------------------------------------------------------------------------------------------------\n\n// Export for CommonJS compatibility (Node.js)\nexport default importCryptoKey;","import getCrypto from \"./getCrypto.js\";\nimport base64FromBuffer from \"../utils/base64FromBuffer.js\";\nimport importCryptoKey from \"./importCryptoKey.js\";\nimport base64ToBuffer from \"../utils/base64ToBuffer.js\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Criptografa dados binários (Buffer/Uint8Array) usando uma chave pública RSA.\n *\n * Esta função gerencia o fluxo de criptografia completo: processa uma chave pública\n * em formato PEM, importa-a para a Web Crypto API e criptografa os dados usando\n * o algoritmo RSA-OAEP, que é o padrão da indústria para preenchimento (padding).\n *\n * @async\n * @function encryptBuffer\n *\n * @param {string} publicKey A chave pública em formato PEM. Deve ser uma string\n * válida, incluindo os cabeçalhos `-----BEGIN PUBLIC KEY-----` e `-----END PUBLIC KEY-----`.\n *\n * @param {Buffer|Uint8Array} messageBuffer Os dados binários a serem criptografados.\n * - Em Node.js, pode ser um `Buffer`.\n * - No navegador, pode ser um `Uint8Array`.\n * - O tamanho máximo dos dados é limitado pelo tamanho da chave e pelo esquema de\n * padding. Por exemplo:\n * - Chave de 2048 bits (RSA-OAEP): ~190 bytes.\n * - Chave de 4096 bits (RSA-OAEP): ~446 bytes.\n *\n * @param {object} [options={}] Opções para personalizar a importação da chave e a criptografia.\n * @property {string} [options.format='spki'] O formato da chave a ser importada.\n * Valores comuns são 'spki' (padrão) ou 'jwk'.\n * @property {RsaHashedImportParams} [options.algorithm={name: 'RSA-OAEP', hash: 'SHA-256'}]\n * O algoritmo a ser usado para a importação da chave.\n * @property {boolean} [options.extractable=true] Se a chave importada pode ser exportada.\n * @property {string[]} [options.keyUsages=['encrypt']] As operações permitidas para a chave.\n * Deve incluir 'encrypt'.\n * @property {string} [options.padding='RSA-OAEP'] O esquema de preenchimento (padding) a ser\n * usado na criptografia.\n *\n * @returns {Promise<string>} Uma Promise que resolve para uma string codificada em base64\n * contendo os dados criptografados. Retorna uma string vazia se `messageBuffer` for vazio.\n *\n * @throws {Error} Lança um erro se a chave for inválida, a mensagem exceder o\n * limite de tamanho para a chave, ou se a operação criptográfica falhar.\n *\n * @example\n * // Exemplo de uso para criptografar uma mensagem\n * const publicKeyPem = `-----BEGIN PUBLIC KEY-----\n * MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...\n * -----END PUBLIC KEY-----`;\n *\n * // No Node.js:\n * // const buffer = Buffer.from('Hello, World!');\n *\n * // No navegador:\n * // const buffer = new TextEncoder().encode('Hello, World!');\n *\n * try {\n * const encrypted = await encryptBuffer(publicKeyPem, buffer);\n * console.log('Dados criptografados (base64):', encrypted);\n * } catch (error) {\n * console.error('Falha na criptografia:', error);\n * }\n */\nasync function encryptBuffer(publicKey, messageBuffer, props = {}) {\n  // Handle empty buffer case early for performance\n  if (!messageBuffer || messageBuffer.length === 0) return \"\";\n\n  // Extract crypto module for the current environment\n  const crypto = getCrypto();\n\n  // Clean and convert PEM-formatted public key to binary format\n  const cleanedPublicKey = publicKey.replace(\n    /(-----(BEGIN|END) (RSA )?(PRIVATE|PUBLIC) KEY-----|\\s)/g,\n    \"\"\n  );\n  const binaryPublicKey = base64ToBuffer(cleanedPublicKey);\n\n  // Destructure configuration with defaults\n  const {\n    format = \"spki\",\n    algorithm = { name: \"RSA-OAEP\", hash: { name: \"SHA-256\" } },\n    extractable = true,\n    keyUsages = [\"encrypt\"],\n    padding = \"RSA-OAEP\",\n  } = props || {};\n\n  // Import the public key into Web Crypto API format\n  const importedKey = await importCryptoKey(\n    format || \"spki\",\n    binaryPublicKey,\n    algorithm || {\n      name: \"RSA-OAEP\",\n      hash: { name: \"SHA-256\" },\n    },\n    extractable !== undefined ? extractable : true,\n    keyUsages || [\"encrypt\"]\n  );\n\n  // Perform the actual encryption operation using the imported key\n  const encryptedBuffer = await crypto.subtle.encrypt(\n    { name: padding || \"RSA-OAEP\" },\n    importedKey,\n    messageBuffer\n  );\n\n  // Convert encrypted binary data to base64 for safe text transmission\n  return base64FromBuffer(encryptedBuffer);\n}\n\n// ------------------------------------------------------------------------------------------------\n\n// Export for CommonJS compatibility (Node.js)\nexport default encryptBuffer;\n","import encryptBuffer from \"../crypto/encryptBuffer\";\nimport bufferFromString from \"../utils/bufferFromString\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @summary Encripta uma mensagem em pedaços (chunks) usando RSA-OAEP.\n *\n * @description\n * Esta função assíncrona primeiro converte o payload para um buffer de bytes.\n * Em seguida, divide esse buffer em pedaços (chunks) e encripta cada um deles\n * em paralelo para máxima performance. O resultado é um array de strings, onde\n * cada uma representa um pedaço encriptado em base64.\n *\n * @param {string} publicKey - A chave pública RSA (formato string PEM) a ser usada.\n * @param {object} payload - A carga a ser encriptada.\n * @param {object} [props={}] - Propriedades adicionais para a encriptação.\n * @param {number} [props.chunkSize=190] - O tamanho máximo de cada pedaço em bytes.\n * O padrão 190 é o limite seguro para chaves RSA de 2048 bits com padding OAEP.\n *\n * @returns {Promise<string[]>} Uma Promise que resolve para um array de pedaços encriptados.\n */\nasync function messageEncryptToChunks(publicKey, payload, props = {}) {\n  if (payload === undefined || payload === null) {\n    return []; // Retornar um array vazio é mais consistente com o tipo de retorno\n  }\n  let { chunkSize } = props || {};\n  if (!isFinite(chunkSize) || chunkSize <= 0) {\n    chunkSize = 190;\n  }\n\n  const jsonPayload = JSON.stringify({ data: payload });\n  const bufferPayload = bufferFromString(jsonPayload);\n  const chunks = [];\n\n  // 1. Divide o buffer principal em vários buffers menores (chunks).\n  for (let i = 0; i < bufferPayload.length; i += chunkSize) {\n    chunks.push(bufferPayload.slice(i, i + chunkSize));\n  }\n\n  // 2. Mapeia cada chunk de buffer para uma promessa de encriptação.\n  const encryptionPromises = chunks.map((chunk) => {\n    return encryptBuffer(publicKey, chunk, props);\n  });\n\n  // 3. Executa todas as encriptações em paralelo para máxima performance.\n  return Promise.all(encryptionPromises);\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default messageEncryptToChunks;\n","import getCrypto from \"./getCrypto\";\nimport base64ToBuffer from \"../utils/base64ToBuffer\";\nimport importCryptoKey from \"./importCryptoKey.js\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Decriptografa uma mensagem em base64 usando uma chave privada RSA.\n *\n * Esta função gerencia o fluxo de decriptografia completo: processa uma chave privada\n * em formato PEM, decodifica a mensagem criptografada de base64, importa a chave\n * para a Web Crypto API e decriptografa os dados usando o algoritmo RSA-OAEP.\n *\n * @async\n * @function decryptBuffer\n *\n * @param {string} privateKey A chave privada em formato PEM. Deve ser uma string\n * válida, incluindo os cabeçalhos `-----BEGIN PRIVATE KEY-----` e `-----END PRIVATE KEY-----`.\n *\n * @param {string} encryptedMessage A mensagem criptografada e codificada em base64\n * que será decriptografada.\n *\n * @param {object} [options={}] Opções para personalizar a importação da chave e a decriptografia.\n * @property {string} [options.format='pkcs8'] O formato da chave privada a ser importada.\n * O padrão 'pkcs8' é o formato mais comum.\n * @property {RsaHashedImportParams} [options.algorithm={name: 'RSA-OAEP', hash: 'SHA-256'}]\n * O algoritmo a ser usado para a importação da chave.\n * @property {boolean} [options.extractable=true] Se a chave importada pode ser exportada.\n * @property {string[]} [options.keyUsages=['decrypt']] As operações permitidas para a chave.\n * Deve incluir 'decrypt'.\n * @property {string} [options.padding='RSA-OAEP'] O esquema de preenchimento (padding)\n * usado na decriptografia. Deve ser o mesmo usado na criptografia.\n *\n * @returns {Promise<Buffer|Uint8Array>} Uma Promise que resolve para os dados\n * decriptografados como um `Buffer` (em Node.js) ou `Uint8Array` (no navegador).\n * Retorna uma string vazia se `encryptedMessage` for vazio.\n *\n * @throws {Error} Lança um erro se a chave for inválida, a mensagem estiver\n * corrompida, ou se a operação criptográfica falhar (ex: padding incorreto).\n *\n * @example\n * // Supondo que `encryptedBase64` foi gerado pela função `encryptBuffer`\n * // e `privateKeyPem` é a chave privada correspondente.\n *\n * try {\n * const decryptedBuffer = await decryptBuffer(privateKeyPem, encryptedBase64);\n *\n * // Para visualizar o resultado como texto:\n * // No Node.js:\n * // console.log('Mensagem decriptografada:', decryptedBuffer.toString('utf8'));\n *\n * // No navegador:\n * // console.log('Mensagem decriptografada:', new TextDecoder().decode(decryptedBuffer));\n * } catch (error) {\n * console.error('Falha na decriptografia:', error);\n * }\n */\nasync function decryptBuffer(privateKey, encryptedMessage, props = {}) {\n  // Early return for empty encrypted messages\n  if (!encryptedMessage) {\n    // Retorna um Uint8Array vazio no navegador ou Buffer vazio no Node\n    return getCrypto().subtle ? new Uint8Array(0) : Buffer.alloc(0);\n  }\n\n  // Destructure configuration with defaults\n  const {\n    format = \"pkcs8\",\n    algorithm = { name: \"RSA-OAEP\", hash: { name: \"SHA-256\" } },\n    extractable = true,\n    keyUsages = [\"decrypt\"],\n    padding = \"RSA-OAEP\"\n  } = props || {};\n\n  // Get crypto implementation\n  const crypto = getCrypto();\n\n  // Clean and convert PEM private key to binary\n  const cleanedPrivateKey = privateKey.replace(\n    /-----(BEGIN|END) (?:RSA )?(?:PRIVATE|PUBLIC) KEY-----|\\s/g,\n    \"\"\n  );\n  const binaryPrivateKey = base64ToBuffer(cleanedPrivateKey);\n\n  // Import the private key\n  const importedKey = await importCryptoKey(\n    format,\n    binaryPrivateKey,\n    algorithm,\n    extractable,\n    keyUsages\n  );\n\n  // Convert base64 encrypted message to binary\n  const encryptedData = base64ToBuffer(encryptedMessage);\n\n  // Perform decryption\n  const decryptedBuffer = await crypto.subtle.decrypt(\n    { name: padding },\n    importedKey,\n    encryptedData\n  );\n\n  // Return the raw decrypted buffer\n  return decryptedBuffer;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default decryptBuffer;","import decryptBuffer from \"../crypto/decryptBuffer\";\nimport bufferToString from \"../utils/bufferToString\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @summary Decripta uma mensagem a partir de pedaços (chunks) encriptados.\n *\n * @description\n * Esta função assíncrona recebe um array de pedaços encriptados, decripta cada um\n * deles em paralelo para máxima performance, e então concatena os buffers resultantes\n * para reconstruir a mensagem original.\n *\n * @param {string} privateKey - A chave privada RSA (formato string PEM) a ser usada.\n * @param {string[]} messageChunks - Um array de strings, onde cada uma é um pedaço encriptado.\n * @param {object} [props={}] - Propriedades adicionais para a decriptação.\n *\n * @returns {Promise<any>} Uma Promise que resolve para o payload original decriptado.\n */\nasync function messageDecryptFromChunks(privateKey, messageChunks, props = {}) {\n  if (!messageChunks || messageChunks.length === 0) {\n    return \"\";\n  }\n\n  const decryptionPromises = messageChunks.map(chunk =>\n    decryptBuffer(privateKey, chunk, props)\n  );\n  const decryptedBuffers = await Promise.all(decryptionPromises);\n\n  \n  // Lógica de concatenação de alta performance.\n  // Etapa A: Calcula o tamanho total necessário para o buffer final.\n  let totalLength = 0;\n  for (const buffer of decryptedBuffers) {\n    totalLength += buffer.byteLength;\n  }\n\n  // Etapa B: Aloca um único buffer grande (Uint8Array) de uma só vez.\n  const finalBuffer = new Uint8Array(totalLength);\n\n  // Etapa C: Copia cada buffer decriptado para a sua posição correta no buffer final.\n  let offset = 0;\n  for (const buffer of decryptedBuffers) {\n    finalBuffer.set(new Uint8Array(buffer), offset);\n    offset += buffer.byteLength;\n  }\n\n  const jsonString = bufferToString(finalBuffer);\n  \n  const payload = JSON.parse(jsonString);\n\n  return payload.data;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default messageDecryptFromChunks;","import isNumber from \"../helpers/isNumber\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário para normalizar strings, removendo acentos.\n */\n\n/**\n * @summary Remove acentos e outros caracteres diacríticos de uma string.\n *\n * @description\n * Esta função converte uma string para sua forma normalizada (NFD - Normalization Form\n * Canonical Decomposition), que separa os caracteres base de seus acentos (marcas\n * diacríticas combinadas). Em seguida, uma expressão regular remove essas marcas,\n * resultando em uma string \"limpa\", sem acentuação.\n *\n * A função processa apenas entradas do tipo `string` ou `number`, retornando\n * outros tipos de dados inalterados.\n *\n * @param {string | number} [text=\"\"] - O texto a ser normalizado.\n *\n * @returns {*} A string normalizada, ou o valor original se a entrada não for\n * uma string ou número.\n *\n * @example\n * const acentuado = 'Pão de Açúcar & Linguiça';\n * const normalizado = normalize(acentuado);\n * console.log(normalizado); // \"Pao de Acucar & Linguica\"\n *\n * normalize(123.45); // Retorna a string \"123.45\"\n * normalize({ a: 1 }); // Retorna o objeto { a: 1 } inalterado\n */\nfunction normalize(text = \"\") {\n  // 1. Verifica se a entrada é um tipo que pode ser normalizado (string ou número).\n  if (isNumber(text) || typeof text === \"string\") {\n    // 2. Converte para string (caso seja número) e aplica a normalização.\n    // \"NFD\" decompõe um caractere como \"ç\" em seus componentes: \"c\" + \"¸\".\n    // A regex /[\\u0300-\\u036f]/g então remove o componente de acentuação (o intervalo\n    // Unicode para \"Combining Diacritical Marks\").\n    return String(text)\n      .normalize(\"NFD\")\n      .replace(/[\\u0300-\\u036f]/g, \"\");\n  }\n\n  // 3. Se a entrada não for do tipo esperado, retorna-a inalterada.\n  return text;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default normalize;","/**\n * @fileoverview Fornece uma função para criar um novo objeto contendo apenas um\n * subconjunto de chaves de um objeto de origem.\n */\n\n/**\n * @summary Cria um novo objeto contendo apenas as chaves especificadas de um objeto de origem.\n * @description Itera sobre um array de chaves (`keysToPick`) e constrói um novo objeto\n * com as chaves e valores correspondentes do objeto de origem (`sourceObject`).\n * Chaves que existem em `keysToPick` mas não no `sourceObject` são ignoradas.\n * A função não modifica o objeto original.\n *\n * @param {object} sourceObject - O objeto do qual as propriedades serão selecionadas.\n * @param {string[]} keysToPick - Um array de nomes de chaves (strings) a serem incluídas no novo objeto.\n * @returns {object} Um novo objeto contendo apenas as propriedades selecionadas.\n *\n * @example\n * const user = {\n * id: 123,\n * name: 'John Doe',\n * email: 'john.doe@example.com',\n * isAdmin: true,\n * lastLogin: new Date()\n * };\n *\n * const keys = ['id', 'name', 'email'];\n * const publicUserData = pickKeys(user, keys);\n *\n * // Retorna: { id: 123, name: 'John Doe', email: 'john.doe@example.com' }\n * console.log(publicUserData);\n *\n * @example\n * // Chaves não existentes são simplesmente ignoradas\n * const partialData = pickKeys(user, ['id', 'nonExistentKey']);\n * // Retorna: { id: 123 }\n * console.log(partialData);\n */\nfunction pickKeys(sourceObject, keysToPick) {\n  // Validação de entradas para garantir robustez. Retorna um objeto vazio para entradas inválidas.\n  if (\n    sourceObject === null ||\n    typeof sourceObject !== \"object\" ||\n    Array.isArray(sourceObject)\n  ) {\n    return {};\n  }\n  if (!Array.isArray(keysToPick)) {\n    return {};\n  }\n\n  // Usa reduce para construir o novo objeto de forma eficiente e funcional.\n  return keysToPick.reduce((newObj, key) => {\n    // Verifica se a chave existe como uma propriedade própria do objeto de origem.\n    // Usar Object.prototype.hasOwnProperty.call é a forma mais segura de fazer essa checagem.\n    if (Object.prototype.hasOwnProperty.call(sourceObject, key)) {\n      newObj[key] = sourceObject[key];\n    }\n    return newObj;\n  }, {});\n}\n\n// ------------------------------------------------------------------------------------------------\nexport default pickKeys;\n// ------------------------------------------------------------------------------------------------\n","/**\n * @file Utilitário para adicionar mensagens a um array de log.\n */\n\n/**\n * @typedef {object} LogEntry - Define a estrutura de uma entrada de log.\n * @property {string} time - O timestamp da entrada de log no formato ISO (UTC).\n * @property {string} message - A mensagem de log.\n * @property {*} [more_info] - Opcional. Informações adicionais ou metadados.\n */\n\n/**\n * @summary Adiciona uma nova entrada a um array de logs, modificando-o.\n *\n * @description\n * Esta função adiciona uma nova entrada de log (com timestamp, mensagem e informações\n * adicionais) diretamente a um array existente.\n *\n * **Atenção:** Esta função é **mutável**, o que significa que ela **modifica\n * diretamente** o array `logObj` passado como argumento. Se o `logObj` fornecido não\n * for um array, um novo array será criado e retornado.\n *\n * @param {LogEntry[]} logObj - O array de log a ser modificado.\n * @param {string} message - A mensagem de log a ser adicionada.\n * @param {*} [more_info] - Opcional. Qualquer informação ou objeto adicional a ser incluído no log.\n *\n * @returns {LogEntry[]} O mesmo array de log que foi passado, agora com a nova mensagem.\n *\n * @example\n * const meuLog = [{ time: '...', message: 'Serviço iniciado.' }];\n * pushLogMessage(meuLog, 'Usuário conectado.', { userId: 123 });\n *\n * // O array original FOI modificado\n * console.log(meuLog.length); // 2\n * console.log(meuLog[1].message); // \"Usuário conectado.\"\n *\n * // Se a variável de log não for um array, um novo é criado\n * let logInexistente; // undefined\n * logInexistente = pushLogMessage(logInexistente, 'Primeira mensagem.');\n * console.log(logInexistente.length); // 1\n */\nfunction pushLogMessage(logObj, message, more_info) {\n  // 1. Verifica se o `logObj` de entrada é um array.\n  // Se não for, um novo array é criado para a variável local `logObj`.\n  if (!Array.isArray(logObj)) {\n    logObj = [];\n  }\n\n  // 2. Cria a nova entrada de log.\n  const newEntry = {\n    time: new Date().toISOString(),\n    message,\n  };\n\n  // Adiciona o campo `more_info` ao objeto de log apenas se ele tiver sido fornecido.\n  if (more_info !== undefined) {\n    newEntry.more_info = more_info;\n  }\n\n  // 3. Adiciona a nova entrada diretamente ao array (mutação).\n  logObj.push(newEntry);\n\n  // 4. Retorna o array modificado.\n  return logObj;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default pushLogMessage;","import toString from \"./toString.js\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário para extrair apenas dígitos de um valor.\n */\n\n/**\n * @summary Extrai apenas os dígitos de uma string ou de outro valor.\n *\n * @description\n * Esta função recebe um valor de qualquer tipo, o converte para uma string e remove\n * todos os caracteres que não são dígitos (0-9). É útil para limpar entradas de\n * usuário, como números de telefone, CEPs ou CPFs que podem conter máscaras\n * (pontos, traços, parênteses).\n *\n * @param {*} [text=\"\"] - O valor do qual os dígitos serão extraídos.\n *\n * @returns {string} Uma string contendo apenas os dígitos do valor de entrada.\n *\n * @example\n * const phoneNumber = '(11) 98765-4321';\n * const digits = regexDigitsOnly(phoneNumber);\n * console.log(digits); // \"11987654321\"\n *\n * const price = 'R$ 19,90';\n * const priceDigits = regexDigitsOnly(price);\n * console.log(priceDigits); // \"1990\"\n *\n * regexDigitsOnly(123.45); // Retorna \"12345\"\n */\nfunction regexDigitsOnly(text = \"\") {\n  // 1. Converte a entrada para uma string de forma segura.\n  const stringValue = toString(text);\n\n  // 2. Remove todos os caracteres que não são dígitos (0-9).\n  // A regex `/[^0-9]/g` encontra qualquer caractere que não esteja no intervalo de 0 a 9\n  // e o substitui por uma string vazia.\n  return stringValue.replace(/[^0-9]/g, \"\");\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default regexDigitsOnly;","import toString from \"./toString.js\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário para substituir caracteres em uma string com base em um conjunto permitido.\n */\n\n/**\n * @summary Substitui caracteres em uma string que não pertencem a um conjunto de caracteres permitido.\n *\n * @description\n * Esta função cria dinamicamente uma expressão regular a partir de uma string que define um\n * conjunto de caracteres permitidos. Ela então remove ou substitui todos os caracteres da\n * string de entrada que não fazem parte desse conjunto. É uma ferramenta flexível\n * para limpar e sanitizar strings.\n *\n * @param {*} [text=\"\"] - O valor a ser processado, que será convertido para string.\n * @param {string} [regex=\"A-Za-zÀ-ú0-9 \"] - Uma string que define o conjunto de caracteres\n * a serem **mantidos**. Pode incluir intervalos, como `A-Z` ou `0-9`.\n * @param {string} [replacement=\"\"] - A string que substituirá cada caractere não permitido.\n * @param {boolean} [trim=true] - Se `true`, remove espaços em branco do início e do fim do resultado.\n *\n * @returns {string} A string resultante após a substituição e o trim opcional.\n *\n * @example\n * // Manter apenas letras e números, substituindo o resto por '*'\n * const text = \"Hello! @123 World_456\";\n * const allowed = \"A-Za-z0-9\";\n * const result = regexReplaceTrim(text, allowed, \"*\");\n * console.log(result); // \"Hello***123*World*456\"\n *\n * // Manter apenas letras maiúsculas e remover o resto\n * const textWithSpaces = \"   A B C   \";\n * const resultTrimmed = regexReplaceTrim(textWithSpaces, \"A-Z\", \"\");\n * console.log(resultTrimmed); // \"ABC\"\n */\nfunction regexReplaceTrim(\n  text = \"\",\n  regex = \"A-Za-zÀ-ú0-9 \",\n  replacement = \"\",\n  trim = true\n) {\n  // 1. Converte as entradas para string para garantir a operação.\n  const stringValue = toString(text);\n  const allowedChars = toString(regex);\n  const replacementValue = toString(replacement);\n\n  // 2. Constrói a expressão regular que corresponde a qualquer caractere NÃO presente no conjunto.\n  // A string `allowedChars` é inserida diretamente para permitir intervalos como 'A-Z'.\n  const filterRegex = new RegExp(`[^${allowedChars}]`, \"g\");\n\n  // 3. Realiza a substituição uma única vez para evitar duplicação de código.\n  let result = stringValue.replace(filterRegex, replacementValue);\n\n  // 4. Aplica o trim opcionalmente ao resultado.\n  if (trim) {\n    result = result.trim();\n  }\n\n  return result;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default regexReplaceTrim;","import toString from \"./toString.js\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário para extrair apenas letras de um valor.\n */\n\n/**\n * @summary Extrai apenas caracteres alfabéticos (letras) de uma string ou de outro valor.\n *\n * @description\n * Esta função recebe um valor de qualquer tipo, o converte para uma string e remove\n * todos os caracteres que não são letras, como números, símbolos, espaços e\n * pontuação. Ela preserva tanto letras do alfabeto padrão (a-z, A-Z) quanto\n * a maioria das letras acentuadas comuns (à, ç, õ, etc.).\n *\n * @param {*} [text=\"\"] - O valor do qual as letras serão extraídas.\n *\n * @returns {string} Uma string contendo apenas as letras do valor de entrada.\n *\n * @example\n * const fullName = 'José \"Zé\" da Silva - 1985';\n * const letters = regexLettersOnly(fullName);\n * console.log(letters); // \"JoséZédaSilva\"\n *\n * const product = 'Camiseta (Polo) - Azul';\n * const productName = regexLettersOnly(product);\n * console.log(productName); // \"CamisetaPoloAzul\"\n */\nfunction regexLettersOnly(text = \"\") {\n  // 1. Converte a entrada para uma string de forma segura.\n  const stringValue = toString(text);\n\n  // 2. Remove todos os caracteres que não são letras.\n  // A regex `/[^A-Za-zÀ-ú]/g` encontra qualquer caractere que não esteja nos\n  // intervalos de 'A' a 'Z', 'a' a 'z', ou no intervalo de caracteres acentuados comuns.\n  return stringValue.replace(/[^A-Za-zÀ-ú]/g, \"\");\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default regexLettersOnly;","import toString from \"./toString.js\";\nimport isObject from \"../helpers/isObject\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário para remover substrings duplicadas de uma string.\n */\n\n/**\n * @summary Remove substrings duplicadas de um texto, com opção de ignorar maiúsculas/minúsculas.\n *\n * @description\n * Esta função divide uma string em um array de substrings, remove as duplicatas\n * e une as substrings de volta em uma única string.\n *\n * **Comportamento Importante:**\n * - No modo padrão (sensível a maiúsculas/minúsculas), a **primeira** ocorrência de uma substring é mantida.\n * - No modo insensível a maiúsculas/minúsculas, a **última** ocorrência de uma substring é mantida, preservando sua capitalização original.\n *\n * @param {*} text - O valor a ser processado, que será convertido para string.\n * @param {string} [splitString=\" \"] - O caractere ou string usado para dividir o texto.\n * @param {boolean} [caseInsensitive=false] - Se `true`, a comparação de duplicatas\n * ignorará a diferença entre maiúsculas e minúsculas.\n *\n * @returns {string} Uma nova string com as substrings duplicadas removidas. Retorna uma\n * string vazia se a entrada for um objeto.\n *\n * @example\n * const phrase = 'apple Orange apple ORANGE';\n *\n * // Sensível a maiúsculas/minúsculas (mantém a primeira ocorrência)\n * removeDuplicatedStrings(phrase); // \"apple Orange ORANGE\"\n *\n * // Insensível a maiúsculas/minúsculas (mantém a última ocorrência)\n * removeDuplicatedStrings(phrase, ' ', true); // \"apple ORANGE\"\n */\nfunction removeDuplicatedStrings(\n  text,\n  splitString = \" \",\n  caseInsensitive = false\n) {\n  // 1. Validação da entrada.\n  if (isObject(text)) {\n    return \"\";\n  }\n\n  // 2. Prepara o array de substrings.\n  const separator = toString(splitString);\n  const array = toString(text)\n    .trim()\n    .split(separator)\n    .filter(v => v);\n\n  // 3. Lógica para remover duplicatas.\n  if (!caseInsensitive) {\n    // Mantém a PRIMEIRA ocorrência de cada item.\n    return [...new Set(array)].join(separator);\n  } else {\n    // Lógica para manter a ÚLTIMA ocorrência, de forma performática.\n    const seenIndexes = {};\n    // 1. Mapeia a versão minúscula de cada item para o seu último índice no array.\n    array.forEach((item, index) => {\n      seenIndexes[item.toLowerCase()] = index;\n    });\n\n    // 2. Extrai apenas os índices que devem ser mantidos (os das últimas ocorrências).\n    const indexesToKeep = new Set(Object.values(seenIndexes));\n\n    // 3. Filtra o array original, mantendo apenas os itens nos índices desejados.\n    // Isso preserva a ordem e a capitalização corretas.\n    return array\n      .filter((_item, index) => indexesToKeep.has(index))\n      .join(separator);\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default removeDuplicatedStrings;","/**\n * @file Utilitário para criar um atraso (delay) programático.\n */\n\n/**\n * @summary Cria um atraso (delay) programático usando uma Promise.\n *\n * @description\n * Esta função é uma versão de `setTimeout` que pode ser usada com `async/await` para pausar\n * a execução de uma função assíncrona. Ela retorna uma Promise que será resolvida\n * ou rejeitada após o número de milissegundos especificado.\n *\n * @param {number} milliseconds - O número de milissegundos para esperar. Deve ser um número não negativo.\n * @param {*} [returnValue=true] - O valor com o qual a Promise será resolvida ou rejeitada.\n * @param {boolean} [throwError=false] - Se `true`, a Promise será rejeitada. Se `false` (padrão),\n * a Promise será resolvida.\n *\n * @returns {Promise<*>} Uma Promise que resolve ou rejeita após o atraso.\n *\n * @example\n * async function runProcess() {\n * console.log('Iniciando processo...'); // Ex: 17:18:43\n *\n * // Espera por 2 segundos e continua\n * await sleep(2000);\n * console.log('Processo continuado após 2 segundos.'); // Ex: 17:18:45\n *\n * try {\n * // Espera por 1 segundo e então rejeita a promise\n * await sleep(1000, 'Erro controlado', true);\n * } catch (error) {\n * console.error('Erro capturado:', error); // Erro capturado: Erro controlado\n * }\n * }\n *\n * runProcess();\n */\nfunction sleep(milliseconds, returnValue = true, throwError = false) {\n  // 1. Validação da entrada. Retorna uma promise já rejeitada para entradas inválidas.\n  if (typeof milliseconds !== 'number' || milliseconds < 0) {\n    const error = new TypeError('O tempo de espera (milliseconds) deve ser um número não negativo.');\n    return Promise.reject(error);\n  }\n\n  // A função retorna uma nova Promise, que é o padrão para operações assíncronas.\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      // 2. Decide se a promise deve ser resolvida ou rejeitada com base no parâmetro.\n      if (throwError) {\n        // Comportamento especial do código original: se o valor for o padrão `true`,\n        // rejeita com um erro genérico para maior clareza.\n        if (returnValue === true) {\n          return reject(new Error(\"Sleep Error\"));\n        }\n        // Caso contrário, rejeita com o valor personalizado fornecido.\n        return reject(returnValue);\n      }\n\n      // 3. Resolve a promise com o valor fornecido.\n      return resolve(returnValue);\n    }, milliseconds);\n  });\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default sleep;","/**\n * @file Utilitário seguro para dividir (split) strings.\n */\n\n/**\n * @summary Divide uma string em um array de substrings com base em um separador.\n *\n * @description\n * Esta função é um wrapper seguro para o método nativo `String.prototype.split()`.\n * Ela lida com entradas que não são strings (como `null` ou `undefined`) de forma\n * graciosa, retornando um array vazio em vez de lançar um erro, o que a torna\n * mais segura para usar em pipelines de dados.\n *\n * @param {string} text - A string a ser dividida.\n * @param {string | RegExp} [char=\" \"] - O separador. Pode ser uma string ou uma Expressão Regular.\n *\n * @returns {string[]} Um array de substrings. Retorna um array vazio se a entrada\n * não for uma string válida ou for uma string vazia.\n *\n * @example\n * const fruits = 'maçã,banana,laranja';\n * const fruitArray = split(fruits, ',');\n * console.log(fruitArray); // ['maçã', 'banana', 'laranja']\n *\n * const empty = split(null);\n * console.log(empty); // []\n *\n * const sentence = \"O rato roeu a roupa\";\n * const words = split(sentence); // Usa o separador padrão \" \"\n * console.log(words); // [\"O\", \"rato\", \"roeu\", \"a\", \"roupa\"]\n */\nfunction split(text, char = \" \") {\n  // 1. Validação: Garante que a entrada é uma string válida e não vazia.\n  // Se não for, retorna um array vazio para evitar erros em tempo de execução.\n  if (!text || typeof text !== \"string\") {\n    return [];\n  }\n\n  // 2. Delega a operação para o método nativo e eficiente `split`.\n  return text.split(char);\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default split;","import { compressSync, strToU8 } from \"fflate\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário cross-platform e performático para compressão de strings.\n */\n\n/**\n * @typedef {object} CompressionOptions - Opções para a função de compressão.\n * @property {'base64' | 'buffer'} [outputType='base64'] - O formato da saída. 'base64' para uma string ou 'buffer' para um Uint8Array.\n * @property {number} [level=6] - O nível de compressão (0-9). Níveis mais altos são mais lentos mas podem gerar saídas menores.\n * @property {number} [mem=8] - O nível de uso de memória (1-12). Níveis mais altos são mais rápidos e podem comprimir melhor, mas usam mais memória.\n */\n\n/**\n * @summary Comprime uma string usando o algoritmo DEFLATE, retornando Base64 ou um buffer.\n *\n * @description\n * Esta função síncrona recebe uma string, a converte para bytes em UTF-8 e a comprime\n * de forma eficiente usando a biblioteca `fflate`. O resultado é retornado no formato\n * especificado pelo `outputType`: uma string Base64 (ideal para transmissão em texto)\n * ou um `Uint8Array` (para manipulação binária).\n *\n * @param {string} text - A string a ser comprimida.\n * @param {CompressionOptions} [options={}] - Opções para customizar a compressão e o formato de saída.\n *\n * @returns {string | Uint8Array} A string comprimida em Base64 ou o `Uint8Array` dos dados comprimidos.\n * Retorna um valor vazio apropriado (string ou Uint8Array) para entradas inválidas.\n *\n * @example\n * const textoOriginal = 'Um texto longo para ser comprimido. Repetir, repetir, repetir.';\n *\n * // Comprimir para Base64 (padrão)\n * const comprimidoB64 = stringCompress(textoOriginal);\n *\n * // Comprimir para um buffer binário com nível de compressão máximo\n * const comprimidoBuffer = stringCompress(textoOriginal, { outputType: 'buffer', level: 9 });\n */\nfunction stringCompress(text, options = {}) {\n  // 1. Define as opções padrão e as mescla com as fornecidas pelo usuário\n  // para garantir um comportamento robusto e previsível.\n  const finalOptions = {\n    outputType: 'base64',\n    level: 6,\n    mem: 8,\n    ...options\n  };\n\n  // 2. Valida a entrada.\n  if (typeof text !== 'string' || text.length === 0) {\n    // Retorna um valor vazio do tipo de saída esperado para manter a consistência.\n    return finalOptions.outputType === 'buffer' ? new Uint8Array() : \"\";\n  }\n\n  // 3. Converte a string de entrada para um buffer de bytes UTF-8.\n  // `strToU8` é um helper otimizado da biblioteca `fflate`.\n  const inputBuffer = strToU8(text);\n\n  // 4. Comprime o buffer usando as opções especificadas.\n  const compressedBuffer = compressSync(inputBuffer, {\n    level: finalOptions.level,\n    mem: finalOptions.mem,\n  });\n\n  // 5. Retorna o resultado no formato solicitado.\n  if (finalOptions.outputType === 'buffer') {\n    return compressedBuffer;\n  }\n\n  // Por padrão, retorna em Base64. A conversão de binário para Base64\n  // é feita de forma diferente e otimizada para cada ambiente.\n  if (typeof Buffer !== 'undefined' && typeof Buffer.from === 'function') {\n    // **Ambiente Node.js:**\n    // Converte o Uint8Array para um Buffer e então para Base64. É o método mais rápido.\n    return Buffer.from(compressedBuffer).toString('base64');\n  } else {\n    // **Ambiente do Navegador:**\n    // Converte o Uint8Array para uma \"binary string\" e usa a função nativa `btoa`.\n    let binary = '';\n    const len = compressedBuffer.byteLength;\n    for (let i = 0; i < len; i++) {\n      binary += String.fromCharCode(compressedBuffer[i]);\n    }\n    return btoa(binary);\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default stringCompress;","import { decompressSync, strFromU8 } from \"fflate\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário cross-platform e performático para descompressão de strings.\n */\n\n/**\n * @typedef {object} DecompressionOptions - Opções para a função de descompressão.\n * @property {'base64' | 'buffer'} [inputType='base64'] - O formato da entrada de dados comprimidos.\n */\n\n/**\n * @summary Descomprime dados (Base64 ou buffer) de volta para a string original.\n *\n * @description\n * Esta função síncrona é a contraparte da `stringCompress`. Ela recebe dados comprimidos,\n * seja como uma string Base64 ou um `Uint8Array`, e os descomprime para a string de\n * texto original em formato UTF-8, utilizando a biblioteca `fflate`.\n *\n * @param {string | Uint8Array} compressedData - Os dados comprimidos a serem descomprimidos.\n * @param {DecompressionOptions} [options={}] - Opções para customizar o tipo de entrada.\n *\n * @returns {string} A string original descomprimida. Retorna uma string vazia se a\n * entrada for inválida ou se a descompressão falhar (ex: dados corrompidos).\n *\n * @example\n * const textoOriginal = 'O texto original que será comprimido e depois descomprimido.';\n *\n * // 1. Comprime para Base64\n * const comprimidoB64 = stringCompress(textoOriginal);\n *\n * // 2. Descomprime de volta para o original\n * const descomprimido = stringDecompress(comprimidoB64);\n *\n * console.log(descomprimido === textoOriginal); // true\n */\nfunction stringDecompress(compressedData, options = {}) {\n  // 1. Define as opções padrão e as mescla com as fornecidas pelo usuário.\n  const finalOptions = {\n    inputType: 'base64',\n    ...options\n  };\n\n  // 2. Valida a entrada principal.\n  if (!compressedData) {\n    return \"\";\n  }\n\n  try {\n    let inputBuffer;\n\n    // 3. Normaliza a entrada para um formato de buffer binário (`Uint8Array`).\n    if (finalOptions.inputType === 'base64') {\n      // Garante que a entrada é uma string antes de tentar decodificar.\n      if (typeof compressedData !== 'string') {\n        return \"\";\n      }\n      \n      // A decodificação de Base64 para binário é feita de forma otimizada para cada ambiente.\n      if (typeof Buffer !== 'undefined' && typeof Buffer.from === 'function') {\n        // **Ambiente Node.js:**\n        // `Buffer.from` lida com Base64 nativamente e é muito rápido.\n        inputBuffer = Buffer.from(compressedData, 'base64');\n      } else {\n        // **Ambiente do Navegador:**\n        // Usa `atob` para decodificar para uma \"binary string\" e então converte para Uint8Array.\n        const binaryString = atob(compressedData);\n        const len = binaryString.length;\n        const bytes = new Uint8Array(len);\n        for (let i = 0; i < len; i++) {\n          bytes[i] = binaryString.charCodeAt(i);\n        }\n        inputBuffer = bytes;\n      }\n    } else {\n      // Se o tipo for 'buffer', assume que a entrada já está em um formato binário compatível.\n      inputBuffer = compressedData;\n    }\n\n    // Valida se a conversão ou a entrada resultou em um buffer com conteúdo.\n    if (!inputBuffer || inputBuffer.byteLength === 0) {\n      return \"\";\n    }\n\n    // 4. Descomprime o buffer. Esta operação pode falhar se os dados estiverem corrompidos.\n    const decompressedBuffer = decompressSync(inputBuffer);\n\n    // 5. Converte o buffer descomprimido de volta para uma string UTF-8.\n    return strFromU8(decompressedBuffer);\n  } catch (error) {\n    // Retorna uma string vazia se a descompressão falhar (ex: dados corrompidos ou Base64 inválido).\n    return \"\";\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default stringDecompress;","import { DATE_ISO_FORMAT } from \"../constants.js\";\nimport { parse } from \"date-fns/parse\";\nimport isInstanceOf from \"../helpers/isInstanceOf\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @summary Converte uma string para um objeto Date, com base em um padrão de formato.\n *\n * @description\n * Esta função utiliza a biblioteca `date-fns` para analisar uma string de data com um\n * formato específico e retornar um objeto `Date`.\n *\n * Um passo importante desta função é que ela trata os valores da string como se\n * estivessem em UTC. Por exemplo, a string \"2025-08-21 10:30:00\" (sem fuso) será convertida para\n * um objeto `Date` que, em UTC, representa `2025-08-21T10:30:00.000Z`.\n *\n * @param {string} stringDate - A string da data a ser analisada.\n * @param {string} [stringFormat=DATE_ISO_FORMAT] - O padrão de formatação da `stringDate`,\n * compatível com `date-fns`.\n * @param {Date} [defaultDate=new Date()] - O valor a ser retornado se a análise falhar.\n * Se `defaultDate` for `null` ou `undefined`, a função retorna `false`.\n *\n * @returns {Date | false} O objeto `Date` resultante, o `defaultDate` em caso de falha,\n * ou `false` se a análise falhar e não houver `defaultDate`.\n */\nfunction stringToDate(\n  stringDate,\n  stringFormat = DATE_ISO_FORMAT,\n  defaultDate = new Date()\n) {\n  let dateToProcess;\n\n  // 1. Tenta analisar a string ou define o fallback inicial.\n  if (typeof stringDate === 'string') {\n    const parsedDate = parse(stringDate, stringFormat, new Date());\n\n    // Verifica se a análise foi bem-sucedida.\n    if (isInstanceOf(parsedDate, Date) && !isNaN(parsedDate.getTime())) {\n      dateToProcess = parsedDate;\n    } else {\n      // Se a análise falhar, usa a data padrão como fallback.\n      dateToProcess = defaultDate;\n    }\n  } else {\n    // Se a entrada não for uma string, usa a data padrão.\n    dateToProcess = defaultDate;\n  }\n\n  // 2. Valida a data a ser processada (seja ela a analisada ou a padrão).\n  if (dateToProcess == null) {\n    // Se a data padrão era nula/indefinida, retorna `false`.\n    return false;\n  }\n  \n  if (!isInstanceOf(dateToProcess, Date) || isNaN(dateToProcess.getTime())) {\n      // Se a data padrão fornecida for inválida, retorna `false`.\n      return false;\n  }\n\n  // 3. Aplica o ajuste de fuso horário a QUALQUER data válida que saia da função.\n  // Isso garante um comportamento consistente tanto para datas analisadas quanto para as padrão.\n  const timezoneOffsetMillis = dateToProcess.getTimezoneOffset() * 60 * 1000;\n  return new Date(dateToProcess.getTime() - timezoneOffsetMillis);\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default stringToDate;","import { DATE_ISO_FORMAT, DATE_BR_HOUR_FORMAT_D } from \"../constants.js\";\nimport stringToDate from \"./stringToDate.js\";\nimport dateToFormat from \"./dateToFormat.js\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário para re-formatar strings de data.\n */\n\n/**\n * @summary Re-formata uma string de data de um formato de entrada para um de saída.\n *\n * @description\n * Esta função é um utilitário de conveniência que combina a análise e a formatação\n * de datas em uma única etapa. Ela usa `stringToDate` para converter a string de entrada em um\n * objeto `Date` e, em seguida, usa `dateToFormat` para converter esse objeto de volta\n * para uma string no formato de saída desejado.\n *\n * @param {string} stringDate - A string da data a ser re-formatada.\n * @param {string} [fromFormat=DATE_ISO_FORMAT] - O padrão de formatação da string de entrada.\n * @param {string} [toFormat=DATE_BR_HOUR_FORMAT_D] - O padrão de formatação desejado para a saída.\n *\n * @returns {string | false} A nova string de data formatada, ou `false` se a\n * análise da data de entrada falhar.\n */\nfunction stringToDateToFormat(\n  stringDate,\n  fromFormat = DATE_ISO_FORMAT,\n  toFormat = DATE_BR_HOUR_FORMAT_D\n) {\n  try {\n    // 1. Converte a string de entrada para um objeto Date.\n    // `stringToDate` retorna um Date cujo tempo UTC corresponde aos números da string.\n    const dateObject = stringToDate(stringDate, fromFormat, false);\n\n    if (dateObject) {\n      // 2. Reverte o ajuste de fuso horário antes de formatar.\n      // `stringToDate` removeu o offset local para tratar a hora como UTC.\n      // Para que `dateToFormat` (que formata em hora local) exiba os números corretos,\n      // é necessário adicionar o offset de volta, criando uma nova data ajustada.\n      const timezoneOffsetMillis = dateObject.getTimezoneOffset() * 60 * 1000;\n      const localDate = new Date(dateObject.getTime() + timezoneOffsetMillis);\n\n      // 3. Formata o objeto Date (agora ajustado para a hora local correta) para a string de saída.\n      return dateToFormat(localDate, toFormat);\n    }\n  } catch (_) {}\n  // 4. Se a conversão inicial falhou, retorna `false`.\n  return false;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default stringToDateToFormat;\n","import toString from \"./toString.js\";\nimport regexDigitsOnly from \"./regexDigitsOnly\";\nimport { STRING_FORMAT_CNPJ } from \"../constants.js\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário para aplicar máscaras de formatação a strings.\n */\n\n/**\n * @summary Aplica uma máscara de formatação a uma string ou valor.\n *\n * @description\n * Esta função formata uma string de entrada de acordo com um padrão (máscara).\n * Os caracteres `#` no padrão são substituídos sequencialmente pelos caracteres\n * da string de entrada. A função pode opcionalmente limpar a entrada para conter\n * apenas dígitos, e também lida com o preenchimento e truncamento da entrada\n * para que ela se ajuste perfeitamente à máscara.\n *\n * @param {*} [text] - O valor a ser formatado. Será convertido para string.\n * @param {string} [pattern=STRING_FORMAT_CNPJ] - A máscara de formatação, onde `#` é um placeholder.\n * @param {object} [options={}] - Opções para customizar o comportamento.\n * @param {boolean} [options.digitsOnly=false] - Se `true`, a string de entrada será primeiro limpa para conter apenas dígitos.\n * @param {string} [options.paddingChar='0'] - O caractere a ser usado para preencher a entrada à esquerda se ela for menor que o necessário.\n *\n * @returns {string} A string formatada com a máscara.\n *\n * @example\n * // Formatar um CNPJ (com limpeza de dígitos)\n * const cnpj = '12.345.678/0001-90';\n * stringToFormat(cnpj, '##.###.###/####-##', { digitsOnly: true });\n * // Retorna: \"12.345.678/0001-90\"\n *\n * // Formatar um valor com preenchimento à esquerda\n * stringToFormat('123', 'ID-######', { paddingChar: '0' });\n * // Retorna: \"ID-000123\"\n */\nfunction stringToFormat(\n  text,\n  pattern = STRING_FORMAT_CNPJ,\n  options = {}\n) {\n  // 1. Define e mescla as opções para um manuseio robusto de parâmetros.\n  const finalOptions = {\n    digitsOnly: false,\n    paddingChar: \"0\",\n    ...options\n  };\n\n  let processedText = toString(text);\n\n  // 2. Aplica a limpeza de dígitos opcionalmente.\n  if (finalOptions.digitsOnly) {\n    processedText = regexDigitsOnly(processedText);\n  }\n\n  // 3. Calcula o tamanho necessário com base nos placeholders '#' no padrão.\n  const requiredSize = (pattern.match(/#/g) || []).length;\n  if (requiredSize === 0) {\n      return pattern; // Se não houver placeholders, retorna o padrão literal.\n  }\n\n  // 4. Garante que o texto tenha o tamanho exato: trunca se for longo, preenche se for curto.\n  processedText = processedText.slice(0, requiredSize).padStart(requiredSize, finalOptions.paddingChar);\n\n  // 5. Aplica a máscara de forma funcional.\n  // A cada ocorrência de '#', a função de callback fornece o próximo\n  // caractere do texto processado para a substituição.\n  let charIndex = 0;\n  return pattern.replace(/#/g, () => processedText[charIndex++]);\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default stringToFormat;","import { zlibSync, strToU8 } from \"fflate\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário cross-platform para compressão de strings com Zlib.\n */\n\n/**\n * @typedef {object} ZlibOptions - Opções para a função de compressão Zlib.\n * @property {'base64' | 'buffer'} [outputType='base64'] - O formato da saída. 'base64' para uma string ou 'buffer' para um Uint8Array.\n * @property {number} [level=6] - O nível de compressão (0-9). Níveis mais altos são mais lentos mas podem gerar saídas menores.\n * @property {number} [mem=8] - O nível de uso de memória (1-12). Níveis mais altos são mais rápidos e podem comprimir melhor, mas usam mais memória.\n */\n\n/**\n * @summary Comprime uma string usando o algoritmo Zlib.\n *\n * @description\n * Esta função síncrona recebe uma string, a converte para bytes em UTF-8 e a comprime\n * de forma eficiente usando o formato Zlib da biblioteca `fflate`. O resultado é retornado no formato\n * especificado pelo `outputType`: uma string Base64 ou um `Uint8Array`.\n *\n * @param {string} text - A string a ser comprimida.\n * @param {ZlibOptions} [options={}] - Opções para customizar a compressão e o formato de saída.\n *\n * @returns {string | Uint8Array} A string comprimida em Base64 ou o `Uint8Array` dos dados comprimidos.\n * Retorna um valor vazio apropriado (string ou Uint8Array) para entradas inválidas.\n *\n * @example\n * const textoOriginal = 'Este texto será comprimido com o algoritmo Zlib.';\n *\n * // Comprimir para Base64 (padrão)\n * const comprimidoB64 = stringZLibCompress(textoOriginal);\n *\n * // Comprimir para um buffer binário com nível de compressão máximo\n * const comprimidoBuffer = stringZLibCompress(textoOriginal, { outputType: 'buffer', level: 9 });\n */\nfunction stringZLibCompress(text, options = {}) {\n  // 1. Define as opções padrão e as mescla com as fornecidas pelo usuário.\n  const finalOptions = {\n    outputType: 'base64',\n    level: 6,\n    mem: 8,\n    ...options\n  };\n\n  // 2. Valida a entrada.\n  if (typeof text !== 'string' || text.length === 0) {\n    // Retorna um valor vazio do tipo de saída esperado para manter a consistência.\n    return finalOptions.outputType === 'buffer' ? new Uint8Array() : \"\";\n  }\n\n  // 3. Converte a string de entrada para um buffer de bytes UTF-8.\n  const inputBuffer = strToU8(text);\n\n  // 4. Comprime o buffer usando as opções especificadas.\n  const compressedBuffer = zlibSync(inputBuffer, {\n    level: finalOptions.level,\n    mem: finalOptions.mem,\n  });\n\n  // 5. Retorna o resultado no formato solicitado.\n  if (finalOptions.outputType === 'buffer') {\n    return compressedBuffer;\n  }\n\n  // Por padrão, retorna em Base64, com a conversão otimizada para cada ambiente.\n  if (typeof Buffer !== 'undefined' && typeof Buffer.from === 'function') {\n    // **Ambiente Node.js:**\n    // Converte o Uint8Array para um Buffer e então para Base64. É o método mais rápido.\n    return Buffer.from(compressedBuffer).toString('base64');\n  } else {\n    // **Ambiente do Navegador:**\n    // Converte o Uint8Array para uma \"binary string\" e usa a função nativa `btoa`.\n    let binary = '';\n    const len = compressedBuffer.byteLength;\n    for (let i = 0; i < len; i++) {\n      binary += String.fromCharCode(compressedBuffer[i]);\n    }\n    return btoa(binary);\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default stringZLibCompress;","import { unzlibSync, strFromU8 } from \"fflate\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário cross-platform para descompressão de strings com Zlib.\n */\n\n/**\n * @typedef {object} ZlibDecompressionOptions - Opções para a função de descompressão Zlib.\n * @property {'base64' | 'buffer'} [inputType='base64'] - O formato da entrada de dados comprimidos.\n */\n\n/**\n * @summary Descomprime dados (Base64 ou buffer) usando Zlib de volta para a string original.\n *\n * @description\n * Esta função síncrona é a contraparte da `stringZLibCompress`. Ela recebe dados comprimidos\n * no formato Zlib, seja como uma string Base64 ou um `Uint8Array`, e os descomprime\n * para a string de texto original em formato UTF-8.\n *\n * @param {string | Uint8Array} compressedData - Os dados comprimidos a serem descomprimidos.\n * @param {ZlibDecompressionOptions} [options={}] - Opções para customizar o tipo de entrada.\n *\n * @returns {string} A string original descomprimida. Retorna uma string vazia se a\n * entrada for inválida ou se a descompressão falhar (ex: dados corrompidos).\n *\n * @example\n * const textoOriginal = 'Este texto será comprimido e depois descomprimido com Zlib.';\n *\n * // 1. Comprime para Base64\n * const comprimidoB64 = stringZLibCompress(textoOriginal);\n *\n * // 2. Descomprime de volta para o original\n * const descomprimido = stringZLibDecompress(comprimidoB64);\n *\n * console.log(descomprimido === textoOriginal); // true\n */\nfunction stringZLibDecompress(compressedData, options = {}) {\n  // 1. Define as opções padrão e as mescla com as fornecidas pelo usuário.\n  const finalOptions = {\n    inputType: 'base64',\n    ...options\n  };\n\n  // 2. Valida a entrada principal.\n  if (!compressedData) {\n    return \"\";\n  }\n\n  try {\n    let inputBuffer;\n\n    // 3. Normaliza a entrada para um formato de buffer binário (`Uint8Array`).\n    if (finalOptions.inputType === 'base64') {\n      if (typeof compressedData !== 'string') {\n        return \"\";\n      }\n      \n      // A decodificação de Base64 para binário é otimizada para cada ambiente.\n      if (typeof Buffer !== 'undefined' && typeof Buffer.from === 'function') {\n        // **Ambiente Node.js:**\n        inputBuffer = Buffer.from(compressedData, 'base64');\n      } else {\n        // **Ambiente do Navegador:**\n        const binaryString = atob(compressedData);\n        const len = binaryString.length;\n        const bytes = new Uint8Array(len);\n        for (let i = 0; i < len; i++) {\n          bytes[i] = binaryString.charCodeAt(i);\n        }\n        inputBuffer = bytes;\n      }\n    } else {\n      // Se o tipo for 'buffer', assume que a entrada já está em um formato binário.\n      inputBuffer = compressedData;\n    }\n\n    if (!inputBuffer || inputBuffer.byteLength === 0) {\n      return \"\";\n    }\n\n    // 4. Descomprime o buffer. Pode falhar se os dados estiverem corrompidos.\n    const decompressedBuffer = unzlibSync(inputBuffer);\n\n    // 5. Converte o buffer descomprimido de volta para uma string UTF-8.\n    return strFromU8(decompressedBuffer);\n  } catch (error) {\n    // Retorna uma string vazia se a descompressão falhar.\n    return \"\";\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default stringZLibDecompress;","/**\n * @file Utilitário para criar uma função \"throttled\" (limitada por frequência).\n */\n\n/**\n * @summary Cria uma versão \"throttled\" de uma função, que limita sua frequência de execução.\n *\n * @description\n * Throttle é uma técnica que garante que uma função seja executada no máximo uma vez\n * a cada `wait` milissegundos. Ao contrário do `debounce` que espera um período de inatividade,\n * o `throttle` permite execuções contínuas, mas espaçadas no tempo.\n *\n * É ideal para controlar eventos que disparam com muita frequência e onde uma resposta periódica\n * é desejada, como em eventos de scroll, redimensionamento de janela ou movimento do mouse.\n * Esta implementação executa a função na primeira chamada (\"leading edge\") e ignora as\n * chamadas subsequentes durante o período de espera (cooldown).\n *\n * @param {Function} callback - A função que terá sua execução limitada.\n * @param {number} wait - O intervalo mínimo em milissegundos entre as execuções.\n *\n * @returns {(...args: any[]) => void} Uma nova função \"throttled\" que pode ser chamada no lugar da original.\n *\n * @throws {TypeError} Lança um erro se o `callback` não for uma função ou se `wait` não for um número.\n *\n * @example\n * // Exemplo: um evento de scroll que atualiza a UI, mas no máximo a cada 250ms.\n * let scrollCount = 0;\n * const onScroll = () => {\n * scrollCount++;\n * console.log(`Atualizando UI... Chamada nº ${scrollCount}`);\n * };\n *\n * const throttledScroll = throttle(onScroll, 250);\n *\n * // No navegador, você adicionaria o listener:\n * // window.addEventListener('scroll', throttledScroll);\n *\n * // Simulando chamadas rápidas:\n * throttledScroll(); // Executa: \"Atualizando UI... Chamada nº 1\"\n * throttledScroll(); // Ignorada (dentro do cooldown)\n * throttledScroll(); // Ignorada (dentro do cooldown)\n *\n * setTimeout(() => {\n * throttledScroll(); // Executa: \"Atualizando UI... Chamada nº 2\"\n * }, 300); // 300ms > 250ms, então o cooldown já acabou.\n */\nfunction throttle(callback, wait) {\n  // 1. Validação dos parâmetros na criação da função.\n  if (typeof callback !== 'function') {\n    throw new TypeError('O callback fornecido para o throttle deve ser uma função.');\n  }\n  if (typeof wait !== 'number' || wait < 0) {\n    throw new TypeError('O tempo de espera (wait) do throttle deve ser um número não negativo.');\n  }\n\n  // 2. Closure para manter o estado de \"cooldown\" entre as chamadas.\n  let inCooldown = false;\n\n  // Usa uma função regular para preservar o contexto `this` de quem a chama.\n  return function(...args) {\n    // Se a função já foi chamada dentro do período de `wait`, ignora esta nova chamada.\n    if (inCooldown) {\n      return;\n    }\n\n    // 3. Executa o callback imediatamente na primeira chamada válida.\n    // O `this` e os `args` são da chamada atual que está sendo executada.\n    callback.apply(this, args);\n\n    // 4. Inicia o período de \"cooldown\".\n    inCooldown = true;\n\n    // 5. Define um temporizador para terminar o \"cooldown\" após o tempo de espera,\n    // permitindo que a função seja executada novamente.\n    setTimeout(() => {\n      inCooldown = false;\n    }, wait);\n  };\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default throttle","/**\n * @description Gera uma string de timestamp altamente customizável e formatada com base em um padrão fornecido.\n * A função é otimizada para calcular apenas os componentes de data/hora necessários para o formato solicitado.\n *\n * @param {string} [format='D-MT-Y_H:MN:S:MS'] A string de formato que define a estrutura da saída.\n * Os seguintes tokens serão substituídos pelos seus respectivos valores:\n * - `Y`: Ano com 4 dígitos (ex: 2025)\n * - `MT`: Mês com 2 dígitos (01-12)\n * - `D`: Dia com 2 dígitos (01-31)\n * - `H`: Hora com 2 dígitos, formato 24h (00-23)\n * - `MN`: Minuto com 2 dígitos (00-59)\n * - `S`: Segundo com 2 dígitos (00-59)\n * - `MS`: Milissegundo com 3 dígitos (000-999)\n *\n * Qualquer outro caractere na string de formato (ex: '-', ':', '_', '/') será mantido como um separador literal.\n *\n * @returns {string} Uma string representando o timestamp formatado de acordo com o padrão.\n *\n * @example\n * // Chamada sem parâmetros, usa o formato padrão.\n * // Retorna algo como: \"22-08-2025_19:37:33:456\"\n * getFormattedTimestamp();\n *\n * @example\n * // Formato de hora customizado com underscores, como solicitado.\n * // Retorna algo como: \"19_37_33_456\"\n * getFormattedTimestamp('H_MN_S_MS');\n *\n * @example\n * // Formato de hora simples, como solicitado.\n * // Retorna algo como: \"19:37:33\"\n * getFormattedTimestamp('H:MN:S');\n *\n * @example\n * // Formato de data para logs (padrão ISO 8601).\n * // Retorna algo como: \"2025-08-22\"\n * getFormattedTimestamp('Y-MT-D');\n */\nfunction timestamp(format = 'D-MT-Y_H:MN:S:MS') {\n  const now = new Date();\n\n  // Mapeamento dos tokens para suas funções de obtenção e formatação.\n  // A avaliação é \"lazy\" (preguiçosa): a função só é executada quando o token correspondente\n  // é encontrado na string de formato, melhorando a performance.\n  const tokens = {\n    // Ano com 4 dígitos\n    Y: () => now.getFullYear(),\n    // Mês com 2 dígitos (getMonth() é 0-indexado)\n    MT: () => String(now.getMonth() + 1).padStart(2, '0'),\n    // Dia com 2 dígitos\n    D: () => String(now.getDate()).padStart(2, '0'),\n    // Hora com 2 dígitos (formato 24h)\n    H: () => String(now.getHours()).padStart(2, '0'),\n    // Minuto com 2 dígitos\n    MN: () => String(now.getMinutes()).padStart(2, '0'),\n    // Segundo com 2 dígitos\n    S: () => String(now.getSeconds()).padStart(2, '0'),\n    // Milissegundo com 3 dígitos\n    MS: () => String(now.getMilliseconds()).padStart(3, '0'),\n  };\n\n  // Usa uma expressão regular para encontrar e substituir todos os tokens de uma só vez.\n  // A flag 'g' (global) garante que todas as ocorrências de tokens sejam substituídas,\n  // não apenas a primeira.\n  // Para cada token encontrado, a função correspondente no objeto 'tokens' é chamada.\n  return format.replace(/Y|MT|D|H|MN|S|MS/g, (token) => tokens[token]());\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default timestamp;\n","/**\n * @file Utilitário cross-platform para converter strings UTF-8 para Uint8Array.\n */\n\n/**\n * @summary Converte uma string (UTF-8) para um `Uint8Array` ou uma string de bytes.\n *\n * @description\n * Esta função converte uma string para sua representação binária como um `Uint8Array` em\n * formato UTF-8. Opcionalmente, se um caractere de junção (`joinChar`) for fornecido,\n * a função retornará uma string com os valores dos bytes unidos por esse caractere.\n * A conversão para bytes é cross-platform e lida corretamente com caracteres multi-byte.\n *\n * @param {string} [text=\"\"] - A string a ser convertida.\n * @param {string} [joinChar] - Opcional. Se fornecido, a função retorna uma string dos valores\n * dos bytes em vez de um `Uint8Array`.\n *\n * @returns {Uint8Array | string} Um `Uint8Array` com os bytes da string, ou uma `string`\n * formatada se `joinChar` for especificado.\n *\n * @example\n * // Retornando um Uint8Array\n * const bytes = uint8ArrayFromString('Hi');\n * console.log(bytes); // Uint8Array(2) [ 72, 105 ]\n *\n * // Retornando uma string formatada\n * const byteString = uint8ArrayFromString('Hi', '-');\n * console.log(byteString); // \"72-105\"\n */\nfunction uint8ArrayFromString(text = \"\", joinChar) {\n  // 1. Validação de tipo.\n  if (typeof text !== 'string') {\n    // Retorna um tipo consistente com o caminho de sucesso (string vazia ou array vazio).\n    return joinChar !== undefined ? '' : new Uint8Array();\n  }\n\n  let uint8Array;\n\n  // **Ambiente Node.js:**\n  if (typeof window === 'undefined') {\n    // `Buffer.from` cria um Buffer (que é um Uint8Array) a partir da string UTF-8.\n    uint8Array = Buffer.from(text, 'utf-8');\n  } else {\n    // **Ambiente do Navegador:**\n    // `TextEncoder` é a API padrão para converter strings em bytes UTF-8.\n    uint8Array = new TextEncoder().encode(text);\n  }\n\n  // 3. Decide o formato de saída com base na presença de `joinChar`.\n  if (joinChar !== undefined) {\n    // `Uint8Array` não possui o método `.join`, então é necessário converter\n    // para um array padrão antes de fazer a junção.\n    return Array.from(uint8Array).join(joinChar);\n  }\n\n  // Retorna o Uint8Array se nenhum `joinChar` for especificado.\n  return uint8Array;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default uint8ArrayFromString;","/**\n * @file Utilitário para converter um buffer (ou sua representação em string) para uma string de texto.\n */\n\n/**\n * @summary Converte um `Uint8Array` ou uma string de bytes para uma string de texto (UTF-8).\n *\n * @description\n * Esta função tem um comportamento duplo:\n * 1. **Modo Padrão (sem `splitChar`):** Recebe um objeto buffer-like (`Uint8Array`, `Buffer`, `ArrayBuffer`)\n * e o decodifica para uma string UTF-8.\n * 2. **Modo de Análise (com `splitChar`):** Recebe uma **string** de números (representando bytes),\n * separados pelo `splitChar`. Ela irá analisar essa string, montar um `Uint8Array` e então decodificá-lo.\n *\n * @param {Uint8Array | ArrayBuffer | Buffer | string} uint8Array - O buffer a ser convertido,\n * ou a string de bytes a ser analisada.\n * @param {string} [splitChar] - Opcional. Ativa o modo de análise, usando este caractere como separador.\n *\n * @returns {string} A string decodificada.\n *\n * @example\n * // Modo Padrão (com um buffer real)\n * const bytes = new Uint8Array([72, 101, 108, 108, 111]); // Bytes para \"Hello\"\n * uint8ArrayToString(bytes); // Retorna \"Hello\"\n *\n * // Modo de Análise (com uma string de bytes)\n * const byteString = \"72,101,108,108,111\";\n * uint8ArrayToString(byteString, ','); // Retorna \"Hello\"\n */\nfunction uint8ArrayToString(uint8Array, splitChar) {\n  // 1. Validação de entrada básica.\n  if (uint8Array == null) {\n    return \"\";\n  }\n\n  let bufferSource = uint8Array;\n\n  // 2. Verifica se está no \"Modo de Análise\".\n  if (splitChar !== undefined && typeof uint8Array === 'string') {\n    // Converte a string de números (ex: \"72, 101, 108\") em um array de números.\n    const bytes = uint8Array.split(splitChar).map(s => parseInt(s.trim(), 10));\n    // Cria o buffer a partir dos números analisados.\n    bufferSource = new Uint8Array(bytes);\n  }\n\n  // 3. Decodifica o buffer para uma string UTF-8 (lógica cross-platform).\n  // `bufferSource` agora é garantidamente um objeto buffer-like.\n  try {\n    // Ambiente Node.js:\n    if (typeof window === 'undefined') {\n      const nodeBuffer = Buffer.isBuffer(bufferSource) ? bufferSource : Buffer.from(bufferSource);\n      return nodeBuffer.toString('utf-8');\n    }\n\n    // Ambiente do Navegador:\n    return new TextDecoder().decode(bufferSource);\n  } catch (error) {\n    // Retorna uma string vazia se o buffer de entrada for inválido para as APIs.\n    return \"\";\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default uint8ArrayToString;","import validateCADICMSPR from \"./validateCADICMSPR.js\";\nimport validateCEP from \"./validateCEP.js\";\nimport validateChavePix from \"./validateChavePix.js\";\nimport validateCNH from \"./validateCNH.js\";\nimport validateCNPJ from \"./validateCNPJ.js\";\nimport validateCPF from \"./validateCPF.js\";\nimport validateEmail from \"./validateEmail.js\";\nimport validatePISPASEPNIT from \"./validatePISPASEPNIT.js\";\nimport validateRenavam from \"./validateRenavam.js\";\nimport validateTituloEleitor from \"./validateTituloEleitor.js\";\nimport validateRG from \"./validateRG.js\";\n\n// Named exports para importação individual\nexport {\n  validateCADICMSPR,\n  validateCEP,\n  validateChavePix,\n  validateCNH,\n  validateCNPJ,\n  validateCPF,\n  validateEmail,\n  validatePISPASEPNIT,\n  validateRenavam,\n  validateTituloEleitor,\n  validateRG\n};\n\n// Default export para compatibilidade\nexport default {\n  validateCADICMSPR,\n  validateCEP,\n  validateChavePix,\n  validateCNH,\n  validateCNPJ,\n  validateCPF,\n  validateEmail,\n  validatePISPASEPNIT,\n  validateRenavam,\n  validateTituloEleitor,\n  validateRG,\n};","/**\n * @fileoverview Funções para validação de inscrição estadual (CAD/ICMS) do estado do Paraná (PR).\n * Código compatível com Node.js e navegadores.\n */\n\n/**\n * Calcula um dígito verificador com base em uma sequência de dígitos e um array de pesos.\n * Esta é uma função auxiliar interna para evitar a repetição da lógica de cálculo.\n *\n * @param {string} digits - A sequência de dígitos a ser usada no cálculo.\n * @param {number[]} weights - O array de pesos para multiplicar cada dígito.\n * @returns {number} O dígito verificador calculado.\n * @private\n */\nfunction _calculateVerifierDigit(digits, weights) {\n  // Multiplica cada dígito pelo seu peso correspondente e soma os resultados.\n  // O uso de 'reduce' é uma forma funcional e concisa de realizar a soma ponderada.\n  const sum = digits\n    .split('')\n    .reduce((acc, digit, index) => acc + (Number(digit) * weights[index]), 0);\n\n  const remainder = sum % 11;\n\n  // Conforme a regra de cálculo, se o resto for 0 ou 1, o dígito é 0.\n  // Caso contrário, é 11 menos o resto.\n  return (remainder <= 1) ? 0 : 11 - remainder;\n}\n\n/**\n * Valida uma inscrição estadual (CAD/ICMS) do estado do Paraná (PR).\n * A função lida com entradas formatadas (com pontos, traços) e não formatadas,\n * desde que contenham a quantidade correta de dígitos.\n *\n * @summary Valida o CAD/ICMS do estado do Paraná.\n * @param {string | number} cadicms O valor do CAD/ICMS a ser validado.\n * @returns {boolean} Retorna `true` se o CAD/ICMS for válido, e `false` caso contrário.\n * @example\n * // Exemplo com números e strings formatadas/não formatadas\n * validateCADICMSPR(\"90312851-11\"); // true\n * validateCADICMSPR(\"9031285111\");  // true\n * validateCADICMSPR(9031285111);   // true\n * validateCADICMSPR(\"1234567890\");  // false\n */\nfunction validateCADICMSPR(cadicms) {\n  // Garante que a entrada seja uma string e remove todos os caracteres não numéricos.\n  // O construtor String() lida de forma segura com null, undefined e outros tipos.\n  const digitsOnly = String(cadicms).replace(/[^\\d]/g, '');\n\n  // Define o tamanho esperado para a inscrição estadual.\n  const CADICMS_LENGTH = 10;\n\n  // A inscrição estadual deve ter no máximo 10 dígitos e não pode estar vazia.\n  // A validação original permite números menores que 10 e os preenche com zeros,\n  // essa lógica é mantida.\n  if (digitsOnly === '' || digitsOnly.length > CADICMS_LENGTH) {\n    return false;\n  }\n\n  // Se a string for menor que 10, preenche com zeros à esquerda até atingir o tamanho correto.\n  const paddedCadicms = digitsOnly.padStart(CADICMS_LENGTH, '0');\n\n  // --- Cálculo do Primeiro Dígito Verificador ---\n\n  // Pesos para o cálculo do primeiro dígito (baseado nos 8 primeiros dígitos da inscrição).\n  const WEIGHTS_DV1 = [3, 2, 7, 6, 5, 4, 3, 2];\n  const firstEightDigits = paddedCadicms.substring(0, 8);\n  const expectedFirstVerifier = _calculateVerifierDigit(firstEightDigits, WEIGHTS_DV1);\n\n  // Compara o dígito calculado com o nono dígito da inscrição.\n  // A conversão para Number() garante uma comparação estrita de tipos.\n  const firstVerifier = Number(paddedCadicms[8]);\n  if (expectedFirstVerifier !== firstVerifier) {\n    return false;\n  }\n\n  // --- Cálculo do Segundo Dígito Verificador ---\n\n  // Pesos para o cálculo do segundo dígito (baseado nos 9 primeiros dígitos da inscrição).\n  const WEIGHTS_DV2 = [4, 3, 2, 7, 6, 5, 4, 3, 2];\n  const firstNineDigits = paddedCadicms.substring(0, 9);\n  const expectedSecondVerifier = _calculateVerifierDigit(firstNineDigits, WEIGHTS_DV2);\n\n  // Compara o dígito calculado com o décimo (último) dígito da inscrição.\n  const secondVerifier = Number(paddedCadicms[9]);\n  \n  // O retorno final é o resultado da comparação do segundo dígito.\n  return expectedSecondVerifier === secondVerifier;\n}\n\n// ------------------------------------------------------------------------------------------------\n\n// Mantém a exportação no padrão CommonJS para compatibilidade com Node.js.\n// Em um ambiente de navegador, esta linha será ignorada.\nexport default validateCADICMSPR;\n\n// ------------------------------------------------------------------------------------------------","/**\n * @fileoverview Fornece uma função para validar CEP (Código de Endereçamento Postal).\n */\n\n/**\n * Valida um CEP (Código de Endereçamento Postal).\n *\n * @summary Valida um CEP.\n * @description A função verifica se a entrada consiste em exatamente 8 dígitos numéricos,\n * ignorando caracteres de máscara.\n *\n * @param {string | number} cep O CEP a ser validado.\n * @returns {boolean} Retorna `true` se o CEP for válido, e `false` caso contrário.\n * @example\n * validateCEP(\"80000-123\"); // true\n * validateCEP(\"1234567\");   // false\n */\nfunction validateCEP(cep = \"\") {\n  const digitsOnly = String(cep).replace(/[^\\d]/g, \"\");\n  return digitsOnly.length === 8;\n}\n\n// ------------------------------------------------------------------------------------------------\nexport default validateCEP;\n// ------------------------------------------------------------------------------------------------\n","/**\n * @fileoverview Fornece uma função para validar números de CNPJ (Cadastro Nacional da Pessoa Jurídica).\n * O código é compatível com ambientes Node.js e navegadores.\n */\n\n/**\n * Array de pesos utilizado no algoritmo de cálculo dos dígitos verificadores do CNPJ.\n * @private\n * @type {number[]}\n */\nconst DEFAULT_WEIGHTS = [6, 5, 4, 3, 2, 9, 8, 7, 6, 5, 4, 3, 2];\n\n/**\n * Calcula o valor numérico de um caractere para o algoritmo de soma ponderada.\n * A conversão é baseada no valor ASCII do caractere, o que resulta em um\n * mapeamento específico para letras (ex: 'A' => 17, 'B' => 18).\n *\n * @private\n * @param {string} char - O caractere a ser convertido.\n * @returns {number} O valor numérico correspondente para o cálculo.\n */\nfunction _getCharValue(char) {\n  // A subtração do charCode de '0' é o método que define a conversão.\n  return char.charCodeAt(0) - '0'.charCodeAt(0);\n}\n\n/**\n * Calcula os dois dígitos verificadores para uma base de 12 caracteres de um CNPJ.\n *\n * @private\n * @param {string} baseCnpj - Os 12 primeiros caracteres do CNPJ.\n * @param {number[]} weights - O array de pesos a ser usado no cálculo.\n * @returns {string} Uma string contendo os dois dígitos verificadores calculados.\n */\nfunction _calculateVerifierDigits(baseCnpj, weights) {\n  /**\n   * Calcula um único dígito verificador a partir do resultado de uma soma ponderada.\n   * @param {number} sum - A soma ponderada.\n   * @returns {number} O dígito verificador (0 a 9).\n   */\n  const getDigit = (sum) => {\n    const remainder = sum % 11;\n    return remainder < 2 ? 0 : 11 - remainder;\n  };\n\n  let sum1 = 0;\n  let sum2 = 0;\n\n  for (let i = 0; i < baseCnpj.length; i++) {\n    // Converte o caractere para seu valor numérico específico do algoritmo.\n    const value = _getCharValue(baseCnpj[i]);\n    sum1 += value * weights[i + 1];\n    sum2 += value * weights[i];\n  }\n\n  const dv1 = getDigit(sum1);\n  sum2 += dv1 * weights[baseCnpj.length]; // Adiciona o primeiro dígito ao cálculo do segundo.\n  const dv2 = getDigit(sum2);\n\n  return `${dv1}${dv2}`;\n}\n\n/**\n * Valida um número de CNPJ (Cadastro Nacional da Pessoa Jurídica).\n *\n * @summary Valida um CNPJ, com suporte a formatos alfanuméricos.\n * @description A função suporta o formato numérico padrão e o futuro formato alfanumérico.\n * A entrada pode conter ou não os caracteres de máscara comuns ('.', '/', '-').\n *\n * @param {string | number} cnpj O CNPJ a ser validado.\n * @param {object} [options={}] Opções de configuração para a validação.\n * @param {string} [options.addPaddingChar=\"0\"] Caractere a ser usado para preencher a entrada até 14 caracteres.\n * @param {number[]} [options.weights=DEFAULT_WEIGHTS] Array de pesos para o cálculo dos dígitos verificadores.\n * @param {boolean} [options.ignoreToUpperCase=true] Se `false`, a entrada é convertida para maiúsculas. Se `true`, a validação diferencia maiúsculas de minúsculas.\n * @param {boolean} [options.ignorePadding=false] Se `true`, a função não adiciona preenchimento, validando a entrada como está.\n * @returns {boolean} Retorna `true` se o CNPJ for válido, e `false` caso contrário.\n */\nfunction validateCNPJ(cnpj = \"\", options = {}) {\n  // 1. Normalização e Configuração\n  let processedCnpj = String(cnpj).replace(/[./-]/g, \"\");\n\n  const finalOptions = {\n    addPaddingChar: \"0\",\n    weights: DEFAULT_WEIGHTS,\n    ignorePadding: false,\n    ignoreToUpperCase: true,\n    ...options,\n  };\n\n  // A conversão para maiúsculas é um comportamento opcional controlado via `options`.\n  if (finalOptions.ignoreToUpperCase === false) {\n    processedCnpj = processedCnpj.toUpperCase();\n  }\n\n  if (!finalOptions.ignorePadding) {\n    processedCnpj = processedCnpj.padStart(14, finalOptions.addPaddingChar);\n  }\n\n  // 2. Regras de Validação de Formato e Casos Inválidos\n\n  // O CNPJ deve consistir em 12 caracteres alfanuméricos (base) e 2 dígitos (verificadores).\n  const regexCNPJ = /^([A-Z\\d]){12}(\\d){2}$/;\n  if (!regexCNPJ.test(processedCnpj)) {\n    return false;\n  }\n  \n  // Para CNPJs puramente numéricos, sequências de dígitos repetidos são inválidas (ex: '111...').\n  if (/^\\d+$/.test(processedCnpj) && /^(\\d)\\1{13}$/.test(processedCnpj)) {\n    return false;\n  }\n\n  // 3. Cálculo e Verificação Final\n  const baseDigits = processedCnpj.substring(0, 12);\n  const verifierDigits = processedCnpj.substring(12);\n\n  const calculatedVerifierDigits = _calculateVerifierDigits(baseDigits, finalOptions.weights);\n\n  return verifierDigits === calculatedVerifierDigits;\n}\n\n// ------------------------------------------------------------------------------------------------\n\n// Exporta a função para uso em ambientes Node.js (CommonJS).\nexport default validateCNPJ;\n\n// ------------------------------------------------------------------------------------------------","/**\n * @fileoverview Fornece uma função para validar números de CPF (Cadastro de Pessoas Físicas).\n * O código é compatível com ambientes Node.js e navegadores.\n */\n\n/**\n * Calcula um dígito verificador de CPF a partir de uma base de dígitos.\n * O algoritmo é o mesmo para o primeiro e o segundo dígito, variando apenas o tamanho da base.\n *\n * @private\n * @param {string} baseDigits - A sequência de dígitos para o cálculo (9 para o 1º dígito, 10 para o 2º).\n * @returns {number} O dígito verificador calculado.\n */\nfunction _calculateVerifierDigit(baseDigits) {\n  // O peso inicial é o tamanho da base + 1 (10 para o 1º dígito, 11 para o 2º).\n  const initialWeight = baseDigits.length + 1;\n\n  // Calcula a soma ponderada dos dígitos.\n  const sum = baseDigits\n    .split('')\n    .reduce((acc, digit, index) => acc + (Number(digit) * (initialWeight - index)), 0);\n\n  const remainder = sum % 11;\n\n  // Se o resto da divisão for menor que 2, o dígito é 0; caso contrário, é 11 menos o resto.\n  return remainder < 2 ? 0 : 11 - remainder;\n}\n\n/**\n * Valida um número de CPF (Cadastro de Pessoas Físicas).\n *\n * @summary Valida um CPF, numérico ou com máscara.\n * @description A função remove caracteres de máscara, verifica casos inválidos conhecidos\n * e calcula os dois dígitos verificadores para confirmar a validade do CPF.\n *\n * @param {string | number} cpf O número de CPF a ser validado.\n * @returns {boolean} Retorna `true` se o CPF for válido, e `false` caso contrário.\n * @example\n * validateCPF(\"123.456.789-00\"); // Exemplo válido\n * validateCPF(\"111.111.111-11\"); // Retorna false\n */\nfunction validateCPF(cpf = \"\") {\n  // 1. Normalização da Entrada\n  const digitsOnly = String(cpf).replace(/[^\\d]/g, '');\n\n  const CPF_LENGTH = 11;\n\n  // Rejeita a entrada se, após a limpeza, estiver vazia ou com mais de 11 dígitos.\n  if (digitsOnly === '' || digitsOnly.length > CPF_LENGTH) {\n    return false;\n  }\n\n  // Garante que a string tenha 11 dígitos, preenchendo com zeros à esquerda se necessário.\n  const paddedCpf = digitsOnly.padStart(CPF_LENGTH, '0');\n\n  // 2. Verificação de Casos Inválidos\n  // CPFs com todos os dígitos iguais são inválidos. A regex /^(\\d)\\1{10}$/ checa essa condição.\n  if (/^(\\d)\\1{10}$/.test(paddedCpf)) {\n    return false;\n  }\n\n  // 3. Cálculo e Validação dos Dígitos\n  const baseDv1 = paddedCpf.substring(0, 9);\n  const expectedDv1 = _calculateVerifierDigit(baseDv1);\n\n  // Compara o primeiro dígito verificador calculado com o fornecido.\n  if (expectedDv1 !== Number(paddedCpf[9])) {\n    return false;\n  }\n\n  const baseDv2 = paddedCpf.substring(0, 10);\n  const expectedDv2 = _calculateVerifierDigit(baseDv2);\n\n  // Compara o segundo dígito e retorna o resultado final da validação.\n  return expectedDv2 === Number(paddedCpf[10]);\n}\n\n// ------------------------------------------------------------------------------------------------\n\n// Exporta a função para uso em ambientes Node.js (CommonJS).\nexport default validateCPF;\n\n// ------------------------------------------------------------------------------------------------","/**\n * @fileoverview Fornece uma função para validar endereços de e-mail.\n * O código é compatível com ambientes Node.js e navegadores.\n */\n\n/**\n * Expressão regular para validar a maioria dos formatos de e-mail padrão.\n * Definida como uma constante fora da função para evitar a recompilação a cada\n * chamada, o que melhora a performance.\n * @private\n * @type {RegExp}\n */\nconst EMAIL_REGEX =\n  /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n\n/**\n * Valida um endereço de e-mail com base em um formato padrão.\n *\n * @summary Valida um endereço de e-mail.\n * @description A função verifica se a string fornecida corresponde a um formato de e-mail\n * comum, cobrindo a maioria dos casos de uso padrão (ex: `usuario@dominio.com`).\n *\n * @param {string | any} email O valor a ser verificado. A função o converterá para string.\n * @returns {boolean} Retorna `true` se o e-mail tiver um formato válido, e `false` caso contrário.\n * @example\n * validateEmail(\"contato@exemplo.com\"); // true\n * validateEmail(\"email-invalido\");       // false\n */\nfunction validateEmail(email = \"\") {\n  // Converte a entrada para string para garantir que o método .test() funcione.\n  const emailAsString = String(email);\n\n  // Testa a string contra a expressão regular pré-compilada.\n  return EMAIL_REGEX.test(emailAsString);\n}\n\n// ------------------------------------------------------------------------------------------------\n\n// Exporta a função para uso em ambientes Node.js (CommonJS).\nexport default validateEmail;\n\n// ------------------------------------------------------------------------------------------------\n","/**\n * @fileoverview Fornece uma função para validar Chaves PIX.\n */\n\nimport validateCNPJ from \"./validateCNPJ\";\nimport validateCPF from \"./validateCPF\";\nimport validateEmail from \"./validateEmail\";\n\n/**\n * Regex para validar um UUID v4 (formato da Chave Aleatória PIX).\n * @private\n */\nconst UUID_V4_REGEX =\n  /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n\n/**\n * Regex para validar um número de telefone brasileiro no formato PIX (+55DDXXXXXXXXX).\n * @private\n */\n// Versão Oficial: Aceita 10 (fixo) ou 11 (celular) dígitos após o +55.\nconst PIX_PHONE_REGEX = /^\\+55\\d{10,11}$/;\n\n/**\n * @summary Valida uma Chave PIX de qualquer tipo, incluindo CNPJ alfanumérico.\n * @description\n * A função verifica se a chave fornecida corresponde a um dos cinco formatos\n * válidos de Chave PIX, delegando a validação de CPF, CNPJ e E-mail para as\n * funções correspondentes.\n *\n * @param {string} [chave=\"\"] - A Chave PIX a ser validada.\n * @returns {boolean} Retorna `true` se a chave for válida, e `false` caso contrário.\n *\n * @example\n * validateChavePix(\"meu.email@valido.com\"); // true\n * validateChavePix(\"11122233344\");         // true (se for um CPF válido)\n * validateChavePix(\"+5511987654321\");      // true (celular)\n * validateChavePix(\"+554133334444\");       // true (fixo)\n */\nfunction validateChavePix(chave = \"\") {\n  // Converte a entrada para string e remove espaços das pontas.\n  const keyAsString = String(chave || \"\").trim();\n\n  // Uma chave PIX não pode ser vazia.\n  if (keyAsString === \"\") {\n    return false;\n  }\n\n  // A ordem de verificação é importante para performance e para evitar ambiguidades.\n  if (UUID_V4_REGEX.test(keyAsString)) return true;\n  if (PIX_PHONE_REGEX.test(keyAsString)) return true;\n  if (keyAsString.includes(\"@\")) return validateEmail(keyAsString);\n  \n  // Para os formatos restantes (CPF/CNPJ), delega a validação.\n  if (validateCPF(keyAsString)) {\n    return true;\n  }\n  \n  if (validateCNPJ(keyAsString)) {\n    return true;\n  }\n\n  // Se não se encaixou em nenhum formato, é inválida.\n  return false;\n}\n\n// ------------------------------------------------------------------------------------------------\nexport default validateChavePix;","/**\n * @fileoverview Fornece uma função para validar números de CNH.\n */\n\n/**\n * Pesos para o cálculo do primeiro e segundo dígito verificador da CNH.\n * @private\n */\nconst CNH_WEIGHTS_DV1 = [9, 8, 7, 6, 5, 4, 3, 2, 1];\nconst CNH_WEIGHTS_DV2 = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\n/**\n * Valida um número de CNH (Carteira Nacional de Habilitação).\n *\n * @summary Valida um número de CNH.\n * @description A função verifica o formato, a regra de dígitos repetidos e calcula os\n * dois dígitos verificadores para confirmar a validade do número.\n *\n * @param {string | number} cnh O número da CNH a ser validado.\n * @returns {boolean} Retorna `true` se a CNH for válida, e `false` caso contrário.\n */\nfunction validateCNH(cnh = \"\") {\n  const digitsOnly = String(cnh).replace(/[^\\d]/g, \"\");\n\n  if (digitsOnly.length !== 11 || /^(\\d)\\1{10}$/.test(digitsOnly)) {\n    return false;\n  }\n\n  const base = digitsOnly.substring(0, 9);\n  const verifierDigits = digitsOnly.substring(9);\n\n  // --- Cálculo do primeiro dígito ---\n  const sum1 = base\n    .split(\"\")\n    .reduce(\n      (acc, digit, index) => acc + Number(digit) * CNH_WEIGHTS_DV1[index],\n      0\n    );\n\n  const remainder1 = sum1 % 11;\n  const calculatedDv1 = remainder1 >= 10 ? 0 : remainder1;\n\n  if (calculatedDv1 !== Number(verifierDigits[0])) {\n    return false;\n  }\n\n  // --- Cálculo do segundo dígito ---\n  const sum2 = base\n    .split(\"\")\n    .reduce(\n      (acc, digit, index) => acc + Number(digit) * CNH_WEIGHTS_DV2[index],\n      0\n    );\n\n  const remainder2 = sum2 % 11;\n  const calculatedDv2 = remainder2 >= 10 ? 0 : remainder2;\n\n  return calculatedDv2 === Number(verifierDigits[1]);\n}\n\n// ------------------------------------------------------------------------------------------------\nexport default validateCNH;\n// ------------------------------------------------------------------------------------------------\n","/**\n * @fileoverview Fornece uma função para validar números de PIS/PASEP/NIT.\n */\n\n/**\n * Array de pesos utilizado no algoritmo de cálculo do dígito verificador.\n * @private\n * @type {number[]}\n */\nconst PIS_WEIGHTS = [3, 2, 9, 8, 7, 6, 5, 4, 3, 2];\n\n/**\n * Valida um número de PIS/PASEP/NIT.\n *\n * @summary Valida um número de PIS/PASEP/NIT.\n * @description A função verifica o formato, a regra de dígitos repetidos e o dígito\n * verificador para confirmar a validade do número.\n *\n * @param {string | number} pis O número a ser validado.\n * @returns {boolean} Retorna `true` se o número for válido, e `false` caso contrário.\n * @example\n * validatePISPASEPNIT(\"120.12345.67-8\"); // true\n * validatePISPASEPNIT(\"11111111111\");    // false\n */\nfunction validatePISPASEPNIT(pis = \"\") {\n  const digitsOnly = String(pis).replace(/[^\\d]/g, \"\");\n\n  if (digitsOnly.length !== 11 || /^(\\d)\\1{10}$/.test(digitsOnly)) {\n    return false;\n  }\n\n  const base = digitsOnly.substring(0, 10);\n  const verifierDigit = Number(digitsOnly[10]);\n\n  const sum = base\n    .split(\"\")\n    .reduce((acc, digit, index) => acc + Number(digit) * PIS_WEIGHTS[index], 0);\n\n  const remainder = sum % 11;\n  const calculatedDigit = remainder < 2 ? 0 : 11 - remainder;\n\n  return verifierDigit === calculatedDigit;\n}\n\n// ------------------------------------------------------------------------------------------------\nexport default validatePISPASEPNIT;\n// ------------------------------------------------------------------------------------------------\n","/**\n * @fileoverview Fornece uma função para validar códigos de RENAVAM.\n */\n\n/**\n * Array de pesos utilizado no cálculo do dígito verificador do RENAVAM.\n * @private\n * @type {number[]}\n */\nconst RENAVAM_WEIGHTS = [2, 3, 4, 5, 6, 7, 8, 9, 2, 3];\n\n/**\n * Valida um código de RENAVAM (Registro Nacional de Veículos Automotores).\n *\n * @summary Valida um código de RENAVAM.\n * @description A função valida o formato de 11 dígitos (preenchendo com zeros se\n * necessário) e calcula o dígito verificador para confirmar sua validade.\n *\n * @param {string | number} renavam O código a ser validado.\n * @returns {boolean} Retorna `true` se o RENAVAM for válido, e `false` caso contrário.\n */\nfunction validateRENAVAM(renavam = \"\") {\n  const digitsOnly = String(renavam).replace(/[^\\d]/g, \"\").padStart(11, \"0\");\n\n  if (digitsOnly.length !== 11 || /^(\\d)\\1{10}$/.test(digitsOnly)) {\n    return false;\n  }\n\n  const base = digitsOnly.substring(0, 10);\n  const verifierDigit = Number(digitsOnly[10]);\n\n  const reversedBase = base.split(\"\").reverse();\n\n  const sum = reversedBase.reduce(\n    (acc, digit, index) => acc + Number(digit) * RENAVAM_WEIGHTS[index],\n    0\n  );\n\n  const remainder = sum % 11;\n  const calculatedDigit = remainder <= 1 ? 0 : 11 - remainder;\n\n  return verifierDigit === calculatedDigit;\n}\n\n// ------------------------------------------------------------------------------------------------\nexport default validateRENAVAM;\n// ------------------------------------------------------------------------------------------------\n","/**\n * @fileoverview Fornece uma função para validar números de Título de Eleitor.\n */\n\n/**\n * Pesos para o cálculo do primeiro dígito verificador.\n * @private\n */\nconst TITULO_WEIGHTS_DV1 = [2, 3, 4, 5, 6, 7, 8, 9];\n\n/**\n * Valida um número de Título de Eleitor.\n *\n * @summary Valida um número de Título de Eleitor.\n * @description A função valida o formato de 12 dígitos e calcula ambos os dígitos\n * verificadores, considerando as regras especiais baseadas no estado de emissão.\n *\n * @param {string | number} titulo O número do título a ser validado.\n * @returns {boolean} Retorna `true` se o título for válido, e `false` caso contrário.\n */\nfunction validateTituloEleitor(titulo = \"\") {\n  // Verifica se o parâmetro é nulo ou indefinido\n  if (titulo == null) {\n    return false;\n  }\n\n  const digitsOnly = String(titulo).replace(/[^\\d]/g, \"\").padStart(12, \"0\");\n\n  if (digitsOnly.length !== 12) {\n    return false;\n  }\n\n  const base = digitsOnly.substring(0, 8);\n  const stateCode = Number(digitsOnly.substring(8, 10));\n  const verifierDigits = digitsOnly.substring(10);\n\n  // O código de estado deve ser válido (entre 1 e 28)\n  if (stateCode < 1 || stateCode > 28) {\n    return false;\n  }\n\n  // --- Cálculo do primeiro dígito verificador ---\n  const sum1 = base\n    .split(\"\")\n    .reduce(\n      (acc, digit, index) => acc + Number(digit) * TITULO_WEIGHTS_DV1[index],\n      0\n    );\n\n  let remainder1 = sum1 % 11;\n  let calculatedDv1;\n\n  // Regras para o primeiro DV baseadas na documentação oficial:\n  // - Se resto for 0: para SP (01) e MG (02) é 1, para outros estados é 0\n  // - Se resto for maior que 9: é 0\n  // - Nos outros casos: é o próprio resto\n  if (remainder1 === 0) {\n    calculatedDv1 = (stateCode === 1 || stateCode === 2) ? 1 : 0;\n  } else if (remainder1 > 9) {\n    calculatedDv1 = 0;\n  } else {\n    calculatedDv1 = remainder1;\n  }\n\n  if (calculatedDv1 !== Number(verifierDigits[0])) {\n    return false;\n  }\n\n  // --- Cálculo do segundo dígito verificador ---\n  const digit1 = Number(digitsOnly.substring(8, 9)); // Primeiro dígito do código do estado\n  const digit2 = Number(digitsOnly.substring(9, 10)); // Segundo dígito do código do estado\n  \n  const sum2 = (digit1 * 7) + (digit2 * 8) + (calculatedDv1 * 9);\n\n  let remainder2 = sum2 % 11;\n  let calculatedDv2;\n  \n  // Mesma lógica do primeiro dígito verificador.\n  if (remainder2 === 0) {\n    calculatedDv2 = (stateCode === 1 || stateCode === 2) ? 1 : 0;\n  } else if (remainder2 > 9) {\n    calculatedDv2 = 0;\n  } else {\n    calculatedDv2 = remainder2;\n  }\n\n  return calculatedDv2 === Number(verifierDigits[1]);\n}\n\n// ------------------------------------------------------------------------------------------------\nexport default validateTituloEleitor;\n// ------------------------------------------------------------------------------------------------","/**\n * @fileoverview Fornece uma função para validar números de RG (Registro Geral) brasileiro.\n */\n\n/**\n * Pesos para o cálculo do dígito verificador do RG.\n * Os fatores multiplicadores crescem da esquerda para a direita, iniciando em 2.\n * @private\n */\nconst RG_WEIGHTS = [2, 3, 4, 5, 6, 7, 8, 9];\n\n/**\n * Valida um número de RG (Registro Geral) brasileiro.\n *\n * @summary Valida um número de RG brasileiro usando o algoritmo de módulo 11.\n * @description A função valida o formato de 8 dígitos seguido por um dígito verificador,\n * que pode ser um número (0-9) ou a letra 'X' quando o cálculo resulta em 10.\n * Remove automaticamente pontuação e formatação do input.\n *\n * @param {string | number} rg O número do RG a ser validado (com ou sem formatação).\n * @returns {boolean} Retorna `true` se o RG for válido, e `false` caso contrário.\n *\n * @example\n * validateRG('24.678.131-4'); // true\n * validateRG('37.606.335-X'); // true\n * validateRG('45.727.503-0'); // true\n * validateRG('123456789'); // false\n * validateRG('24678131X'); // false (dígito verificador incorreto)\n */\nfunction validateRG(rg = \"\") {\n  // Verifica se o parâmetro é nulo ou indefinido\n  if (rg == null) {\n    return false;\n  }\n\n  // Remove toda formatação, mantendo apenas números e a letra X\n  const cleanRG = String(rg)\n    .toUpperCase()\n    .replace(/[^\\dX]/g, \"\");\n\n  // RG deve ter exatamente 9 caracteres (8 dígitos + 1 verificador)\n  if (cleanRG.length !== 9) {\n    return false;\n  }\n\n  // Extrai os 8 primeiros dígitos (base) e o dígito verificador\n  const base = cleanRG.substring(0, 8);\n  const verifierDigit = cleanRG.substring(8);\n\n  // Verifica se a base contém apenas dígitos\n  if (!/^\\d{8}$/.test(base)) {\n    return false;\n  }\n\n  // Verifica se o dígito verificador é válido (0-9 ou X)\n  if (!/^[\\dX]$/.test(verifierDigit)) {\n    return false;\n  }\n\n  // Verifica se todos os dígitos da base são iguais (RG inválido por convenção)\n  if (/^(\\d)\\1{7}$/.test(base)) {\n    return false;\n  }\n\n  // --- Cálculo do dígito verificador usando módulo 11 ---\n  \n  // Multiplica cada dígito pelo seu peso correspondente\n  const sum = base\n    .split(\"\")\n    .reduce((acc, digit, index) => {\n      return acc + (Number(digit) * RG_WEIGHTS[index]);\n    }, 0);\n\n  // Calcula o resto da divisão por 11\n  const remainder = sum % 11;\n  \n  // Calcula o complemento (11 - resto)\n  const complement = 11 - remainder;\n  \n  // Determina o dígito verificador calculado\n  let calculatedDigit;\n  \n  if (complement === 10) {\n    // Quando o complemento é 10, o dígito verificador é 'X'\n    calculatedDigit = 'X';\n  } else if (complement === 11) {\n    // Quando o complemento é 11, o dígito verificador é '0'\n    calculatedDigit = '0';\n  } else {\n    // Para outros casos, o dígito verificador é o próprio complemento\n    calculatedDigit = String(complement);\n  }\n\n  // Compara o dígito calculado com o fornecido\n  return calculatedDigit === verifierDigit;\n}\n\n// ------------------------------------------------------------------------------------------------\nexport default validateRG;\n// ------------------------------------------------------------------------------------------------","import getCrypto from \"./getCrypto.js\";\nimport decrypt from \"./decrypt.js\";\nimport encrypt from \"./encrypt.js\";\nimport decryptBuffer from \"./decryptBuffer.js\";\nimport encryptBuffer from \"./encryptBuffer.js\";\nimport digest from \"./digest.js\";\nimport importCryptoKey from \"./importCryptoKey.js\";\nimport verifySignature from \"./verifySignature.js\";\n\n// Named exports para importação individual\nexport {\n  getCrypto,\n  decrypt,\n  encrypt,\n  decryptBuffer,\n  encryptBuffer,\n  digest,\n  importCryptoKey,\n  verifySignature,\n};\n\n// Default export para compatibilidade\nexport default {\n  getCrypto,\n  decrypt,\n  encrypt,\n  decryptBuffer,\n  encryptBuffer,\n  digest,\n  importCryptoKey,\n  verifySignature,\n};\n","import getCrypto from \"./getCrypto\";\nimport bufferToString from \"../utils/bufferToString\";\nimport base64ToBuffer from \"../utils/base64ToBuffer\";\nimport importCryptoKey from \"./importCryptoKey.js\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Asynchronously decrypts an encrypted message using a provided private key.\n * \n * This function performs RSA-OAEP decryption using the Web Crypto API, supporting both\n * Node.js and browser environments. It handles PEM-formatted private keys and base64-encoded\n * encrypted messages, providing a secure and efficient decryption process.\n *\n * @async\n * @function decrypt\n * @param {string} privateKey - The PEM-encoded private key used for decryption\n * @param {string} encryptedMessage - The base64-encoded encrypted message to decrypt\n * @param {Object} [props={}] - Configuration options for the decryption process\n * @param {string} [props.format=\"pkcs8\"] - Private key format specification\n * @param {Object} [props.algorithm] - Cryptographic algorithm configuration\n * @param {string} [props.algorithm.name=\"RSA-OAEP\"] - Algorithm name\n * @param {Object} [props.algorithm.hash] - Hash algorithm configuration\n * @param {string} [props.algorithm.hash.name=\"SHA-256\"] - Hash algorithm name\n * @param {boolean} [props.extractable=true] - Whether the imported key can be extracted\n * @param {string[]} [props.keyUsages=[\"decrypt\"]] - Permitted key usage operations\n * @param {string} [props.padding=\"RSA-OAEP\"] - Padding scheme for decryption operation\n * @returns {Promise<string>} The decrypted message as a UTF-8 string\n * @throws {Error} When decryption fails due to invalid key, corrupted data, or crypto errors\n * \n * @example\n * const decryptedText = await decrypt(pemPrivateKey, base64EncryptedMessage);\n * \n * @example\n * const decryptedText = await decrypt(pemPrivateKey, base64EncryptedMessage, {\n *   algorithm: { name: \"RSA-OAEP\", hash: { name: \"SHA-1\" } },\n *   extractable: false\n * });\n */\nasync function decrypt(privateKey, encryptedMessage, props = {}) {\n  // Early return for empty encrypted messages to avoid unnecessary processing\n  if (!encryptedMessage) {\n    return \"\";\n  }\n\n  // Destructure configuration with optimized defaults\n  const {\n    format = \"pkcs8\",\n    algorithm = { name: \"RSA-OAEP\", hash: { name: \"SHA-256\" } },\n    extractable = true,\n    keyUsages = [\"decrypt\"],\n    padding = \"RSA-OAEP\"\n  } = props || {};\n\n  // Get crypto implementation (Node.js or browser)\n  const crypto = getCrypto();\n\n  // Clean and convert PEM private key to binary format\n  // Removes PEM headers, footers, and whitespace in a single operation\n  const cleanedPrivateKey = privateKey.replace(\n    /-----(BEGIN|END) (?:RSA )?(?:PRIVATE|PUBLIC) KEY-----|\\s/g,\n    \"\"\n  );\n  const binaryPrivateKey = base64ToBuffer(cleanedPrivateKey);\n\n  // Import the private key for cryptographic operations\n  const importedKey = await importCryptoKey(\n    format,\n    binaryPrivateKey,\n    algorithm,\n    extractable,\n    keyUsages\n  );\n\n  // Convert base64 encrypted message to binary data\n  const encryptedData = base64ToBuffer(encryptedMessage);\n\n  // Perform decryption using the Web Crypto API\n  const decryptedBuffer = await crypto.subtle.decrypt(\n    { name: padding },\n    importedKey,\n    encryptedData\n  );\n\n  // Convert decrypted binary data back to string\n  return bufferToString(decryptedBuffer);\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default decrypt;\n\n// ------------------------------------------------------------------------------------------------","import getCrypto from \"./getCrypto.js\";\nimport bufferFromString from \"../utils/bufferFromString\";\nimport base64FromBuffer from \"../utils/base64FromBuffer.js\";\nimport importCryptoKey from \"./importCryptoKey.js\";\nimport base64ToBuffer from \"../utils/base64ToBuffer.js\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Encrypts a message using asymmetric cryptography with public key encryption.\n *\n * This function provides a complete encryption workflow that handles PEM-formatted\n * public keys, performs key importation, and encrypts plaintext messages using\n * industry-standard cryptographic algorithms. It supports various RSA encryption\n * schemes and is designed for secure data transmission scenarios where the sender\n * has access to the recipient's public key.\n *\n * The function automatically handles key format conversion from PEM to binary,\n * imports the key into the Web Crypto API, performs the encryption operation,\n * and returns the result as a base64-encoded string for easy transmission.\n *\n * @async\n * @param {string} publicKey - The public key in PEM format for encryption:\n *                            - Must be a valid PEM-encoded public key string\n *                            - Supports standard PEM headers (BEGIN/END PUBLIC KEY)\n *                            - Can include RSA-specific headers (BEGIN/END RSA PUBLIC KEY)\n *                            - Whitespace and line breaks are automatically handled\n *                            - Key should be compatible with the specified algorithm\n *\n * @param {string} message - The plaintext message to encrypt:\n *                          - UTF-8 encoded string that will be converted to binary\n *                          - Empty strings are handled gracefully (returns empty result)\n *                          - Message length is limited by the key size and padding:\n *                            - RSA-OAEP with 2048-bit key: ~190 bytes max\n *                            - RSA-OAEP with 4096-bit key: ~446 bytes max\n *                          - For larger messages, consider hybrid encryption approaches\n *\n * @param {Object} [props={}] - Configuration options for encryption parameters:\n * @param {string} [props.format='spki'] - Public key import format:\n *                            - 'spki': SubjectPublicKeyInfo format (most common for public keys)\n *                            - 'raw': Raw key data (not typical for RSA keys)\n *                            - 'jwk': JSON Web Key format\n *\n * @param {Object} [props.algorithm] - Cryptographic algorithm specification:\n *                            Default: { name: 'RSA-OAEP', hash: { name: 'SHA-256' } }\n *                            Supported algorithms:\n *                            - RSA-OAEP: Optimal Asymmetric Encryption Padding\n *                            - RSA-PKCS1-v1_5: PKCS#1 v1.5 padding (legacy, less secure)\n *                            Hash options: SHA-1, SHA-256, SHA-384, SHA-512\n *\n * @param {boolean} [props.extractable=true] - Key extractability setting:\n *                            - true: Key can be exported after import (default)\n *                            - false: Key cannot be extracted (more secure)\n *                            - Generally safe to leave as true for public keys\n *\n * @param {string[]} [props.keyUsages=['encrypt']] - Permitted key operations:\n *                            - ['encrypt']: Only encryption operations (default)\n *                            - ['encrypt', 'wrapKey']: Encryption and key wrapping\n *                            - Must include 'encrypt' for this function to work\n *\n * @param {string} [props.padding='RSA-OAEP'] - Encryption padding scheme:\n *                            - 'RSA-OAEP': Optimal Asymmetric Encryption Padding (recommended)\n *                            - 'RSA-PKCS1-v1_5': PKCS#1 v1.5 padding (legacy)\n *                            - Should match the algorithm.name parameter\n *\n * @returns {Promise<string>} Promise resolving to encrypted data:\n *                           - Base64-encoded string representation of encrypted bytes\n *                           - Ready for transmission over text-based protocols\n *                           - Can be stored safely in JSON, XML, or database text fields\n *                           - Returns empty string if input message is empty\n *\n * @throws {Error} Throws an error when:\n *                 - Public key is malformed or invalid PEM format\n *                 - Key is incompatible with the specified algorithm\n *                 - Message exceeds maximum size for the key/padding combination\n *                 - Cryptographic operation fails due to invalid parameters\n *                 - Required crypto modules are unavailable in the environment\n *\n * @example\n * // Basic RSA-OAEP encryption with default parameters\n * const publicKeyPem = `-----BEGIN PUBLIC KEY-----\n * MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...\n * -----END PUBLIC KEY-----`;\n *\n * const encrypted = await encrypt(publicKeyPem, 'Hello, World!');\n * console.log('Encrypted message:', encrypted);\n *\n * @example\n * // Advanced encryption with custom algorithm parameters\n * const customEncrypted = await encrypt(\n *   publicKeyPem,\n *   'Sensitive data',\n *   {\n *     algorithm: {\n *       name: 'RSA-OAEP',\n *       hash: { name: 'SHA-512' }\n *     },\n *     extractable: false,\n *     keyUsages: ['encrypt'],\n *     padding: 'RSA-OAEP'\n *   }\n * );\n *\n * @example\n * // Handle encryption errors gracefully\n * try {\n *   const result = await encrypt(publicKey, message);\n *   // Transmit or store the encrypted result\n *   await sendSecureMessage(result);\n * } catch (error) {\n *   console.error('Encryption failed:', error.message);\n *   // Implement fallback or error reporting\n * }\n *\n * @example\n * // Empty message handling\n * const emptyResult = await encrypt(publicKey, '');\n * console.log(emptyResult === ''); // true\n */\nasync function encrypt(publicKey, message, props = {}) {\n  // Handle empty message case early for performance\n  if (!message) return \"\";\n\n  // Extract crypto module for the current environment\n  const crypto = getCrypto();\n\n  // Clean and convert PEM-formatted public key to binary format\n  // Remove PEM headers, footers, and whitespace to get pure base64 content\n  const cleanedPublicKey = publicKey.replace(\n    /(-----(BEGIN|END) (RSA )?(PRIVATE|PUBLIC) KEY-----|\\s)/g,\n    \"\"\n  );\n  const binaryPublicKey = base64ToBuffer(cleanedPublicKey);\n\n  const {\n    format = \"spki\",\n    algorithm = { name: \"RSA-OAEP\", hash: { name: \"SHA-256\" } },\n    extractable = true,\n    keyUsages = [\"encrypt\"],\n    padding = \"RSA-OAEP\",\n  } = props || {};\n\n  // Import the public key into Web Crypto API format\n  // Use provided parameters or sensible defaults for RSA-OAEP encryption\n  const importedKey = await importCryptoKey(\n    format || \"spki\",\n    binaryPublicKey,\n    algorithm || {\n      name: \"RSA-OAEP\",\n      hash: { name: \"SHA-256\" },\n    },\n    extractable !== undefined ? extractable : true,\n    keyUsages || [\"encrypt\"]\n  );\n\n  // Convert message string to binary format for encryption\n  const messageBuffer = bufferFromString(message);\n\n  // Perform the actual encryption operation using the imported key\n  // The padding parameter determines the encryption scheme used\n  const encryptedBuffer = await crypto.subtle.encrypt(\n    { name: padding || \"RSA-OAEP\" },\n    importedKey,\n    messageBuffer\n  );\n\n  // Convert encrypted binary data to base64 for safe text transmission\n  return base64FromBuffer(encryptedBuffer);\n}\n\n// ------------------------------------------------------------------------------------------------\n\n// Export for CommonJS compatibility (Node.js)\nexport default encrypt;\n","import getCrypto from \"./getCrypto\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Computes a cryptographic hash (digest) of the given data using the specified algorithm.\n * \n * This function provides a unified interface for cryptographic hashing that works seamlessly\n * across both Node.js and browser environments. It automatically handles string-to-binary\n * conversion and selects the appropriate hashing implementation based on the runtime environment.\n *\n * @async\n * @function digest\n * @param {string} algorithm - The hash algorithm identifier (e.g., 'SHA-256', 'SHA-1', 'SHA-512')\n * @param {string|Uint8Array} data - The input data to hash - string or binary array\n * @returns {Promise<Uint8Array>} The computed cryptographic hash as a Uint8Array\n * @throws {Error} When the algorithm is unsupported or hashing operation fails\n *\n * @example\n * // Hash a string using SHA-256\n * const hash = await digest('SHA-256', 'hello world');\n * console.log(Array.from(hash).map(b => b.toString(16).padStart(2, '0')).join(''));\n *\n * @example\n * // Hash binary data using SHA-1\n * const binaryData = new Uint8Array([72, 101, 108, 108, 111]);\n * const hash = await digest('SHA-1', binaryData);\n * console.log(hash);\n *\n * @example\n * // Hash large text content\n * const content = 'Lorem ipsum dolor sit amet...';\n * const hash = await digest('SHA-512', content);\n * console.log(hash.length); // 64 bytes for SHA-512\n */\nasync function digest(algorithm, data) {\n  // Convert string data to Uint8Array using optimized approach\n  const binaryData = typeof data === \"string\" \n    ? new TextEncoder().encode(data)\n    : data;\n\n  // Get the appropriate crypto implementation for current environment\n  const crypto = getCrypto();\n\n  // Use Web Crypto API in browser environment for better performance and security\n  if (typeof window !== \"undefined\") {\n    const hashBuffer = await crypto.subtle.digest(algorithm, binaryData);\n    return new Uint8Array(hashBuffer);\n  }\n\n  // Use Node.js crypto module in server environment\n  // Convert Web Crypto API algorithm names to Node.js format if needed\n  const nodeAlgorithm = algorithm.toLowerCase().replace('-', '');\n  const hash = crypto.createHash(nodeAlgorithm).update(binaryData).digest();\n  \n  // Ensure consistent Uint8Array return type across environments\n  return new Uint8Array(hash);\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default digest;\n\n// ------------------------------------------------------------------------------------------------","import getCrypto from './getCrypto';\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Verifies digital signatures using the Web Crypto API in a cross-platform manner.\n *\n * This function provides a unified interface for cryptographic signature verification\n * across different environments (browser and Node.js). It leverages the Web Crypto API's\n * subtle.verify method to perform secure signature validation using various cryptographic\n * algorithms including RSA-PSS, RSA-PKCS1-v1_5, ECDSA, and HMAC.\n *\n * The verification process involves comparing a provided signature against the expected\n * signature for given data using the specified public key and algorithm. This is essential\n * for ensuring data integrity and authenticity in cryptographic workflows.\n *\n * @param {Object|string} algorithm - Algorithm specification for signature verification:\n *                          - Object: Detailed parameters (e.g., { name: 'RSA-PSS', saltLength: 32 })\n *                          - String: Simple algorithm name (e.g., 'RSA-PSS', 'ECDSA')\n *                          Common algorithms:\n *                          - RSA-PSS: RSA with PSS padding\n *                          - RSA-PKCS1-v1_5: RSA with PKCS#1 v1.5 padding\n *                          - ECDSA: Elliptic Curve Digital Signature Algorithm\n *                          - HMAC: Hash-based Message Authentication Code\n *\n * @param {CryptoKey} key - The cryptographic key used for signature verification:\n *                          - For asymmetric algorithms: Must be a public key with 'verify' usage\n *                          - For symmetric algorithms (HMAC): Can be the same key used for signing\n *                          - Must be compatible with the specified algorithm\n *                          - Key must have been imported with 'verify' in keyUsages array\n *\n * @param {BufferSource|ArrayBuffer|Uint8Array} signature - The digital signature to verify:\n *                          - Binary signature data as BufferSource (ArrayBuffer, Uint8Array, etc.)\n *                          - Must be in the format produced by the corresponding sign operation\n *                          - Length and format depend on the algorithm used:\n *                            - RSA signatures: typically 256 bytes (2048-bit) or 512 bytes (4096-bit)\n *                            - ECDSA signatures: varies by curve (64 bytes for P-256, 96 bytes for P-384)\n *                            - HMAC signatures: depends on hash function (32 bytes for SHA-256)\n *\n * @param {BufferSource|ArrayBuffer|Uint8Array} data - The original data that was signed:\n *                          - Binary data as BufferSource that needs to be verified against signature\n *                          - Must be exactly the same data used during the signing process\n *                          - Any modification to this data will cause verification to fail\n *                          - For text data, ensure consistent encoding (typically UTF-8)\n *\n * @returns {Promise<boolean>} Promise resolving to verification result:\n *                          - true: Signature is valid and data integrity is confirmed\n *                          - false: Signature is invalid, data may have been tampered with\n *                          Note: This method never rejects for invalid signatures, only for\n *                          operational errors (invalid keys, unsupported algorithms, etc.)\n *\n * @throws {Error} Throws an error when:\n *                 - Crypto module is unavailable in the current environment\n *                 - Invalid algorithm specification or unsupported algorithm\n *                 - Key is inappropriate for the algorithm or missing 'verify' usage\n *                 - Signature or data parameters are malformed or incompatible\n *                 - Environment doesn't support the specified cryptographic operations\n *\n * @example\n * // Verify RSA-PSS signature\n * const publicKey = await importCryptoKey(/* RSA public key parameters *);\n * const signatureBytes = new Uint8Array([...]); // RSA signature\n * const originalData = new TextEncoder().encode('Hello, World!');\n * \n * const isValid = await verifySignature(\n *   {\n *     name: 'RSA-PSS',\n *     saltLength: 32\n *   },\n *   publicKey,\n *   signatureBytes,\n *   originalData\n * );\n * console.log('Signature valid:', isValid);\n *\n * @example\n * // Verify ECDSA signature with P-256 curve\n * const ecdsaKey = await importCryptoKey(/* ECDSA public key parameters *);\n * const ecdsaSignature = new Uint8Array([...]); // ECDSA signature (64 bytes for P-256)\n * const messageData = new Uint8Array([...]); // Original message\n * \n * const result = await verifySignature(\n *   { name: 'ECDSA', hash: 'SHA-256' },\n *   ecdsaKey,\n *   ecdsaSignature,\n *   messageData\n * );\n *\n * @example\n * // Verify HMAC signature (symmetric)\n * const hmacKey = await importCryptoKey(/* HMAC key parameters *);\n * const hmacSignature = new Uint8Array(32); // HMAC-SHA256 signature\n * const payload = new TextEncoder().encode('{\"user\": \"john\", \"action\": \"login\"}');\n * \n * try {\n *   const verified = await verifySignature(\n *     { name: 'HMAC', hash: 'SHA-256' },\n *     hmacKey,\n *     hmacSignature,\n *     payload\n *   );\n *   if (verified) {\n *     console.log('Message authenticated successfully');\n *   } else {\n *     console.warn('Message authentication failed - possible tampering');\n *   }\n * } catch (error) {\n *   console.error('Verification error:', error.message);\n * }\n */\nasync function verifySignature(algorithm, key, signature, data) {\n  // Retrieve the appropriate crypto module for the current environment\n  const crypto = getCrypto();\n  \n  // Perform signature verification using the Web Crypto API\n  // The subtle.verify method handles the cryptographic verification process\n  // and returns a boolean indicating signature validity\n  return await crypto.subtle.verify(algorithm, key, signature, data);\n}\n\n// ------------------------------------------------------------------------------------------------\n\n// Export for CommonJS compatibility (Node.js)\nexport default verifySignature;","import convertECDSAASN1Signature from \"./convertECDSAASN1Signature.js\";\nimport getAuthenticationAuthData from \"./getAuthenticationAuthData.js\";\nimport getRegistrationAuthData from \"./getRegistrationAuthData.js\";\nimport getWebAuthnAuthenticationAssertion from \"./getWebAuthnAuthenticationAssertion.js\";\nimport getWebAuthnRegistrationCredential from \"./getWebAuthnRegistrationCredential.js\";\nimport validateRPID from \"./validateRPID.js\";\nimport validateAuthentication from \"./validateAuthentication.js\";\nimport validateRegistration from \"./validateRegistration.js\";\n\n// Named exports para importação individual\nexport { \n  convertECDSAASN1Signature,\n  getAuthenticationAuthData,\n  getRegistrationAuthData,\n  getWebAuthnAuthenticationAssertion,\n  getWebAuthnRegistrationCredential,\n  validateRPID,\n  validateAuthentication,\n  validateRegistration\n};\n\n// Default export para compatibilidade\nexport default {\n  convertECDSAASN1Signature,\n  getAuthenticationAuthData,\n  getRegistrationAuthData,\n  getWebAuthnAuthenticationAssertion,\n  getWebAuthnRegistrationCredential,\n  validateRPID,\n  validateAuthentication,\n  validateRegistration,\n};","import bufferConcatenate from \"../../utils/bufferConcatenate\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Converts an ECDSA signature from ASN.1/DER format to concatenated r|s format.\n * \n * The function expects an ASN.1 SEQUENCE containing exactly two INTEGER elements (r and s).\n * Both r and s components are normalized to be multiples of 128 bits (16 bytes) by:\n * - Removing leading zero bytes used for two's complement padding\n * - Adding zero padding when components are 15 bytes (one byte short of 16-byte boundary)\n *\n * @param {Uint8Array} asn1Signature - The input signature in ASN.1/DER format\n * @returns {Uint8Array} The signature in concatenated r|s format where both r and s are 128-bit aligned\n * @throws {Error} If the input doesn't contain exactly 2 ASN.1 sequence elements\n * @throws {Error} If r or s components have unexpected lengths after normalization\n */\nfunction convertECDSAASN1Signature(asn1Signature) {\n  const elements = readASN1IntegerSequence(asn1Signature);\n  \n  if (elements.length !== 2) {\n    throw new Error(\"Expected 2 ASN.1 sequence elements\");\n  }\n  \n  let [r, s] = elements;\n\n  // Normalize r component to 128-bit boundary\n  r = normalizeECDSAComponent(r);\n  \n  // Normalize s component to 128-bit boundary  \n  s = normalizeECDSAComponent(s);\n\n  // Concatenate normalized r and s components\n  return bufferConcatenate(r, s);\n}\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Normalizes an ECDSA signature component (r or s) to be a multiple of 128 bits (16 bytes).\n * \n * This function handles two cases:\n * 1. Removes leading zero byte if present for two's complement and length is 16n+1\n * 2. Adds leading zero byte padding if length is 16n-1 (15 bytes)\n *\n * @param {Uint8Array} component - The signature component to normalize\n * @returns {Uint8Array} The normalized component aligned to 128-bit boundary\n * @throws {Error} If the component length is not a multiple of 16 bytes after normalization\n */\nfunction normalizeECDSAComponent(component) {\n  const length = component.byteLength;\n  let normalized = component;\n  \n  // Remove leading zero byte used for two's complement if length is 16n+1\n  if (component[0] === 0 && length % 16 === 1) {\n    normalized = component.slice(1);\n  }\n  // Add leading zero byte padding if length is 16n-1 (15 bytes)\n  else if (length % 16 === 15) {\n    const padding = new Uint8Array([0]);\n    normalized = new Uint8Array(bufferConcatenate(padding, component));\n  }\n\n  // Validate that the component is now properly aligned to 128-bit boundary\n  if (normalized.byteLength % 16 !== 0) {\n    throw new Error(\"unknown ECDSA sig r length error\");\n  }\n\n  return normalized;\n}\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Parses an ASN.1/DER encoded sequence and extracts all INTEGER elements.\n * \n * This function performs basic ASN.1 parsing by:\n * 1. Validating the input starts with SEQUENCE tag (0x30)\n * 2. Reading the sequence length from the second byte\n * 3. Iterating through elements, ensuring each is an INTEGER (0x02)\n * 4. Extracting the value portion of each INTEGER element\n *\n * @param {Uint8Array} input - The ASN.1/DER encoded sequence\n * @returns {Array<Uint8Array>} Array of INTEGER values as Uint8Array buffers\n * @throws {Error} If input is not a valid ASN.1 SEQUENCE\n * @throws {Error} If any sequence element is not an ASN.1 INTEGER\n */\nfunction readASN1IntegerSequence(input) {\n  // Validate ASN.1 SEQUENCE tag\n  if (input[0] !== 0x30) {\n    throw new Error(\"Input is not an ASN.1 sequence\");\n  }\n\n  // Extract sequence length from second byte\n  const sequenceLength = input[1];\n  const elements = [];\n  \n  // Get sequence content, skipping tag and length bytes\n  let position = 2;\n  const sequenceEnd = position + sequenceLength;\n\n  // Parse all elements within the sequence\n  while (position < sequenceEnd) {\n    const tag = input[position];\n    \n    // Validate INTEGER tag\n    if (tag !== 0x02) {\n      throw new Error(\"Expected ASN.1 sequence element to be an INTEGER\");\n    }\n\n    // Read element length\n    const elementLength = input[position + 1];\n    \n    // Extract element value, skipping tag and length bytes\n    const elementValue = input.slice(position + 2, position + 2 + elementLength);\n    elements.push(elementValue);\n    \n    // Advance position to next element\n    position += 2 + elementLength;\n  }\n\n  return elements;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default convertECDSAASN1Signature;\n\n// ------------------------------------------------------------------------------------------------","import base64FromBuffer from \"../../utils/base64FromBuffer\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Extracts and processes data from a WebAuthn authentication assertion object.\n * \n * This function parses the WebAuthn assertion response and extracts all relevant\n * authentication data including client data, authenticator data, signature, and\n * optional user handle information.\n *\n * @param {Object} assertion - The WebAuthn authentication assertion object\n * @param {string} assertion.id - The credential ID as a string\n * @param {ArrayBuffer} assertion.rawId - The credential ID as raw bytes\n * @param {string} assertion.type - The credential type (typically \"public-key\")\n * @param {Object} assertion.response - The authenticator assertion response\n * @param {ArrayBuffer} assertion.response.clientDataJSON - Client data in JSON format\n * @param {ArrayBuffer} assertion.response.authenticatorData - Authenticator data bytes\n * @param {ArrayBuffer} assertion.response.signature - The assertion signature\n * @param {ArrayBuffer} [assertion.response.userHandle] - Optional user handle\n * @returns {Object} Extracted authentication data with parsed components\n * @throws {Error} If extraction fails due to missing or invalid data\n */\nfunction getAuthenticationAuthData(assertion) {\n  const id = assertion.id;\n  const rawId = base64FromBuffer(assertion.rawId);\n  const type = assertion.type;\n\n  // Build response object with all authentication data\n  const response = {\n    clientDataJSONDecoded: new TextDecoder().decode(assertion.response.clientDataJSON),\n    clientDataJSON: base64FromBuffer(assertion.response.clientDataJSON),\n    authenticatorData: base64FromBuffer(assertion.response.authenticatorData),\n    signature: base64FromBuffer(assertion.response.signature),\n    userHandle: assertion.response.userHandle\n      ? base64FromBuffer(assertion.response.userHandle)\n      : false\n  };\n\n  // Parse authenticator data structure\n  const authData = getAuthDataFromAuthentication(assertion.response.authenticatorData);\n\n  return {\n    id,\n    rawId,\n    type,\n    authData,\n    response\n  };\n}\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Parses WebAuthn authenticator data according to the FIDO2 specification.\n * \n * The authenticator data structure contains:\n * - RP ID Hash (32 bytes): SHA-256 hash of the relying party identifier\n * - Flags (1 byte): Bit flags indicating various states\n * - Counter (4 bytes): Signature counter value (big-endian)\n * - Optional attested credential data (variable length)\n * - Optional extensions data (variable length)\n *\n * @param {ArrayBuffer} authData - Raw authenticator data from WebAuthn response\n * @returns {Object} Parsed authenticator data components\n * @throws {Error} If authenticator data is too short or contains invalid data\n */\nfunction getAuthDataFromAuthentication(authData) {\n  // Validate minimum length for RP ID hash, flags, and counter\n  if (!authData || authData.byteLength < 37) {\n    throw new Error(\n      `Authenticator data was ${authData?.byteLength || \"invalid\"} bytes, expected at least 37 bytes`\n    );\n  }\n\n  const dataView = new DataView(authData, authData.byteOffset, authData.length);\n  let pointer = 0;\n\n  // Extract RP ID hash (32 bytes)\n  const rpIdHash = authData.slice(pointer, pointer + 32);\n  pointer += 32;\n\n  // Extract and parse flags byte\n  const flagsBuf = authData.slice(pointer, pointer + 1);\n  const flagsInt = new Uint8Array(flagsBuf)[0];\n  pointer += 1;\n\n  const flags = {\n    up: !!(flagsInt & 0x01), // User Present (bit 0)\n    uv: !!(flagsInt & 0x04), // User Verified (bit 2)\n    be: !!(flagsInt & 0x08), // Backup Eligible (bit 3)\n    bs: !!(flagsInt & 0x10), // Backup State (bit 4)\n    at: !!(flagsInt & 0x40), // Attested Credential Data Present (bit 6)\n    ed: !!(flagsInt & 0x80), // Extension Data Present (bit 7)\n    flagsInt\n  };\n\n  // Extract signature counter (4 bytes, big-endian)\n  const counterBuf = authData.slice(pointer, pointer + 4);\n  const counter = dataView.getUint32(pointer, false); // false = big-endian\n  pointer += 4;\n\n  // Parse optional attested credential data\n  const attestationResult = parseAttestedCredentialData(flags, authData, pointer);\n  pointer = attestationResult.newPointer;\n\n  // Parse optional extension data\n  const extensionsData = parseExtensionData(flags, authData, pointer);\n\n  return {\n    rpIdHash: base64FromBuffer(rpIdHash),\n    flagsBuf: base64FromBuffer(flagsBuf),\n    flags,\n    counter,\n    counterBuf: base64FromBuffer(counterBuf),\n    aaguid: attestationResult.aaguid,\n    credentialId: base64FromBuffer(attestationResult.credentialId),\n    credentialPublicKey: base64FromBuffer(attestationResult.credentialPublicKey),\n    extensionsData\n  };\n}\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Parses attested credential data from authenticator data when the AT flag is set.\n * \n * Attested credential data structure:\n * - AAGUID (16 bytes): Authenticator attestation GUID\n * - Credential ID Length (2 bytes): Length of credential ID (big-endian)\n * - Credential ID (variable): The credential identifier\n * - Credential Public Key (variable): COSE-encoded public key\n *\n * @param {Object} flags - Parsed flags from authenticator data\n * @param {ArrayBuffer} authData - Complete authenticator data buffer\n * @param {number} pointer - Current parsing position in the buffer\n * @returns {Object} Parsed credential data and updated pointer position\n */\nfunction parseAttestedCredentialData(flags, authData, pointer) {\n  // Return undefined values if attested credential data is not present\n  if (!flags.at) {\n    return {\n      aaguid: undefined,\n      credentialId: undefined,\n      credentialPublicKey: undefined,\n      newPointer: pointer\n    };\n  }\n\n  const dataView = new DataView(authData, authData.byteOffset, authData.length);\n\n  // Extract AAGUID (16 bytes)\n  const aaguid = authData.slice(pointer, pointer + 16);\n  pointer += 16;\n\n  // Extract credential ID length (2 bytes, big-endian)\n  const credentialIdLength = dataView.getUint16(pointer, false);\n  pointer += 2;\n\n  // Extract credential ID\n  const credentialId = authData.slice(pointer, pointer + credentialIdLength);\n  pointer += credentialIdLength;\n\n  // Extract credential public key (remaining data up to extensions)\n  // Note: In practice, public key length varies, but for this implementation\n  // we assume a fixed 77 bytes as per original code\n  const credentialPublicKey = authData.slice(pointer, pointer + 77);\n  pointer += 77;\n\n  return {\n    aaguid,\n    credentialId,\n    credentialPublicKey,\n    newPointer: pointer\n  };\n}\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Parses extension data from authenticator data when the ED flag is set.\n * \n * Extension data is CBOR-encoded and contains additional authenticator\n * information. The data extends from the current pointer to the end of\n * the authenticator data buffer.\n *\n * @param {Object} flags - Parsed flags from authenticator data\n * @param {ArrayBuffer} authData - Complete authenticator data buffer\n * @param {number} pointer - Current parsing position in the buffer\n * @returns {ArrayBuffer|undefined} Extension data buffer or undefined if not present\n */\nfunction parseExtensionData(flags, authData, pointer) {\n  // Return undefined if extension data is not present\n  if (!flags.ed) {\n    return undefined;\n  }\n\n  // Extension data spans from current pointer to end of authenticator data\n  return authData.slice(pointer);\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default getAuthenticationAuthData;\n\n// ------------------------------------------------------------------------------------------------","/**\n * @file Módulo para processar e extrair dados de uma credencial de registro WebAuthn.\n */\n\nimport { decode } from \"cbor-x\";\nimport base64FromBuffer from \"../../utils/base64FromBuffer\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Analisa o buffer de dados do autenticador (authData) para extrair o ID da credencial e a chave pública.\n * A estrutura do buffer `authData` é rigorosamente definida pela especificação WebAuthn.\n * Esta função decodifica essa estrutura de bytes.\n * @see https://www.w3.org/TR/webauthn-2/#sctn-authenticator-data\n *\n * @private\n * @param {ArrayBuffer} attestationObjectBuffer - O buffer do objeto de atestado, que contém os dados do autenticador.\n * @returns {{credentialId: string, publicKeyObject: string}} Um objeto contendo o ID da credencial e a chave pública, ambos codificados em Base64.\n */\nfunction parseAuthenticatorData(attestationObjectBuffer) {\n  // 1. Decodifica o objeto de atestado do formato CBOR para acessar seus campos internos.\n  const attestationObject = decode(new Uint8Array(attestationObjectBuffer));\n  const { authData } = attestationObject;\n\n  // 2. Define constantes para os offsets e comprimentos dos campos na estrutura `authData`,\n  // conforme a especificação. Isso substitui \"números mágicos\" por valores claros e documentados.\n  const RP_ID_HASH_OFFSET = 0;\n  const RP_ID_HASH_LENGTH = 32;\n  const FLAGS_OFFSET = RP_ID_HASH_OFFSET + RP_ID_HASH_LENGTH; // 32\n  const FLAGS_LENGTH = 1;\n  const SIGN_COUNT_OFFSET = FLAGS_OFFSET + FLAGS_LENGTH; // 33\n  const SIGN_COUNT_LENGTH = 4;\n\n  // O `attestedCredentialData` é opcional e sua presença é indicada pelo bit 'AT' nas flags.\n  // Seu início é após os campos de cabeçalho.\n  const ATTESTED_CREDENTIAL_DATA_OFFSET = SIGN_COUNT_OFFSET + SIGN_COUNT_LENGTH; // 37\n  const AAGUID_LENGTH = 16;\n  const CREDENTIAL_ID_LENGTH_BYTES = 2;\n\n  const CREDENTIAL_ID_LENGTH_OFFSET =\n    ATTESTED_CREDENTIAL_DATA_OFFSET + AAGUID_LENGTH; // 53\n  const CREDENTIAL_ID_OFFSET =\n    CREDENTIAL_ID_LENGTH_OFFSET + CREDENTIAL_ID_LENGTH_BYTES; // 55\n\n  // 3. Extrai o comprimento do ID da credencial. Este é um inteiro de 2 bytes (Big Endian).\n  // Usamos um DataView para garantir a interpretação correta dos bytes.\n  const idLenBytes = authData.slice(\n    CREDENTIAL_ID_LENGTH_OFFSET,\n    CREDENTIAL_ID_OFFSET\n  );\n  const dataView = new DataView(idLenBytes.buffer);\n  const credentialIdLength = dataView.getUint16(0);\n\n  // 4. Extrai o ID da credencial e a chave pública usando os comprimentos e offsets calculados.\n  const credentialId = authData.slice(\n    CREDENTIAL_ID_OFFSET,\n    CREDENTIAL_ID_OFFSET + credentialIdLength\n  );\n  const publicKeyBytes = authData.slice(\n    CREDENTIAL_ID_OFFSET + credentialIdLength\n  );\n\n  // 5. Retorna os dados extraídos, codificados em Base64 para facilitar o transporte e armazenamento.\n  return {\n    credentialId: base64FromBuffer(credentialId.buffer),\n    publicKeyObject: base64FromBuffer(publicKeyBytes.buffer),\n  };\n}\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Extrai e formata os dados de autenticação de registro de uma credencial WebAuthn (`PublicKeyCredential`).\n * A função processa os vários `ArrayBuffer`s da credencial, convertendo-os para formatos úteis (como Base64)\n * e decodificando a estrutura de dados interna do autenticador.\n *\n * @param {PublicKeyCredential} credential - O objeto de credencial WebAuthn retornado pelo navegador após um registro bem-sucedido.\n * @returns {object} Um objeto estruturado contendo os dados de registro prontos para serem enviados a um servidor.\n * @throws {Error} Lança um erro se ocorrer um problema durante o processamento da credencial (ex: formato inválido).\n */\nfunction getRegistrationAuthData(credential) {\n  const response = credential.response;\n\n  // Analisa a estrutura de bytes do `attestationObject` para extrair dados internos.\n  const parsedAuthData = parseAuthenticatorData(response.attestationObject);\n\n  // Decodifica o `clientDataJSON` de ArrayBuffer para uma string UTF-8 legível.\n  const clientDataJSONDecoded = new TextDecoder().decode(\n    response.clientDataJSON\n  );\n\n  // Constrói o objeto de retorno final com todos os dados relevantes convertidos para Base64.\n  // Isso prepara os dados para serem serializados (ex: como JSON) e enviados para o servidor.\n  return {\n    // Dados de nível superior da credencial\n    rawId: base64FromBuffer(credential.rawId),\n    id: credential.id,\n    type: credential.type,\n    authenticatorAttachment: credential.authenticatorAttachment,\n    clientExtensionResults: credential.getClientExtensionResults(),\n\n    // Dados extraídos e analisados do `authData`\n    authData: parsedAuthData,\n\n    // Dados da resposta do autenticador, convertidos para formatos apropriados\n    response: {\n      attestationObject: base64FromBuffer(response.attestationObject),\n      authenticatorData: base64FromBuffer(response.getAuthenticatorData()),\n      clientDataJSON: base64FromBuffer(response.clientDataJSON),\n      clientDataJSONDecoded,\n      transports: response.getTransports() || [],\n      publicKey: base64FromBuffer(response.getPublicKey()),\n      publicKeyAlgorithm: response.getPublicKeyAlgorithm(),\n    },\n  };\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default getRegistrationAuthData;\n\n// ------------------------------------------------------------------------------------------------\n","/**\n * @file Módulo para iniciar o processo de autenticação WebAuthn no navegador.\n */\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Valida se o objeto de propriedades fornecido contém todos os campos necessários\n * para uma chamada `navigator.credentials.get()`. Lança um erro se a validação falhar.\n *\n * @private\n * @param {PublicKeyCredentialRequestOptions} props - O objeto de opções a ser validado.\n * @throws {Error} Lança um erro descritivo se um campo obrigatório estiver ausente ou for inválido.\n */\nfunction validateAuthenticationOptions(props) {\n  // Valida a presença do 'challenge', que é essencial para prevenir ataques de repetição.\n  if (!props.challenge) {\n    throw new Error(\"No challenge provided\");\n  }\n\n  // Valida a lista de credenciais permitidas. O autenticador usará esta lista\n  // para encontrar uma credencial correspondente que o usuário possa usar para assinar.\n  if (\n    !props.allowCredentials ||\n    !Array.isArray(props.allowCredentials) ||\n    props.allowCredentials.length === 0\n  ) {\n    throw new Error(\"No allowCredentials provided\");\n  }\n\n  // Itera sobre cada credencial permitida para garantir que sua estrutura está correta.\n  for (const cred of props.allowCredentials) {\n    if (!cred.id) {\n      throw new Error(\n        \"No allowCredentials (id) provided - The credential ID registered on the registration phase\"\n      );\n    }\n    if (!cred.type) {\n      throw new Error(\"No allowCredentials (type) provided\");\n    }\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Inicia o processo de autenticação WebAuthn no navegador e retorna uma asserção de autenticação.\n * Esta função é um wrapper para `navigator.credentials.get()`, adicionando validações\n * e suporte a um callback opcional para retrocompatibilidade.\n *\n * @param {PublicKeyCredentialRequestOptions} props - O objeto contendo as opções para solicitar uma asserção de autenticação.\n * @param {Function} [callback] - Função de callback opcional que será chamada com a asserção obtida como argumento.\n * @returns {Promise<PublicKeyCredential|string>} Uma promessa que resolve para o objeto `PublicKeyCredential` (a asserção),\n * ou para a string \"WebAuthn not supported\" se a API não estiver disponível.\n * @throws {Error} Lança um erro se ocorrer um problema durante o processo de autenticação (ex: validação falha, usuário cancela).\n */\nasync function getWebAuthnAuthenticationAssertion(props, callback) {\n  // 1. Verificação de Suporte da API\n  // Garante que a API WebAuthn para obter credenciais está disponível no navegador.\n  if (typeof navigator?.credentials?.get !== \"function\") {\n    return \"WebAuthn not supported\";\n  }\n\n  // 2. Validação dos Parâmetros\n  // Executa uma verificação rigorosa das opções para garantir que a chamada à API será bem-sucedida.\n  validateAuthenticationOptions(props);\n\n  // 3. Obtenção da Asserção\n  // Invoca a API nativa do navegador para solicitar uma asserção de autenticação.\n  // O `await` pausa a execução até que o usuário prove sua identidade ao autenticador.\n  const assertion = await navigator.credentials.get({\n    publicKey: props,\n  });\n\n  // 4. Execução do Callback (Opcional)\n  // Se um callback válido for fornecido, ele é invocado com a asserção.\n  if (typeof callback === \"function\") {\n    return callback(assertion);\n  }\n\n  // 5. Retorno da Promessa\n  // Se nenhum callback for usado, a função retorna a asserção, resolvendo a promessa.\n  return assertion;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default getWebAuthnAuthenticationAssertion;\n\n// ------------------------------------------------------------------------------------------------\n","/**\n * @file Módulo para iniciar o processo de registro WebAuthn no navegador.\n */\n\n// ------------------------------------------------------------------------------------------------\n/**\n * Valida se o objeto de propriedades fornecido contém todos os campos necessários\n * para uma chamada `navigator.credentials.create()`. Lança um erro se a validação falhar.\n *\n * @private\n * @param {PublicKeyCredentialCreationOptions} props - O objeto de opções a ser validado.\n * @throws {Error} Lança um erro descritivo se um campo obrigatório estiver ausente ou for inválido.\n */\nfunction validateCreationOptions(props) {\n  // Valida a presença do 'challenge', que é essencial para a segurança do protocolo.\n  if (!props.challenge) {\n    throw new Error(\"No challenge provided\");\n  }\n\n  // Valida as informações da Relying Party (RP).\n  if (!props.rp) {\n    throw new Error(\"No RP (Relying Party) provided\");\n  }\n  if (!props.rp.name) {\n    throw new Error(\"No RP (Relying Party) name provided\");\n  }\n\n  // Valida as informações do usuário.\n  if (!props.user) {\n    throw new Error(\"No user provided\");\n  }\n  if (!props.user.id) {\n    throw new Error(\"No user id provided\");\n  }\n  if (!props.user.displayName) {\n    throw new Error(\"No user display name provided\");\n  }\n  if (!props.user.name) {\n    throw new Error(\"No user name provided\");\n  }\n\n  // Valida os parâmetros dos tipos de credenciais de chave pública aceitos.\n  // Deve ser um array não vazio.\n  if (\n    !props.pubKeyCredParams ||\n    !Array.isArray(props.pubKeyCredParams) ||\n    props.pubKeyCredParams.length === 0\n  ) {\n    throw new Error(\"No pubKeyCredParams provided\");\n  }\n\n  // Itera sobre cada parâmetro para garantir que a estrutura está correta.\n  for (const param of props.pubKeyCredParams) {\n    if (!param.hasOwnProperty(\"alg\")) {\n      throw new Error(\"No pubKeyCredParams.alg provided\");\n    }\n    if (!param.hasOwnProperty(\"type\")) {\n      throw new Error(\"No pubKeyCredParams.type provided\");\n    }\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n/**\n * Inicia o processo de registro WebAuthn no navegador e retorna uma nova credencial.\n * Esta função é um wrapper para `navigator.credentials.create()`, adicionando validações\n * e suporte a um callback opcional.\n *\n * @param {PublicKeyCredentialCreationOptions} [props={}] - O objeto contendo as opções para a criação de uma nova credencial de chave pública.\n * @param {Function} [callback] - Função de callback opcional que será chamada com a credencial criada como argumento.\n * @returns {Promise<PublicKeyCredential|string>} Uma promessa que resolve para o objeto `PublicKeyCredential` criado,\n * ou para a string \"WebAuthn not supported\" se a API não estiver disponível no navegador.\n * @throws {Error} Lança um erro se ocorrer um problema durante o processo de criação da credencial (ex: validação falha, cancelamento do usuário).\n */\nasync function getWebAuthnRegistrationCredential(props = {}, callback) {\n  // 1. Verificação de Suporte da API\n  // Garante que a API WebAuthn está disponível no objeto `navigator` antes de prosseguir.\n  // Esta função destina-se apenas a ambientes de navegador.\n  if (typeof navigator?.credentials?.create !== \"function\") {\n    return \"WebAuthn not supported\";\n  }\n\n  // 2. Validação dos Parâmetros\n  // Executa uma verificação rigorosa das opções fornecidas para garantir que a chamada à API\n  // seja bem-sucedida e evitar erros inesperados.\n  validateCreationOptions(props);\n\n  // 3. Criação da Credencial\n  // Invoca a API nativa do navegador para solicitar a criação de uma nova credencial.\n  // O `await` pausa a execução até que o usuário interaja com o prompt (ex: usando biometria)\n  // e a promessa seja resolvida ou rejeitada.\n  const credential = await navigator.credentials.create({\n    publicKey: props,\n  });\n\n  // 4. Execução do Callback (Opcional)\n  // Se um callback foi fornecido e é uma função válida, ele é invocado com a credencial.\n  // Este padrão é mantido para garantir a retrocompatibilidade com a assinatura original.\n  if (typeof callback === \"function\") {\n    return callback(credential);\n  }\n\n  // 5. Retorno da Promessa\n  // Se nenhum callback for usado, a função retorna a credencial, resolvendo a promessa.\n  return credential;\n}\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Exporta a função para uso em módulos CommonJS.\n */\nexport default getWebAuthnRegistrationCredential;\n\n// ------------------------------------------------------------------------------------------------\n","/**\n * @file Módulo para validação de RPID (Relying Party ID) usando dependências específicas.\n */\n\n// Importa as utilidades necessárias de outros módulos.\n// A responsabilidade pela implementação de baixo nível é delegada a essas funções.\nimport base64ToBuffer from \"../../utils/base64ToBuffer\";\nimport bufferCompare from \"../../utils/bufferCompare\";\nimport bufferFromString from \"../../utils/bufferFromString\";\nimport getCrypto from \"../../crypto/getCrypto.js\";\n\n// ------------------------------------------------------------------------------------------------\n/**\n * Valida de forma assíncrona que o RPID original corresponde ao RPID de verificação após a aplicação de um hash.\n * Esta função orquestra chamadas a utilitários criptográficos e de buffer para realizar a validação.\n *\n * @param {string} originalRPID - O identificador RPID original (string UTF-8) a ser validado.\n * @param {string} verifyRPID - A representação em Base64 do RPID a ser verificado. Espera-se que contenha o hash do RPID original.\n * @param {string} [algorithm=\"SHA-256\"] - O algoritmo de hash a ser usado. Deve ser compatível com a implementação de `getCrypto`.\n * @returns {Promise<boolean>} Retorna uma promessa que resolve para `true` se os RPIDs corresponderem.\n * @throws {Error} Lança um erro se `originalRPID` ou `verifyRPID` não forem fornecidos, ou se os RPIDs não corresponderem.\n */\nasync function validateRPID(originalRPID, verifyRPID, algorithm = \"SHA-256\") {\n  // 1. Validação dos Parâmetros de Entrada\n  // Garante que os argumentos essenciais foram fornecidos antes de qualquer processamento.\n  if (!originalRPID || typeof originalRPID !== \"string\") {\n    throw new Error(\"originalRPID is required\");\n  }\n  originalRPID = originalRPID.trim();\n  if (!originalRPID) {\n    throw new Error(\"originalRPID is required\");\n  }\n\n  if (!verifyRPID || typeof verifyRPID !== \"string\") {\n    throw new Error(\"verifyRPID is required\");\n  }\n\n  verifyRPID = verifyRPID.trim();\n  if (!verifyRPID) {\n    throw new Error(\"verifyRPID is required\");\n  }\n\n  // 2. Preparação para o Hashing\n  // Obtém a interface de criptografia do ambiente (Node.js ou navegador) através do utilitário.\n  const crypto = getCrypto();\n  // Converte a string do RPID original em um formato de buffer, que é o tipo de entrada\n  // esperado pela API de criptografia para a operação de digest.\n  const originalRPIDBuffer = bufferFromString(originalRPID);\n\n  // 3. Geração do Hash\n  // Calcula o hash do buffer do RPID original usando o algoritmo especificado.\n  // A operação `digest` é assíncrona e retorna o hash resultante (geralmente como um ArrayBuffer).\n  const digestOfOriginalRPID = await crypto.subtle.digest(\n    algorithm,\n    originalRPIDBuffer\n  );\n\n  // 4. Decodificação e Extração do Hash de Verificação\n  // Decodifica a string base64 `verifyRPID` para seu formato de buffer correspondente.\n  const verifyRPIDBuffer = base64ToBuffer(verifyRPID);\n  // Extrai os primeiros 32 bytes do buffer decodificado. Este segmento é assumido\n  // como sendo o hash a ser comparado (consistente com o tamanho de um hash SHA-256).\n  const digestToVerify = verifyRPIDBuffer.slice(0, 32);\n\n  // 5. Comparação Segura\n  // Compara o hash recém-gerado com o hash extraído do parâmetro de verificação.\n  // É crucial que `bufferCompare` implemente uma comparação segura contra ataques de temporização.\n  const areDigestsEqual = bufferCompare(digestOfOriginalRPID, digestToVerify);\n\n  if (!areDigestsEqual) {\n    // Se a comparação falhar, lança um erro específico para indicar a incompatibilidade.\n    throw new Error(\n      `Registration RPID does not match the authentication RPID.`\n    );\n  }\n\n  // Se a comparação for bem-sucedida, a validação está completa.\n  return true;\n}\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Exporta a função `validateRPID` para uso em módulos CommonJS (padrão do Node.js).\n */\nexport default validateRPID;\n\n// ------------------------------------------------------------------------------------------------\n","/**\n * @file Módulo otimizado para validação de asserção de autenticação WebAuthn.\n */\n\nimport verifySignature from \"../../crypto/verifySignature\";\nimport importCryptoKey from \"../../crypto/importCryptoKey\";\nimport validateRPID from \"./validateRPID\";\nimport isNumber from \"../../helpers/isNumber\";\nimport base64ToBuffer from \"../../utils/base64ToBuffer\";\nimport base64From from \"../../utils/base64From\";\nimport bufferConcatenate from \"../../utils/bufferConcatenate\";\nimport convertECDSAASN1Signature from \"./convertECDSAASN1Signature\";\n\n// ------------------------------------------------------------------------------------------------\n/**\n * Recupera os parâmetros do algoritmo para importar uma chave pública com base no identificador do algoritmo.\n * @private\n */\nfunction getImportPublicKeyAlgorithm(publicKeyAlgorithm) {\n  switch (publicKeyAlgorithm) {\n    case -7: // ES256\n      return { name: \"ECDSA\", namedCurve: \"P-256\" };\n    case -257: // RS256\n      return { name: \"RSASSA-PKCS1-v1_5\", hash: { name: \"SHA-256\" } };\n    case -8: // Ed25519\n      throw new Error(\"Ed25519 is not supported by crypto.subtle directly\");\n    default:\n      throw new Error(`Unsupported algorithm: ${publicKeyAlgorithm}`);\n  }\n}\n\n/**\n * Recupera os parâmetros do algoritmo para verificar uma assinatura com base no identificador do algoritmo.\n * @private\n */\nfunction getAlgorithmVerifySignatureParam(publicKeyAlgorithm) {\n  switch (publicKeyAlgorithm) {\n    case -7: // ES256\n      return { name: \"ECDSA\", hash: { name: \"SHA-256\" } };\n    case -257: // RS256\n      return { name: \"RSASSA-PKCS1-v1_5\", hash: { name: \"SHA-256\" } };\n    case -8: // Ed25519\n      throw new Error(\n        \"Ed25519 is not supported by crypto.subtle. Use an external library.\"\n      );\n    default:\n      throw new Error(`Unsupported algorithm: ${publicKeyAlgorithm}`);\n  }\n}\n\n/**\n * Gera um hash combinado a partir dos dados do autenticador e do clientDataJSON da asserção.\n * Este é o payload que foi originalmente assinado pelo autenticador.\n * @private\n */\nasync function generateDataToVerify(assertion) {\n  const authenticatorDataBuffer = base64ToBuffer(\n    assertion.response.authenticatorData\n  );\n  const clientDataJSONBuffer = base64ToBuffer(assertion.response.clientDataJSON);\n  const clientDataJSONHash = await crypto.subtle.digest(\n    \"SHA-256\",\n    clientDataJSONBuffer\n  );\n\n  return bufferConcatenate(authenticatorDataBuffer, clientDataJSONHash);\n}\n\n// ------------------------------------------------------------------------------------------------\n/**\n * Valida de forma assíncrona uma asserção de autenticação WebAuthn em um fluxo otimizado.\n *\n * @param {object} credential - O objeto da credencial armazenado, contendo a chave pública.\n * @param {object} assertion - A asserção de autenticação recebida do cliente.\n * @param {object} [expectedProps={}] - Propriedades esperadas para validação (challenge, origin, etc.).\n * @param {object} [incomingProps={}] - Propriedades recebidas na requisição (contador da asserção).\n * @param {object} [publicKeyProps={}] - Opções para a importação da chave pública.\n * @param {boolean} [convertECDSignature=true] - Se deve converter a assinatura ECDSA do formato bruto para ASN.1.\n * @returns {Promise<boolean>} Retorna `true` se a validação for bem-sucedida.\n * @throws {Error} Lança um erro detalhado na primeira falha de validação.\n */\nasync function validateAuthentication(\n  credential,\n  assertion,\n  expectedProps = {},\n  incomingProps = {},\n  publicKeyProps = {},\n  convertECDSignature = true\n) {\n  // ## 1. Validação Estrutural dos Objetos\n  if (!credential) {\n    throw new Error(\"Missing credential\");\n  }\n  if (!credential.id) {\n    throw new Error(\"Missing credential ID\");\n  }\n  if (!credential.rawId) {\n    throw new Error(\"Missing credential rawId\");\n  }\n  if (credential.type !== \"public-key\") {\n    throw new Error(\"Credential type must be 'public-key'\");\n  }\n\n  if (!assertion) {\n    throw new Error(\"Missing assertion\");\n  }\n  if (!assertion.id) {\n    throw new Error(\"Missing assertion ID\");\n  }\n  if (!assertion.rawId) {\n    throw new Error(\"Missing assertion rawId\");\n  }\n  if (assertion.type !== \"public-key\") {\n    throw new Error(\"Assertion type must be 'public-key'\");\n  }\n\n  // ## 2. Validação de Consistência entre Credencial e Asserção\n  if (credential.id !== assertion.id) {\n    throw new Error(\"Credential ID does not match assertion ID\");\n  }\n  if (credential.rawId !== assertion.rawId) {\n    throw new Error(\"Credential rawId does not match assertion rawId\");\n  }\n\n  // ## 3. Validação do Contador de Assinatura (Prevenção de Replay/Clonagem)\n  const { counterCredential } = expectedProps;\n  const { counterAssertion } = incomingProps;\n  if (!isNumber(counterCredential) || counterCredential < 0) {\n    throw new Error(\"counterCredential must be a number >= 0\");\n  }\n  if (!isNumber(counterAssertion) || counterAssertion < 0) {\n    throw new Error(\"counterAssertion must be a number >= 0\");\n  }\n  // A especificação WebAuthn exige que o contador da nova asserção seja maior que o contador armazenado.\n  // Isso previne ataques de repetição e detecta clonagem de autenticadores.\n  // Uma exceção é quando um autenticador não suporta contadores e sempre retorna 0.\n  // A lógica abaixo acomoda este cenário: a verificação só é imposta se o novo contador for diferente de zero.\n  if (counterAssertion !== 0) {\n    if (counterAssertion <= counterCredential) {\n      throw new Error(\n        `Invalid signature counter. The assertion counter (${counterAssertion}) must be strictly greater than the stored credential counter (${counterCredential}).`\n      );\n    }\n  }\n\n  // ## 4. Validação dos Parâmetros da Requisição (Client Data)\n  const clientDataJSON = JSON.parse(assertion.response.clientDataJSONDecoded);\n  const assertionChallenge = base64From(clientDataJSON?.challenge || \"\");\n  if (expectedProps.challenge !== assertionChallenge) {\n    throw new Error(\"Challenge provided does not match assertion challenge.\");\n  }\n  if (expectedProps.origin !== clientDataJSON?.origin) {\n    throw new Error(\n      `Origin does not match. Expected: ${expectedProps.origin} Actual: ${\n        clientDataJSON?.origin ?? \"none\"\n      }`\n    );\n  }\n  if (expectedProps.type !== clientDataJSON?.type) {\n    throw new Error(\n      `Type does not match. Expected: ${expectedProps.type} Actual: ${\n        clientDataJSON?.type ?? \"none\"\n      }`\n    );\n  }\n\n  // ## 5. Validação das Flags do Autenticador\n  if (!assertion.authData.flags.up) {\n    throw new Error(\"User Present flag (up) is required for authentication.\");\n  }\n  if (!assertion.authData.flags.uv) {\n    throw new Error(\"User Verified flag (uv) is required for authentication.\");\n  }\n\n  // ## 6. Validação do RP ID\n  await validateRPID(expectedProps.rpID, assertion.authData.rpIdHash);\n\n  // ## 7. Verificação da Assinatura Criptográfica\n  const importAlgo = getImportPublicKeyAlgorithm(\n    credential.response.publicKeyAlgorithm\n  );\n  const verifyAlgo = getAlgorithmVerifySignatureParam(\n    credential.response.publicKeyAlgorithm\n  );\n\n  const publicKey = await importCryptoKey(\n    publicKeyProps?.importKey?.format || \"spki\",\n    base64ToBuffer(credential.response.publicKey),\n    importAlgo,\n    publicKeyProps?.importKey?.extractable || false,\n    [\"verify\"]\n  );\n\n  let signature = new Uint8Array(base64ToBuffer(assertion.response.signature));\n  // Assinaturas ECDSA de autenticadores vêm em formato bruto (r||s), mas a Web Crypto API espera ASN.1.\n  if (convertECDSignature && credential.response.publicKeyAlgorithm === -7) {\n    signature = convertECDSAASN1Signature(signature);\n  }\n\n  const dataToVerify = await generateDataToVerify(assertion);\n\n  return verifySignature(verifyAlgo, publicKey, signature, dataToVerify);\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default validateAuthentication;\n\n// ------------------------------------------------------------------------------------------------\n","/**\n * @file Módulo otimizado para validação de credencial de registro WebAuthn.\n */\n\nimport base64ToBuffer from \"../../utils/base64ToBuffer\";\nimport { decode } from \"cbor-x\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Valida uma credencial de registro WebAuthn de forma eficiente.\n *\n * Esta função executa uma série de validações em um fluxo único e otimizado:\n * 1. Valida a estrutura e as propriedades essenciais da credencial.\n * 2. Valida os parâmetros da requisição (challenge, origin, type) contra os valores esperados.\n * 3. Decodifica e valida o formato e a declaração do objeto de atestado.\n *\n * @param {object} credential - A credencial WebAuthn a ser validada.\n * @param {object} [expectedProps={}] - Um objeto contendo as propriedades esperadas para a validação.\n * @param {string} [expectedProps.challenge] - O challenge esperado, conforme enviado ao cliente.\n * @param {string} [expectedProps.origin] - A origem (domínio) esperada da requisição.\n * @param {string} [expectedProps.type] - O tipo de operação esperado (ex: 'webauthn.create').\n * @returns {true} Retorna `true` se a credencial for válida em todos os aspectos.\n * @throws {Error} Lança um erro descritivo no primeiro ponto em que a validação falhar.\n */\nfunction validateRegistration(credential, expectedProps = {}) {\n  // ## 1. Validação Estrutural da Credencial\n  // Garante que o objeto da credencial e suas propriedades fundamentais existem e são do tipo correto.\n  if (!credential) {\n    throw new Error(\"Missing credential\");\n  }\n  if (!credential.id) {\n    throw new Error(\"Missing credential ID\");\n  }\n  if (!credential.rawId) {\n    throw new Error(\"Missing credential rawId\");\n  }\n  if (!credential.type || credential.type !== \"public-key\") {\n    throw new Error(\n      \"Missing credential type or credential type is not public-key\"\n    );\n  }\n\n  // ## 2. Validação dos Parâmetros da Requisição (Client Data)\n  // Compara os dados da requisição (challenge, origin, type) com os valores esperados.\n  const clientDataJSON = JSON.parse(credential.response.clientDataJSONDecoded);\n\n  if (expectedProps.challenge !== clientDataJSON?.challenge) {\n    throw new Error(\n      `Challenge does not match. Provided challenge: ${\n        clientDataJSON?.challenge ?? \"none\"\n      }.`\n    );\n  }\n\n  if (expectedProps.origin !== clientDataJSON?.origin) {\n    throw new Error(\n      `Origin does not match. Expected: ${expectedProps.origin} Actual: ${\n        clientDataJSON?.origin ?? \"none\"\n      }`\n    );\n  }\n\n  if (expectedProps.type !== clientDataJSON?.type) {\n    throw new Error(\n      `Type does not match. Expected: ${expectedProps.type} Actual: ${\n        clientDataJSON?.type ?? \"none\"\n      }`\n    );\n  }\n\n  // ## 3. Validação do Objeto de Atestado (Attestation Object)\n  // Decodifica e valida o formato e a declaração de atestado.\n  const attestationObjectBuffer = base64ToBuffer(\n    credential.response.attestationObject\n  );\n  // A biblioteca `cbor.decode` é altamente otimizada para essa operação.\n  const attestationObject = decode(new Uint8Array(attestationObjectBuffer));\n\n  if (!attestationObject.fmt) {\n    throw new Error(\"Missing attestation object format\");\n  }\n\n  // Para o formato 'none', a declaração de atestado (attStmt) deve estar vazia.\n  // A biblioteca cbor-x decodifica mapas CBOR em objetos Map do JS, que possuem a propriedade `.size`.\n  if (attestationObject.fmt === \"none\") {\n    if (attestationObject.attStmt && attestationObject.attStmt.size > 0) {\n      throw new Error(\"None attestation had unexpected attestation statement\");\n    }\n  } else {\n    // Atualmente, apenas o formato 'none' é suportado por esta validação.\n    throw new Error(`Unsupported Attestation Format: ${attestationObject.fmt}`);\n  }\n\n  // Se todas as validações passarem, a função retorna `true`.\n  return true;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default validateRegistration;\n\n// ------------------------------------------------------------------------------------------------\n","import setConditionBetweenDates from \"./setConditionsBetweenDates.js\";\nimport setConditionBetweenValues from \"./setConditionsBetweenValues.js\";\nimport setConditionStringLike from \"./setConditionStringLike.js\";\n\n// Named exports para importação individual\nexport {\n  setConditionBetweenDates,\n  setConditionBetweenValues,\n  setConditionStringLike\n};\n\n// Default export para compatibilidade\nexport default {\n  setConditionBetweenDates,\n  setConditionBetweenValues,\n  setConditionStringLike,\n};","/**\n * @fileoverview Utilitário para formatar condições de busca por intervalo de datas\n * em objetos de consulta, com dependências de conversão e ajuste de data/hora.\n */\n\n// --- Dependências do Módulo ---\nimport { DATE_BR_FORMAT_D } from \"../../../constants.js\";\nimport stringToDate from \"../../../utils/stringToDate.js\";\nimport dateFirstHourOfDay from \"../../../utils/dateFirstHourOfDay.js\";\nimport dateLastHourOfDay from \"../../../utils/dateLastHourOfDay.js\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Cria uma condição de busca por intervalo de datas (BETWEEN) em um objeto.\n *\n * @summary Formata um intervalo de datas para uma condição de ORM.\n * @description Esta função modifica um objeto de consulta, convertendo strings de data em\n * objetos `Date` e criando uma cláusula `$and` com condições `$gte` (maior ou igual a)\n * e/ou `$lte` (menor ou igual a).\n *\n * **Efeitos Colaterais:**\n * 1.  Adiciona uma nova chave (`key`) ao objeto com a condição de intervalo.\n * 2.  **Remove** as chaves originais de data (`afterKey`, `beforeKey`) do objeto.\n *\n * @param {object} object - O objeto de consulta que será **modificado**.\n * @param {string} [fromFormat=DATE_BR_FORMAT_D] - O formato em que as strings de data de entrada estão.\n * @param {string} [key=\"created_at\"] - A chave principal no objeto onde a condição `$and` será criada.\n * @param {string} [beforeKey=\"created_at_until\"] - A chave que contém a data final do intervalo (`<=`).\n * @param {string} [afterKey=\"created_at_from\"] - A chave que contém a data inicial do intervalo (`>=`).\n * @param {boolean} [resetHMS=true] - Se `true`, ajusta a data inicial para o primeiro momento do dia (00:00:00) e a data final para o último (23:59:59).\n * @returns {object|null} Retorna o objeto modificado se alguma condição for aplicada, ou `null` se nenhuma for.\n *\n * @example\n * // Filtro de entrada\n * const filter = { created_at_from: '01-08-2025', created_at_until: '18-08-2025' };\n *\n * setConditionBetweenDates(filter);\n *\n * // O objeto 'filter' é modificado para:\n * // {\n * //   created_at: {\n * //     $and: [\n * //       { $gte: new Date('2025-08-01T00:00:00.000') },\n * //       { $lte: new Date('2025-08-18T23:59:59.999') }\n * //     ]\n * //   }\n * // }\n * // Note que 'created_at_from' e 'created_at_until' foram removidos.\n */\nfunction setConditionBetweenDates(\n  object,\n  fromFormat = DATE_BR_FORMAT_D,\n  key = \"created_at\",\n  beforeKey = \"created_at_until\",\n  afterKey = \"created_at_from\",\n  resetHMS = true\n) {\n  // Guarda de validação: retorna null se o objeto não existir ou se nenhuma das chaves de\n  // intervalo de data estiver presente, mantendo o comportamento original.\n  if (!object || (!object[afterKey] && !object[beforeKey])) {\n    return null;\n  }\n\n  const conditions = [];\n\n  // Processa a data inicial do intervalo ('de')\n  if (object[afterKey]) {\n    // Converte a string de data para um objeto Date.\n    const fromDate = stringToDate(object[afterKey], fromFormat);\n\n    // Ajusta a data para o início do dia, se solicitado.\n    const finalDate = resetHMS ? dateFirstHourOfDay(fromDate) : fromDate;\n\n    conditions.push({ $gte: finalDate });\n\n    // Remove a chave original do objeto, conforme a lógica original.\n    delete object[afterKey];\n  }\n\n  // Processa a data final do intervalo ('até')\n  if (object[beforeKey]) {\n    const untilDate = stringToDate(object[beforeKey], fromFormat);\n\n    // Ajusta a data para o final do dia, se solicitado.\n    const finalDate = resetHMS ? dateLastHourOfDay(untilDate) : untilDate;\n\n    conditions.push({ $lte: finalDate });\n\n    // Remove a chave original do objeto.\n    delete object[beforeKey];\n  }\n\n  // Adiciona a nova chave de condição ao objeto.\n  object[key] = {\n    $and: conditions,\n  };\n\n  // Retorna o objeto modificado, mantendo o comportamento original.\n  return object;\n}\n\n// ------------------------------------------------------------------------------------------------\nexport default setConditionBetweenDates;\n// ------------------------------------------------------------------------------------------------\n","/**\n * @fileoverview Fornece uma função utilitária para formatar condições de busca\n * por intervalo (BETWEEN) em objetos de consulta de banco de dados.\n */\n\n/**\n * Cria uma condição de busca por intervalo (BETWEEN) em um objeto de consulta.\n *\n * @summary Formata um valor de objeto para uma condição de intervalo (BETWEEN) de ORM.\n * @description Modifica um objeto de consulta para adicionar uma cláusula `$and` com condições\n * `$gte` (maior ou igual a) e/ou `$lte` (menor ou igual a). Esta função é útil para filtrar\n * por um intervalo de valores (ex: datas, preços). **A função modifica o objeto de entrada diretamente**.\n *\n * @param {object} object - O objeto de consulta que será **modificado**.\n * @param {string} [key=\"value\"] - A chave principal no objeto onde a condição `$and` será criada.\n * @param {string} [beforeKey=\"value_until\"] - A chave no objeto que contém o valor final do intervalo (`<=`).\n * @param {string} [afterKey=\"value_from\"] - A chave no objeto que contém o valor inicial do intervalo (`>=`).\n * @returns {object|void} Retorna o objeto modificado se ao menos uma condição (`beforeKey` ou `afterKey`)\n * for aplicada. Retorna `undefined` (implicitamente) se nenhuma condição for encontrada no objeto.\n * @example\n * // Caso com ambas as chaves\n * const query = { value_from: '2025-01-01', value_until: '2025-01-31' };\n * setConditionBetweenValues(query);\n * // query é modificado para:\n * // {\n * //   value_from: '2025-01-01',\n * //   value_until: '2025-01-31',\n * //   value: { $and: [ { $gte: '2025-01-01' }, { $lte: '2025-01-31' } ] }\n * // }\n *\n * // Caso com apenas a chave inicial\n * const query2 = { value_from: 100 };\n * setConditionBetweenValues(query2);\n * // query2 é modificado para: { value_from: 100, value: { $and: [ { $gte: 100 } ] } }\n */\nfunction setConditionBetweenValues(\n  object,\n  key = \"value\",\n  beforeKey = \"value_until\",\n  afterKey = \"value_from\"\n) {\n  // Guarda de validação: se o objeto não existe, ou se nenhuma das chaves de\n  // intervalo (`afterKey` ou `beforeKey`) está presente, a função não faz nada.\n  // Preserva o retorno implícito de `undefined` do código original.\n  if (!object || (!object[afterKey] && !object[beforeKey])) {\n    return;\n  }\n\n  const conditions = [];\n\n  // Adiciona a condição de limite inferior se a chave correspondente existir.\n  if (object[afterKey]) {\n    conditions.push({ $gte: object[afterKey] });\n  }\n\n  // Adiciona a condição de limite superior se a chave correspondente existir.\n  if (object[beforeKey]) {\n    conditions.push({ $lte: object[beforeKey] });\n  }\n\n  // Atribui a nova estrutura de condição ao objeto na chave especificada.\n  object[key] = {\n    $and: conditions,\n  };\n\n  // Preserva o retorno do objeto modificado do código original.\n  return object;\n}\n\n// ------------------------------------------------------------------------------------------------\nexport default setConditionBetweenValues;\n// ------------------------------------------------------------------------------------------------\n","/**\n * @fileoverview Fornece uma função utilitária para formatar condições de busca\n * textual (LIKE) em objetos de consulta de banco de dados.\n */\n\n/**\n * Modifica um objeto para criar uma condição de busca textual (LIKE/ILIKE).\n *\n * @summary Formata um valor de objeto para uma condição LIKE de ORM.\n * @description Esta função é um utilitário para construir cláusulas de consulta para ORMs (como Sequelize).\n * Ela pega o valor de uma chave no objeto, o envolve com wildcards (`%`) e o reatribui\n * à mesma chave no formato `{ $iLike: '%valor%' }` ou `{ $like: '%valor%' }`.\n * A função modifica o objeto de entrada diretamente (mutação).\n *\n * @param {object} object - O objeto de consulta que será **modificado**.\n * @param {string} key - A chave no objeto cujo valor será formatado.\n * @param {boolean} [insensitive=true] - Se `true`, usa `$iLike` (case-insensitive). Se `false`, usa `$like` (case-sensitive).\n * @returns {void} Esta função não retorna um valor; ela modifica o objeto passado como referência.\n * @example\n * const query = { name: 'Maria' };\n * setConditionStringLike(query, 'name');\n * // O objeto 'query' agora é: { name: { $iLike: '%Maria%' } }\n *\n * const filter = { email: 'TESTE@' };\n * setConditionStringLike(filter, 'email', false);\n * // O objeto 'filter' agora é: { email: { $like: '%TESTE@%' } }\n *\n * const emptyQuery = { name: '' };\n * setConditionStringLike(emptyQuery, 'name');\n * // O objeto 'emptyQuery' não é modificado, pois o valor inicial é \"falsy\".\n */\nfunction setConditionStringLike(object, key, insensitive = true) {\n  // Guarda de validação: se o objeto, a chave ou o valor na chave não existirem\n  // ou forem \"falsy\" (como uma string vazia), a função não faz nada.\n  if (!object || !key || !object[key]) {\n    return;\n  }\n\n  // Determina o operador a ser usado com base na opção 'insensitive'.\n  const operator = insensitive ? '$iLike' : '$like';\n  \n  // Armazena o valor original para evitar problemas na reatribuição.\n  const value = object[key];\n\n  // Modifica o objeto, reatribuindo a chave com a nova estrutura de condição.\n  // Usa a sintaxe de nome de propriedade computada ([operator]) para definir a chave dinamicamente.\n  object[key] = {\n    [operator]: `%${value}%`,\n  };\n}\n\n// ------------------------------------------------------------------------------------------------\nexport default setConditionStringLike;\n// ------------------------------------------------------------------------------------------------","// =================================================================================================\n// ARQUIVO:      BulkProcessor.js\n// OBJETIVO:     Fornecer uma classe genérica e de alta performance para processamento de dados\n//               em lote (bulk). Abstrai a complexidade de acumular itens, enviá-los em\n//               batches, e gerenciar concorrência e finalização segura.\n// =================================================================================================\nimport defaultNumeric from \"../helpers/defaultNumeric.js\";\n\n/**\n * @typedef {object} Logger\n * @description Define a interface para um logger compatível.\n * @property {(message: string, context?: object) => void} info - Função para logar mensagens informativas.\n * @property {(message: string, context?: object) => void} error - Função para logar mensagens de erro.\n */\n\n/**\n * @typedef {object} BulkProcessorOptions\n * @property {number} [limit=1000] - O número de itens a acumular antes de disparar o processamento do lote. Será forçado para no mínimo 1.\n * @property {Logger} [logger] - Uma instância de logger estruturado. Se não for fornecido, um logger silencioso será usado.\n * @property {any} [payload={}] - Um objeto de dados estático que será passado para todos os callbacks.\n * @property {any} [serviceContext=null] - Um contexto de serviço ou de dados que será passado para os callbacks.\n * @property {(params: { batch: any[], payload: any, serviceContext: any, logger: Logger }) => Promise<void>} [onFlush] - Callback assíncrono chamado para processar um lote.\n * @property {(params: { buffer: any[], payload: any, item: any, serviceContext: any, logger: Logger }) => Promise<void>} [onAdd] - Callback assíncrono chamado a cada item adicionado.\n * @property {(params: { payload: any, serviceContext: any, logger: Logger }) => Promise<void>} [onEnd] - Callback assíncrono chamado quando o método `end()` é invocado, antes do flush final.\n */\n\n/**\n * @class BulkProcessor\n * @description Gerencia o processamento de itens em lote (bulk).\n * A classe acumula itens em um buffer interno e invoca um callback de processamento\n * assíncrono quando o tamanho do lote atinge um limite definido. É ideal para otimizar\n * operações de I/O, como inserções em banco de dados ou chamadas para APIs.\n *\n * @example\n * // Uso padrão com a nova API de opções\n * const processor = new BulkProcessor({\n * limit: 100,\n * onFlush: async ({ batch }) => {\n * console.log(`Processing ${batch.length} items.`);\n * // ...lógica de inserção no banco de dados...\n * }\n * });\n *\n * for (let i = 0; i < 1000; i++) {\n * processor.add({ id: i, data: `item-${i}` });\n * }\n * await processor.end();\n */\nclass BulkProcessor {\n  /** @private @type {any[]} */\n  #buffer = [];\n  /** @private @type {number} */\n  #limit;\n  /** @private @type {number} */\n  #maxBufferSize;\n  /** @private @type {number} */\n  #maxConcurrentFlushes;\n  /** @private @type {number} */\n  #activeFlushes = 0;\n  /** @private @type {boolean} */\n  #isEnding = false;\n  /** @private @type {Logger} */\n  #logger;\n  /** @private @type {any} */\n  #payload;\n  /** @private @type {any} */\n  #serviceContext;\n  /** @private @type {number} */\n  #retries;\n  /** @private @type {number} */\n  #retryDelayMs;\n  /** @private @type {number} */\n  #flushTimeoutMs;\n  /** @private @type {{onAdd?: Function, onFlush?: Function, onEnd?: Function, onBackpressure?: Function, onFlushFailure?: Function}} */\n  #callbacks;\n\n  /**\n   * Constrói e configura uma nova instância do BulkProcessor.\n   * Este método é projetado para ser flexível, suportando tanto uma assinatura\n   * moderna baseada em um único objeto de opções quanto uma assinatura legada\n   * para garantir a retrocompatibilidade.\n   *\n   * @param {BulkProcessorOptions | object} [arg1={}] - O objeto de opções ou o `payload` (legado).\n   * @param {object} [arg2={}] - O objeto `callbackFunctions` (legado).\n   * @param {object} [arg3={}] - O objeto `options` (legado).\n   */\n  constructor(arg1 = {}, arg2 = {}, arg3 = {}) {\n    let options;\n\n    // Bloco de compatibilidade para a assinatura legada (payload, callbacks, options).\n    // Se os argumentos 2 ou 3 forem fornecidos, o construtor assume que a assinatura\n    // antiga está em uso e remapeia os parâmetros para o novo formato de 'options'.\n    if (Object.keys(arg2).length > 0 || Object.keys(arg3).length > 0) {\n      const payload = arg1;\n      const callbackFunctions = arg2;\n      const otherOptions = arg3;\n      options = {\n        ...otherOptions,\n        payload: otherOptions.payload || payload,\n        onAdd: otherOptions.onAdd || callbackFunctions.onAddCallback,\n        onFlush: otherOptions.onFlush || callbackFunctions.onFlushCallback,\n        onEnd: otherOptions.onEnd || callbackFunctions.onEndCallback,\n      };\n    } else {\n      options = arg1;\n    }\n\n    // Define os padrões para todas as configurações e extrai os valores fornecidos pelo usuário.\n    const {\n      limit: userLimit = 1000,\n      maxBufferSize,\n      maxConcurrentFlushes = 3,\n      flushTimeoutMs = 30000,\n      retries = 0,\n      retryDelayMs = 1000,\n      logger = {\n        info: () => {},\n        error: () => {},\n        warn: () => {},\n        debug: () => {},\n      },\n      payload = {},\n      serviceContext = null,\n      onFlush,\n      onAdd,\n      onEnd,\n      onBackpressure,\n      onFlushFailure,\n    } = options;\n\n    // --- Sanitização e Validação dos Parâmetros ---\n    // Esta seção \"blinda\" o processador contra configurações inválidas ou inseguras,\n    // garantindo que os valores numéricos sejam válidos e estejam dentro de limites razoáveis.\n    this.#limit = Math.max(defaultNumeric(userLimit, 1), 1);\n    // O buffer deve ter espaço para pelo menos dois lotes completos para evitar backpressure prematuro.\n    this.#maxBufferSize = Math.max(\n      this.#limit * 2,\n      defaultNumeric(maxBufferSize, 0)\n    );\n    // Deve haver pelo menos 1 slot de processamento concorrente (comportamento sequencial).\n    this.#maxConcurrentFlushes = Math.max(\n      1,\n      defaultNumeric(maxConcurrentFlushes, 3)\n    );\n    // O número de retries não pode ser negativo.\n    this.#retries = Math.max(0, defaultNumeric(retries, 0));\n    // Garante um delay mínimo para evitar loops de retry muito agressivos.\n    this.#retryDelayMs = Math.max(100, defaultNumeric(retryDelayMs, 1000));\n    // Garante um timeout mínimo para o flush.\n    this.#flushTimeoutMs = Math.max(500, defaultNumeric(flushTimeoutMs, 30000));\n\n    // Atribuição das propriedades da instância.\n    this.#logger = logger;\n    this.#payload = payload;\n    this.#serviceContext = serviceContext;\n    this.#callbacks = { onFlush, onAdd, onEnd, onBackpressure, onFlushFailure };\n\n    // Log de inicialização para observabilidade, registrando a configuração final aplicada.\n    this.#logger.info(`BulkProcessor inicializado.`, {\n      limit: this.#limit,\n      maxBufferSize: this.#maxBufferSize,\n      maxConcurrentFlushes: this.#maxConcurrentFlushes,\n      retries: this.#retries,\n      retryDelayMs: this.#retryDelayMs,\n      flushTimeoutMs: this.#flushTimeoutMs,\n    });\n  }\n\n  /**\n   * Adiciona um item à fila de processamento de forma assíncrona.\n   *\n   * Este é o principal método para popular o processador. Ele gerencia a lógica de backpressure:\n   * se o buffer interno atingir sua capacidade máxima (`maxBufferSize`), a execução\n   * deste método será pausada até que haja espaço disponível. Isso previne o consumo\n   * excessivo de memória sob alta carga.\n   *\n   * A chamada ao callback `onAdd` é realizada de forma \"fire-and-forget\" e não bloqueia a adição do item.\n   *\n   * @param {*} item - O item a ser adicionado ao lote.\n   * @returns {Promise<void>} Uma promessa que resolve quando o item foi adicionado com sucesso ao buffer.\n   */\n  async add(item) {\n    // Trava de segurança para impedir a adição de itens durante o processo de finalização.\n    if (this.#isEnding) {\n      this.#logger.info(\n        \"Processador em estado de finalização. Novos itens estão sendo ignorados.\",\n        { item }\n      );\n      return;\n    }\n\n    // --- Lógica de Backpressure ---\n    // Se o buffer atingiu a capacidade máxima, o processador entra em estado de espera.\n    if (this.#buffer.length >= this.#maxBufferSize) {\n      // Notifica o sistema de que o backpressure foi ativado. A chamada é feita\n      // de forma não-bloqueante para não travar o processo principal.\n      if (this.#callbacks.onBackpressure) {\n        Promise.resolve(\n          this.#callbacks.onBackpressure({\n            bufferSize: this.#buffer.length,\n            maxBufferSize: this.#maxBufferSize,\n            item, // Informa qual item está aguardando para ser adicionado.\n          })\n        ).catch((error) => {\n          this.#logger.error(\"Erro no callback onBackpressure.\", {\n            errorMessage: error.message,\n          });\n        });\n      }\n\n      // Aguarda em um laço até que o buffer tenha espaço novamente.\n      while (this.#buffer.length >= this.#maxBufferSize) {\n        // Pausa a execução por um curto período para evitar consumo de CPU (busy-waiting)\n        // e permite que a event loop processe os flushes em andamento.\n        await new Promise((resolve) => setTimeout(resolve, 50));\n      }\n    }\n\n    // O item é adicionado ao buffer somente após a liberação do backpressure.\n    this.#buffer.push(item);\n\n    // O callback onAdd é invocado de forma não-bloqueante para não impactar a performance de adição.\n    if (this.#callbacks.onAdd) {\n      try {\n        // `Promise.resolve()` garante que mesmo um onAdd síncrono seja tratado como uma promessa.\n        Promise.resolve(\n          this.#callbacks.onAdd({\n            buffer: this.#buffer,\n            payload: this.#payload,\n            item,\n            serviceContext: this.#serviceContext,\n            logger: this.#logger,\n          })\n        ).catch((error) => {\n          this.#logger.error(`Erro não tratado no callback onAdd.`, {\n            errorMessage: error.message,\n          });\n        });\n      } catch (syncError) {\n        // Este catch é uma segurança extra para callbacks síncronos que podem lançar exceções.\n        this.#logger.error(`Erro síncrono no callback onAdd.`, {\n          errorMessage: syncError.message,\n        });\n      }\n    }\n\n    // Verifica se o buffer atingiu o limite para um lote e dispara o processamento.\n    if (this.#buffer.length >= this.#limit) {\n      this.flush();\n    }\n  }\n\n  /**\n   * Dispara o processamento de lotes de forma síncrona e não-bloqueante.\n   *\n   * Atua como um \"despachante\": ele verifica o estado atual do buffer e os slots\n   * de concorrência disponíveis e inicia quantas operações de processamento (`#executeFlush`)\n   * forem possíveis, até o limite de `maxConcurrentFlushes`.\n   *\n   * Este método é chamado automaticamente pelo `add()` e `end()`, mas também pode ser\n   * invocado manualmente para forçar o processamento de um lote parcial.\n   */\n  flush() {\n    // Este laço é o coração da concorrência. Enquanto houver itens e \"trabalhadores\" (slots)\n    // disponíveis, ele continuará despachando novos trabalhos.\n    while (\n      this.#buffer.length > 0 &&\n      this.#activeFlushes < this.#maxConcurrentFlushes\n    ) {\n      const batch = this.#buffer.splice(0, this.#limit);\n      // Dispara a execução sem esperar (fire-and-forget) para permitir que múltiplos\n      // flushes ocorram em paralelo. O gerenciamento do estado assíncrono é feito em #executeFlush.\n      this.#executeFlush(batch);\n    }\n  }\n\n  /**\n   * O motor de processamento assíncrono para um único lote.\n   *\n   * Este método privado encapsula toda a lógica complexa de uma operação de flush,\n   * incluindo:\n   * 1. Gerenciamento do timeout da operação (`flushTimeoutMs`).\n   * 2. Implementação da política de retries (`retries` e `retryDelayMs`).\n   * 3. Invocação do callback `onFlushFailure` para lotes que falham permanentemente.\n   * 4. Gerenciamento do contador de flushes ativos.\n   * 5. Disparo reativo do próximo ciclo de `flush` para manter o pipeline de processamento ativo.\n   *\n   * @private\n   * @param {any[]} batch - O lote de itens que esta execução irá processar.\n   * @returns {Promise<void>}\n   */\n  async #executeFlush(batch) {\n    // Incrementa o contador de operações ativas. Este é o início do ciclo de vida de um flush.\n    this.#activeFlushes++;\n    this.#logger.info(\n      `Iniciando processamento de lote com ${batch.length} itens. Ativos: ${\n        this.#activeFlushes\n      }`\n    );\n\n    let lastError = null;\n\n    // Laço de tentativas: executa a tentativa inicial (attempt 0) + o número de retries configurado.\n    for (let attempt = 0; attempt <= this.#retries; attempt++) {\n      try {\n        // Caso de borda: se nenhum onFlush for fornecido, descarta o lote intencionalmente.\n        if (!this.#callbacks.onFlush) {\n          this.#logger.info(\n            `Nenhum callback onFlush definido. Lote de ${batch.length} itens descartado.`\n          );\n          lastError = null; // Garante que não será tratado como uma falha.\n          break;\n        }\n\n        if (attempt > 0) {\n          this.#logger.info(\n            `Tentativa ${attempt}/${this.#retries} para o lote.`\n          );\n        }\n\n        // Executa o onFlush em uma \"corrida\" contra um timer de timeout.\n        let timeoutId;\n        const timeoutPromise = new Promise((_, reject) => {\n          timeoutId = setTimeout(\n            () =>\n              reject(\n                new Error(`Flush timed out after ${this.#flushTimeoutMs}ms`)\n              ),\n            this.#flushTimeoutMs\n          );\n        });\n\n        try {\n          await Promise.race([\n            this.#callbacks.onFlush({\n              batch,\n              payload: this.#payload,\n              serviceContext: this.#serviceContext,\n              logger: this.#logger,\n            }),\n            timeoutPromise,\n          ]);\n        } finally {\n          // CRÍTICO: Limpa o timeout para evitar que ele dispare mais tarde\n          // e cause um unhandled rejection, caso o flush termine antes do tempo.\n          clearTimeout(timeoutId);\n        }\n\n        // Se a execução chegou aqui, o lote foi processado com sucesso.\n        this.#logger.info(\n          `Lote de ${batch.length} itens processado com sucesso.`\n        );\n        lastError = null;\n        break; // Sai do laço de retries.\n      } catch (error) {\n        // Ocorreu uma falha (seja do onFlush ou do timeout).\n        lastError = error;\n\n        if (attempt >= this.#retries) {\n          // Se esta foi a última tentativa, registra um erro definitivo.\n          this.#logger.error(\n            `Falha definitiva ao processar o lote após ${attempt} tentativa(s).`,\n            {\n              errorMessage: error.message,\n              batchSize: batch.length,\n            }\n          );\n        } else {\n          // Se ainda há tentativas, avisa e aguarda o delay para tentar novamente.\n          this.#logger.warn(\n            `Falha na tentativa ${attempt} de processar o lote. Tentando novamente em ${\n              this.#retryDelayMs\n            }ms...`,\n            {\n              errorMessage: error.message,\n            }\n          );\n          await new Promise((resolve) =>\n            setTimeout(resolve, this.#retryDelayMs)\n          );\n        }\n      }\n    }\n\n    // --- Pós-processamento do Lote ---\n\n    // Se um erro persistiu após todas as retries, aciona o callback de falha definitiva.\n    // Este é o gancho para o usuário implementar uma \"dead-letter queue\".\n    if (lastError && this.#callbacks.onFlushFailure) {\n      try {\n        await this.#callbacks.onFlushFailure({\n          batch,\n          error: lastError,\n          payload: this.#payload,\n          serviceContext: this.#serviceContext,\n          logger: this.#logger,\n        });\n        this.#logger.info(\n          `Callback onFlushFailure executado para o lote com falha.`\n        );\n      } catch (failureCallbackError) {\n        // Segurança: captura erros no próprio callback de falha para não quebrar o processador.\n        this.#logger.error(`Erro CRÍTICO no próprio callback onFlushFailure.`, {\n          errorMessage: failureCallbackError.message,\n        });\n      }\n    }\n\n    // --- Finalização e Reativação ---\n\n    // Decrementa o contador de operações ativas, liberando um slot de concorrência.\n    this.#activeFlushes--;\n    this.#logger.info(\n      `Processamento de lote finalizado. Ativos: ${this.#activeFlushes}`\n    );\n    // Dispara um novo ciclo de flush. Esta chamada reativa é a chave para manter\n    // o processador funcionando em capacidade máxima, preenchendo o slot que acabou de ser liberado.\n    this.flush();\n  }\n\n  /**\n   * Finaliza o processador, garantindo que todos os itens pendentes sejam processados.\n   * Este método é idempotente (seguro para ser chamado múltiplas vezes) e DEVE ser\n   * invocado ao final do ciclo de vida da aplicação para evitar perda de dados.\n   *\n   * @param {number} [forceTimeoutMs=30000] - Tempo máximo em milissegundos para aguardar a\n   * finalização dos lotes em processamento. Se o tempo for excedido, o processo é\n   * encerrado e um aviso é logado com os itens restantes.\n   * @returns {Promise<void>} Uma promessa que resolve quando todos os itens forem\n   * processados ou quando o timeout for atingido.\n   */\n  async end(forceTimeoutMs = 30000) {\n    // Garante que a lógica de finalização execute apenas uma vez.\n    if (this.#isEnding) {\n      return;\n    }\n    // Sinaliza para outras partes do processador (como o método `add`) que o desligamento começou.\n    this.#isEnding = true;\n    const endStartTime = Date.now();\n\n    this.#logger.info(\"Finalizando o processador...\", {\n      itemsNoBuffer: this.#buffer.length,\n      activeFlushes: this.#activeFlushes,\n    });\n\n    // Executa o callback de finalização do usuário, se fornecido.\n    if (this.#callbacks.onEnd) {\n      try {\n        await this.#callbacks.onEnd({\n          /* ... */\n        });\n      } catch (error) {\n        this.#logger.error(`Erro no callback onEnd.`, {\n          errorMessage: error.message,\n        });\n      }\n    }\n\n    // Dispara um último ciclo de flush para processar qualquer item restante no buffer.\n    this.flush();\n\n    // Aguarda o \"esvaziamento\" do processador, respeitando o timeout.\n    // O laço continua enquanto houver itens no buffer ou operações de flush ativas.\n    while (\n      (this.#buffer.length > 0 || this.#activeFlushes > 0) &&\n      Date.now() - endStartTime < forceTimeoutMs\n    ) {\n      await new Promise((resolve) => setTimeout(resolve, 50));\n    }\n\n    // Se o laço terminou mas ainda há trabalho pendente, significa que o timeout foi atingido.\n    if (this.#buffer.length > 0 || this.#activeFlushes > 0) {\n      this.#logger.warn(\n        \"Finalização forçada por timeout. Itens não processados foram descartados.\",\n        {\n          remainingItems: this.#buffer.length,\n          activeFlushes: this.#activeFlushes,\n        }\n      );\n    }\n\n    this.#logger.info(\"Processador finalizado.\");\n  }\n}\n\n// =================================================================================================\n// Exportação da classe para o sistema de módulos do Node.js (CommonJS).\n// Permite que a classe seja importada e instanciada em outros arquivos via `require` ou `import`.\n// =================================================================================================\nexport default BulkProcessor;","/**\n * @fileoverview Fornece uma classe para gerenciar estados de espera assíncronos (Promises).\n * @description Este módulo exporta uma instância única (singleton) da WaitPlugin.\n */\n\n/**\n * @class WaitPlugin\n * @summary Gerencia a criação e resolução de Promises \"on-demand\".\n * @description Utiliza um Map internamente para máxima performance em adições e remoções,\n * enquanto expõe a lista de esperas como um Objeto para compatibilidade e depuração.\n */\nclass WaitPlugin {\n  \n  /**\n   * Inicializa o plugin.\n   * @constructor\n   */\n  constructor() {\n    /**\n     * Armazena as esperas ativas. É um Map privado para performance.\n     * @private\n     * @type {Map<string, {promise: Promise<any>, resolve: Function, reject: Function}>}\n     */\n    this._waitList = new Map();\n  }\n\n  /**\n   * Getter público para a lista de esperas.\n   * @description Converte o Map interno em um Objeto simples para fins de compatibilidade\n   * com testes ou para facilitar a depuração.\n   * @returns {Object<string, {promise: Promise<any>, resolve: Function, reject: Function}>}\n   */\n  get waitList() {\n    return Object.fromEntries(this._waitList);\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Finaliza uma espera, resolvendo ou rejeitando a Promise correspondente.\n   *\n   * @param {string} name - O nome único da espera a ser finalizada.\n   * @param {boolean} [isSuccessful=true] - Se `true`, a Promise será resolvida. Se `false`, será rejeitada.\n   * @param {*} [returnParam] - O valor a ser passado para o `resolve` ou `reject` da Promise.\n   * @returns {any} Retorna `false` se a espera não existir. Em caso de erro interno, retorna o\n   * próprio objeto de erro. Em sucesso, o retorno é indefinido.\n   */\n  finishWait(name, isSuccessful = true, returnParam) {\n    try {\n      const waitItem = this._waitList.get(name);\n      if (!waitItem) {\n        return false;\n      }\n\n      if (isSuccessful) {\n        waitItem.resolve(returnParam);\n      } else {\n        waitItem.reject(returnParam);\n      }\n    } catch (error) {\n      return error;\n    } finally {\n      // A operação delete do Map é segura e performática.\n      this._waitList.delete(name);\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Inicia uma nova espera e retorna uma Promise associada a ela.\n   *\n   * @param {string} name - O nome único para a nova espera.\n   * @returns {Promise<any>|undefined} Retorna a Promise que aguardará a finalização.\n   * Retorna `undefined` se uma espera com o mesmo nome já existir.\n   */\n  startWait(name) {\n    if (this._waitList.has(name)) {\n      return;\n    }\n    \n    let resolve, reject;\n    const promise = new Promise((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n    \n    this._waitList.set(name, { promise, resolve, reject });\n    \n    return promise;\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Finaliza todas as esperas ativas de uma só vez.\n   *\n   * @param {boolean} isSuccessful - Se `true`, todas as Promises serão resolvidas. Se `false`, serão rejeitadas.\n   * @param {*} [returnParam] - O valor a ser passado para cada `resolve` ou `reject`.\n   */\n  finishAll(isSuccessful, returnParam) {\n    // Cria uma cópia das chaves antes de iterar. É a forma mais segura de\n    // modificar uma coleção (neste caso, o Map) enquanto ela está sendo percorrida.\n    const allWaitKeys = Array.from(this._waitList.keys());\n    \n    for (const key of allWaitKeys) {\n      this.finishWait(key, isSuccessful, returnParam);\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n}\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Instância única (singleton) do WaitPlugin.\n * @type {WaitPlugin}\n */\nconst WP = new WaitPlugin();\n\n// ------------------------------------------------------------------------------------------------\n\nexport default WP;","// 1. Importa tudo que será exportado.\n//    Usamos 'import * as' para agrupar as funções do sequelize em um único objeto 'db'.\nimport * as db from \"./db/sequelize/index.js\";\nimport waitPlugin from \"./waitPlugin.js\";\nimport bulkProcessor from \"./bulkProcessor.js\";\n\n// 2. Exporta cada item como uma exportação nomeada.\n//    Isso permite o uso de: import { db, waitPlugin } from '...'\nexport {\n  db,\n  waitPlugin,\n  bulkProcessor\n};\n\n// 3. Agrupa tudo em um objeto e exporta como `default`.\n//    Isso permite o uso de: import custom from '...'; custom.waitPlugin\nexport default {\n  db,\n  waitPlugin,\n  bulkProcessor,\n};"],"mappings":"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","names":["crypto","defaultValue","defaultValue","clone","require","format","crypto","crypto","format","format","crypto","import_fflate","import_fflate","import_fflate","format","_calculateVerifierDigit","format","crypto","crypto","format","crypto","crypto","crypto","import_cbor_x","payload","crypto"]}