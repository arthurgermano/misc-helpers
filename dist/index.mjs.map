{"version":3,"sources":["../src/utils/bufferConcatenate.js","../src/auth/webauthn/convertECDSAASN1Signature.js","../src/utils/base64To.js","../src/utils/base64FromBuffer.js","../src/auth/webauthn/getAuthenticationAuthData.js","../src/auth/webauthn/getRegistrationAuthData.js","../src/auth/webauthn/getWebAuthnAuthenticationAssertion.js","../src/auth/webauthn/getWebAuthnRegistrationCredential.js","../src/utils/base64ToBuffer.js","../src/utils/bufferCompare.js","../src/utils/bufferFromString.js","../src/crypto/getCrypto.js","../src/auth/webauthn/validateRPID.js","../src/crypto/verifySignature.js","../src/crypto/importCryptoKey.js","../src/helpers/isNumber.js","../src/utils/base64From.js","../src/auth/webauthn/validateAuthentication.js","../src/auth/webauthn/validateRegistration.js","../src/auth/webauthn/index.js","../src/constants.js","../src/utils/bufferToString.js","../src/crypto/decrypt.js","../src/crypto/encrypt.js","../src/crypto/digest.js","../src/crypto/index.js","../src/helpers/isInstanceOf.js","../src/utils/stringToDate.js","../src/utils/dateFirstHourOfDay.js","../src/utils/dateLastHourOfDay.js","../src/custom/db/sequelize/setConditionsBetweenDates.js","../src/custom/db/sequelize/setConditionsBetweenValues.js","../src/custom/db/sequelize/setConditionStringLike.js","../src/custom/waitPlugin.js","../src/helpers/defaultNumeric.js","../src/custom/bulkProcessor.js","../src/helpers/dateCompareAsc.js","../src/helpers/dateCompareDesc.js","../src/helpers/defaultValue.js","../src/helpers/isObject.js","../src/helpers/index.js","../src/utils/assign.js","../src/utils/base64FromBase64URLSafe.js","../src/utils/toString.js","../src/utils/base64URLEncode.js","../src/utils/calculateSecondsInTime.js","../src/utils/currencyBRToFloat.js","../src/utils/dateToFormat.js","../src/utils/debouncer.js","../src/utils/deleteKeys.js","../src/utils/generateSimpleId.js","../src/utils/generateRandomString.js","../src/utils/getExecutionTime.js","../src/utils/JSONFrom.js","../src/utils/JSONTo.js","../src/utils/messageEncryptToChunks.js","../src/utils/messageDecryptFromChunks.js","../src/utils/normalize.js","../src/utils/pickKeys.js","../src/utils/pushLogMessage.js","../src/utils/regexDigitsOnly.js","../src/utils/regexReplaceTrim.js","../src/utils/regexLettersOnly.js","../src/utils/removeDuplicatedStrings.js","../src/utils/sleep.js","../src/utils/split.js","../src/utils/stringCompress.js","../src/utils/stringDecompress.js","../src/utils/stringToDateToFormat.js","../src/utils/stringToFormat.js","../src/utils/stringZLibCompress.js","../src/utils/stringZLibDecompress.js","../src/utils/throttle.js","../src/utils/timestamp.js","../src/utils/uint8ArrayFromString.js","../src/utils/uint8ArrayToString.js","../src/utils/index.js","../src/validators/validateCADICMSPR.js","../src/validators/validateCEP.js","../src/validators/validateCNPJ.js","../src/validators/validateCPF.js","../src/validators/validateEmail.js","../src/validators/validateChavePix.js","../src/validators/validateCNH.js","../src/validators/validatePISPASEPNIT.js","../src/validators/validateRenavam.js","../src/validators/validateTituloEleitor.js","../src/validators/validateRG.js","../src/validators/index.js","../src/custom/db/sequelize/index.js","../src/index.js"],"sourcesContent":["/**\n * @file Utilitário para concatenação de objetos \"buffer-like\".\n * @author Seu Nome <seu.email@example.com>\n * @version 2.3.0\n */\n\n/**\n * @summary Concatena dois objetos \"buffer-like\" em um novo ArrayBuffer.\n *\n * @description\n * Esta função une dois objetos que se comportam como buffers (ex: ArrayBuffer,\n * Node.js Buffer, Uint8Array). Ela cria um novo ArrayBuffer contendo os bytes\n * do primeiro buffer seguidos pelos bytes do segundo. A implementação é robusta,\n * segura e universalmente compatível com Node.js e navegadores.\n *\n * @param {ArrayBuffer | Buffer | Uint8Array | null} buffer1 - O primeiro objeto buffer-like.\n * @param {ArrayBuffer | Buffer | Uint8Array | null} buffer2 - O segundo objeto buffer-like.\n *\n * @returns {ArrayBuffer | null} Um novo ArrayBuffer contendo a concatenação dos dois,\n * ou `null` se alguma das entradas for `null` ou se ocorrer um erro.\n *\n * @example\n * const buf1 = new Uint8Array([1, 2]).buffer;\n * const buf2 = new Uint8Array([3, 4]);\n * const combined = bufferConcatenate(buf1, buf2); // -> Retorna ArrayBuffer com [1, 2, 3, 4]\n *\n * const invalid = bufferConcatenate(buf1, null); // -> Retorna null\n */\nfunction bufferConcatenate(buffer1, buffer2) {\n  // 1. Validação explícita para `null` ou `undefined`.\n  // A verificação `== null` é uma forma concisa de tratar ambos os casos.\n  if (buffer1 == null || buffer2 == null) {\n    return null;\n  }\n\n  try {\n    // 2. Implementação Universal com Uint8Array.\n    // O construtor do `Uint8Array` lida nativamente com diversos tipos de buffer.\n    const view1 = new Uint8Array(buffer1);\n    const view2 = new Uint8Array(buffer2);\n\n    // Cria uma nova visão com o tamanho combinado.\n    const resultView = new Uint8Array(view1.length + view2.length);\n\n    // Copia os bytes de forma eficiente para a nova visão.\n    resultView.set(view1, 0);\n    resultView.set(view2, view1.length);\n\n    // Retorna o ArrayBuffer subjacente.\n    return resultView.buffer;\n  } catch (error) {\n    // Captura quaisquer outros erros que possam ocorrer com tipos de entrada inesperados\n    // e retorna `null` para indicar a falha.\n    return null;\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = bufferConcatenate;","const bufferConcatenate = require(\"../../utils/bufferConcatenate\");\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Converts an ECDSA signature from ASN.1/DER format to concatenated r|s format.\n * \n * The function expects an ASN.1 SEQUENCE containing exactly two INTEGER elements (r and s).\n * Both r and s components are normalized to be multiples of 128 bits (16 bytes) by:\n * - Removing leading zero bytes used for two's complement padding\n * - Adding zero padding when components are 15 bytes (one byte short of 16-byte boundary)\n *\n * @param {Uint8Array} asn1Signature - The input signature in ASN.1/DER format\n * @returns {Uint8Array} The signature in concatenated r|s format where both r and s are 128-bit aligned\n * @throws {Error} If the input doesn't contain exactly 2 ASN.1 sequence elements\n * @throws {Error} If r or s components have unexpected lengths after normalization\n */\nfunction convertECDSAASN1Signature(asn1Signature) {\n  const elements = readASN1IntegerSequence(asn1Signature);\n  \n  if (elements.length !== 2) {\n    throw new Error(\"Expected 2 ASN.1 sequence elements\");\n  }\n  \n  let [r, s] = elements;\n\n  // Normalize r component to 128-bit boundary\n  r = normalizeECDSAComponent(r);\n  \n  // Normalize s component to 128-bit boundary  \n  s = normalizeECDSAComponent(s);\n\n  // Concatenate normalized r and s components\n  return bufferConcatenate(r, s);\n}\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Normalizes an ECDSA signature component (r or s) to be a multiple of 128 bits (16 bytes).\n * \n * This function handles two cases:\n * 1. Removes leading zero byte if present for two's complement and length is 16n+1\n * 2. Adds leading zero byte padding if length is 16n-1 (15 bytes)\n *\n * @param {Uint8Array} component - The signature component to normalize\n * @returns {Uint8Array} The normalized component aligned to 128-bit boundary\n * @throws {Error} If the component length is not a multiple of 16 bytes after normalization\n */\nfunction normalizeECDSAComponent(component) {\n  const length = component.byteLength;\n  let normalized = component;\n  \n  // Remove leading zero byte used for two's complement if length is 16n+1\n  if (component[0] === 0 && length % 16 === 1) {\n    normalized = component.slice(1);\n  }\n  // Add leading zero byte padding if length is 16n-1 (15 bytes)\n  else if (length % 16 === 15) {\n    const padding = new Uint8Array([0]);\n    normalized = new Uint8Array(bufferConcatenate(padding, component));\n  }\n\n  // Validate that the component is now properly aligned to 128-bit boundary\n  if (normalized.byteLength % 16 !== 0) {\n    throw new Error(\"unknown ECDSA sig r length error\");\n  }\n\n  return normalized;\n}\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Parses an ASN.1/DER encoded sequence and extracts all INTEGER elements.\n * \n * This function performs basic ASN.1 parsing by:\n * 1. Validating the input starts with SEQUENCE tag (0x30)\n * 2. Reading the sequence length from the second byte\n * 3. Iterating through elements, ensuring each is an INTEGER (0x02)\n * 4. Extracting the value portion of each INTEGER element\n *\n * @param {Uint8Array} input - The ASN.1/DER encoded sequence\n * @returns {Array<Uint8Array>} Array of INTEGER values as Uint8Array buffers\n * @throws {Error} If input is not a valid ASN.1 SEQUENCE\n * @throws {Error} If any sequence element is not an ASN.1 INTEGER\n */\nfunction readASN1IntegerSequence(input) {\n  // Validate ASN.1 SEQUENCE tag\n  if (input[0] !== 0x30) {\n    throw new Error(\"Input is not an ASN.1 sequence\");\n  }\n\n  // Extract sequence length from second byte\n  const sequenceLength = input[1];\n  const elements = [];\n  \n  // Get sequence content, skipping tag and length bytes\n  let position = 2;\n  const sequenceEnd = position + sequenceLength;\n\n  // Parse all elements within the sequence\n  while (position < sequenceEnd) {\n    const tag = input[position];\n    \n    // Validate INTEGER tag\n    if (tag !== 0x02) {\n      throw new Error(\"Expected ASN.1 sequence element to be an INTEGER\");\n    }\n\n    // Read element length\n    const elementLength = input[position + 1];\n    \n    // Extract element value, skipping tag and length bytes\n    const elementValue = input.slice(position + 2, position + 2 + elementLength);\n    elements.push(elementValue);\n    \n    // Advance position to next element\n    position += 2 + elementLength;\n  }\n\n  return elements;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = convertECDSAASN1Signature;\n\n// ------------------------------------------------------------------------------------------------","/**\n * @file Utilitário cross-environment para codificação em Base64.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.0.0\n */\n\n/**\n * @summary Codifica uma string, Buffer ou número para o formato Base64 (sem preenchimento).\n *\n * @description\n * Esta função é cross-environment, funcionando de forma otimizada tanto em Node.js quanto\n * em navegadores. Ela converte a entrada fornecida para uma string Base64 e remove\n * os caracteres de preenchimento (`=`) no final, tornando-a mais compacta e segura para URLs.\n *\n * A implementação no navegador é robusta e lida corretamente com caracteres multi-byte (UTF-8),\n * como acentos e emojis.\n *\n * @param {string | Buffer | number} [text=\"\"] - A entrada a ser codificada. Pode ser uma string,\n * Buffer (apenas Node.js) ou número.\n * @param {BufferEncoding} [fromFormat] - **(Apenas Node.js)** A codificação da string de entrada,\n * se não for UTF-8. Exemplos: 'utf-8', 'hex', 'binary'.\n *\n * @returns {string} A representação da string em Base64, sem o preenchimento (`=`).\n *\n * @example\n * // Uso no Navegador ou Node.js com string UTF-8\n * const encoded = base64To('Sucesso! ✓');\n * console.log(encoded); // \"U3VjZXNzbyEg4pyT\"\n */\nfunction base64To(text = \"\", fromFormat) {\n  // Garante que a função retorne uma string vazia para entradas nulas ou indefinidas.\n  if (text == null) {\n    return \"\";\n  }\n\n  try {\n    let base64String;\n\n    // **Ambiente Node.js:**\n    if (typeof window === \"undefined\") {\n      // Otimização: se a entrada já for um Buffer, usa-o diretamente.\n      // Caso contrário, converte para string para garantir a consistência da entrada.\n      const input = Buffer.isBuffer(text) ? text : String(text);\n      \n      // Utiliza a API nativa Buffer, que lida com diversos formatos de entrada (`fromFormat`).\n      base64String = Buffer.from(input, fromFormat).toString(\"base64\");\n    } else {\n      // **Ambiente do Navegador:**\n      // A função `btoa` do navegador requer uma string onde cada caractere represente um byte (0-255).\n      // Esta linha converte uma string UTF-8 padrão para este formato \"binário\", garantindo\n      // que caracteres multi-byte (acentos, emojis) sejam codificados corretamente.\n      const binaryString = unescape(encodeURIComponent(String(text)));\n      base64String = window.btoa(binaryString);\n    }\n\n    // Remove um ou mais caracteres de preenchimento ('=') do final da string Base64\n    // para criar uma saída mais compacta e segura para URLs.\n    return base64String.replace(/=+$/, \"\");\n  } catch (error) {\n    // Em caso de qualquer erro durante o processo de codificação, retorna uma string vazia.\n    return \"\";\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = base64To;","const base64To = require(\"./base64To\");\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário para conversão de ArrayBuffer para Base64.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.0.0\n */\n\n/**\n * @summary Converte um ArrayBuffer em uma string Base64.\n *\n * @description\n * Esta função é cross-environment, funcionando de forma otimizada tanto em Node.js quanto\n * em navegadores. Ela lida com a conversão de dados binários brutos de um ArrayBuffer\n * para sua representação textual em Base64.\n *\n * No navegador, a função processa o buffer em blocos (chunks) para evitar erros de\n * \"Maximum call stack size exceeded\", garantindo a conversão segura de buffers grandes.\n *\n * @param {ArrayBuffer} buffer - O ArrayBuffer a ser convertido.\n *\n * @returns {string} A representação da string em Base64. Retorna uma string vazia\n * se a entrada não for um ArrayBuffer válido.\n *\n * @example\n * const data = new Uint8Array([0, 1, 2, 3, 253, 254, 255]);\n * const base64String = base64FromBuffer(data.buffer);\n * console.log(base64String); // \"AAECA/3+/w==\"\n */\nfunction base64FromBuffer(buffer) {\n  // Adiciona validação para garantir que a entrada é do tipo esperado.\n  if (!(buffer instanceof ArrayBuffer)) {\n    return \"\";\n  }\n\n  // **Ambiente Node.js:**\n  // A verificação `typeof window` é a forma padrão de diferenciar os ambientes.\n  if (typeof window === \"undefined\") {\n    // A forma mais eficiente no Node: converte o ArrayBuffer para um Buffer nativo\n    // e delega para a função de encoding, que é otimizada para isso.\n    return base64To(Buffer.from(buffer));\n  }\n\n  // **Ambiente do Navegador (implementação robusta):**\n  const bytes = new Uint8Array(buffer);\n  const CHUNK_SIZE = 8192; // Define um tamanho de bloco seguro (8KB)\n  const chunks = [];\n\n  // Itera sobre o buffer em blocos para evitar estouro de pilha.\n  for (let i = 0; i < bytes.length; i += CHUNK_SIZE) {\n    // Pega um \"pedaço\" do buffer. `subarray` é eficiente pois não cria uma nova cópia dos dados.\n    const chunk = bytes.subarray(i, i + CHUNK_SIZE);\n\n    // Converte o bloco de bytes em uma string binária e a armazena.\n    // Usar um array e `join` no final é geralmente mais performático que concatenação com `+=`.\n    chunks.push(String.fromCharCode.apply(null, chunk));\n  }\n\n  // Junta os blocos de string em um só e passa para a função de encoding (que usará btoa).\n  return base64To(chunks.join(\"\"));\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = base64FromBuffer;","const base64FromBuffer = require(\"../../utils/base64FromBuffer\");\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Extracts and processes data from a WebAuthn authentication assertion object.\n * \n * This function parses the WebAuthn assertion response and extracts all relevant\n * authentication data including client data, authenticator data, signature, and\n * optional user handle information.\n *\n * @param {Object} assertion - The WebAuthn authentication assertion object\n * @param {string} assertion.id - The credential ID as a string\n * @param {ArrayBuffer} assertion.rawId - The credential ID as raw bytes\n * @param {string} assertion.type - The credential type (typically \"public-key\")\n * @param {Object} assertion.response - The authenticator assertion response\n * @param {ArrayBuffer} assertion.response.clientDataJSON - Client data in JSON format\n * @param {ArrayBuffer} assertion.response.authenticatorData - Authenticator data bytes\n * @param {ArrayBuffer} assertion.response.signature - The assertion signature\n * @param {ArrayBuffer} [assertion.response.userHandle] - Optional user handle\n * @returns {Object} Extracted authentication data with parsed components\n * @throws {Error} If extraction fails due to missing or invalid data\n */\nfunction getAuthenticationAuthData(assertion) {\n  const id = assertion.id;\n  const rawId = base64FromBuffer(assertion.rawId);\n  const type = assertion.type;\n\n  // Build response object with all authentication data\n  const response = {\n    clientDataJSONDecoded: new TextDecoder().decode(assertion.response.clientDataJSON),\n    clientDataJSON: base64FromBuffer(assertion.response.clientDataJSON),\n    authenticatorData: base64FromBuffer(assertion.response.authenticatorData),\n    signature: base64FromBuffer(assertion.response.signature),\n    userHandle: assertion.response.userHandle\n      ? base64FromBuffer(assertion.response.userHandle)\n      : false\n  };\n\n  // Parse authenticator data structure\n  const authData = getAuthDataFromAuthentication(assertion.response.authenticatorData);\n\n  return {\n    id,\n    rawId,\n    type,\n    authData,\n    response\n  };\n}\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Parses WebAuthn authenticator data according to the FIDO2 specification.\n * \n * The authenticator data structure contains:\n * - RP ID Hash (32 bytes): SHA-256 hash of the relying party identifier\n * - Flags (1 byte): Bit flags indicating various states\n * - Counter (4 bytes): Signature counter value (big-endian)\n * - Optional attested credential data (variable length)\n * - Optional extensions data (variable length)\n *\n * @param {ArrayBuffer} authData - Raw authenticator data from WebAuthn response\n * @returns {Object} Parsed authenticator data components\n * @throws {Error} If authenticator data is too short or contains invalid data\n */\nfunction getAuthDataFromAuthentication(authData) {\n  // Validate minimum length for RP ID hash, flags, and counter\n  if (!authData || authData.byteLength < 37) {\n    throw new Error(\n      `Authenticator data was ${authData?.byteLength || \"invalid\"} bytes, expected at least 37 bytes`\n    );\n  }\n\n  const dataView = new DataView(authData, authData.byteOffset, authData.length);\n  let pointer = 0;\n\n  // Extract RP ID hash (32 bytes)\n  const rpIdHash = authData.slice(pointer, pointer + 32);\n  pointer += 32;\n\n  // Extract and parse flags byte\n  const flagsBuf = authData.slice(pointer, pointer + 1);\n  const flagsInt = new Uint8Array(flagsBuf)[0];\n  pointer += 1;\n\n  const flags = {\n    up: !!(flagsInt & 0x01), // User Present (bit 0)\n    uv: !!(flagsInt & 0x04), // User Verified (bit 2)\n    be: !!(flagsInt & 0x08), // Backup Eligible (bit 3)\n    bs: !!(flagsInt & 0x10), // Backup State (bit 4)\n    at: !!(flagsInt & 0x40), // Attested Credential Data Present (bit 6)\n    ed: !!(flagsInt & 0x80), // Extension Data Present (bit 7)\n    flagsInt\n  };\n\n  // Extract signature counter (4 bytes, big-endian)\n  const counterBuf = authData.slice(pointer, pointer + 4);\n  const counter = dataView.getUint32(pointer, false); // false = big-endian\n  pointer += 4;\n\n  // Parse optional attested credential data\n  const attestationResult = parseAttestedCredentialData(flags, authData, pointer);\n  pointer = attestationResult.newPointer;\n\n  // Parse optional extension data\n  const extensionsData = parseExtensionData(flags, authData, pointer);\n\n  return {\n    rpIdHash: base64FromBuffer(rpIdHash),\n    flagsBuf: base64FromBuffer(flagsBuf),\n    flags,\n    counter,\n    counterBuf: base64FromBuffer(counterBuf),\n    aaguid: attestationResult.aaguid,\n    credentialId: base64FromBuffer(attestationResult.credentialId),\n    credentialPublicKey: base64FromBuffer(attestationResult.credentialPublicKey),\n    extensionsData\n  };\n}\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Parses attested credential data from authenticator data when the AT flag is set.\n * \n * Attested credential data structure:\n * - AAGUID (16 bytes): Authenticator attestation GUID\n * - Credential ID Length (2 bytes): Length of credential ID (big-endian)\n * - Credential ID (variable): The credential identifier\n * - Credential Public Key (variable): COSE-encoded public key\n *\n * @param {Object} flags - Parsed flags from authenticator data\n * @param {ArrayBuffer} authData - Complete authenticator data buffer\n * @param {number} pointer - Current parsing position in the buffer\n * @returns {Object} Parsed credential data and updated pointer position\n */\nfunction parseAttestedCredentialData(flags, authData, pointer) {\n  // Return undefined values if attested credential data is not present\n  if (!flags.at) {\n    return {\n      aaguid: undefined,\n      credentialId: undefined,\n      credentialPublicKey: undefined,\n      newPointer: pointer\n    };\n  }\n\n  const dataView = new DataView(authData, authData.byteOffset, authData.length);\n\n  // Extract AAGUID (16 bytes)\n  const aaguid = authData.slice(pointer, pointer + 16);\n  pointer += 16;\n\n  // Extract credential ID length (2 bytes, big-endian)\n  const credentialIdLength = dataView.getUint16(pointer, false);\n  pointer += 2;\n\n  // Extract credential ID\n  const credentialId = authData.slice(pointer, pointer + credentialIdLength);\n  pointer += credentialIdLength;\n\n  // Extract credential public key (remaining data up to extensions)\n  // Note: In practice, public key length varies, but for this implementation\n  // we assume a fixed 77 bytes as per original code\n  const credentialPublicKey = authData.slice(pointer, pointer + 77);\n  pointer += 77;\n\n  return {\n    aaguid,\n    credentialId,\n    credentialPublicKey,\n    newPointer: pointer\n  };\n}\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Parses extension data from authenticator data when the ED flag is set.\n * \n * Extension data is CBOR-encoded and contains additional authenticator\n * information. The data extends from the current pointer to the end of\n * the authenticator data buffer.\n *\n * @param {Object} flags - Parsed flags from authenticator data\n * @param {ArrayBuffer} authData - Complete authenticator data buffer\n * @param {number} pointer - Current parsing position in the buffer\n * @returns {ArrayBuffer|undefined} Extension data buffer or undefined if not present\n */\nfunction parseExtensionData(flags, authData, pointer) {\n  // Return undefined if extension data is not present\n  if (!flags.ed) {\n    return undefined;\n  }\n\n  // Extension data spans from current pointer to end of authenticator data\n  return authData.slice(pointer);\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = getAuthenticationAuthData;\n\n// ------------------------------------------------------------------------------------------------","/**\n * @file Módulo para processar e extrair dados de uma credencial de registro WebAuthn.\n * @author Seu Nome <seu.email@example.com>\n * @version 1.0.0\n */\n\nconst cbor = require(\"cbor-x\");\nconst base64FromBuffer = require(\"../../utils/base64FromBuffer\");\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Analisa o buffer de dados do autenticador (authData) para extrair o ID da credencial e a chave pública.\n * A estrutura do buffer `authData` é rigorosamente definida pela especificação WebAuthn.\n * Esta função decodifica essa estrutura de bytes.\n * @see https://www.w3.org/TR/webauthn-2/#sctn-authenticator-data\n *\n * @private\n * @param {ArrayBuffer} attestationObjectBuffer - O buffer do objeto de atestado, que contém os dados do autenticador.\n * @returns {{credentialId: string, publicKeyObject: string}} Um objeto contendo o ID da credencial e a chave pública, ambos codificados em Base64.\n */\nfunction parseAuthenticatorData(attestationObjectBuffer) {\n  // 1. Decodifica o objeto de atestado do formato CBOR para acessar seus campos internos.\n  const attestationObject = cbor.decode(new Uint8Array(attestationObjectBuffer));\n  const { authData } = attestationObject;\n\n  // 2. Define constantes para os offsets e comprimentos dos campos na estrutura `authData`,\n  // conforme a especificação. Isso substitui \"números mágicos\" por valores claros e documentados.\n  const RP_ID_HASH_OFFSET = 0;\n  const RP_ID_HASH_LENGTH = 32;\n  const FLAGS_OFFSET = RP_ID_HASH_OFFSET + RP_ID_HASH_LENGTH; // 32\n  const FLAGS_LENGTH = 1;\n  const SIGN_COUNT_OFFSET = FLAGS_OFFSET + FLAGS_LENGTH; // 33\n  const SIGN_COUNT_LENGTH = 4;\n\n  // O `attestedCredentialData` é opcional e sua presença é indicada pelo bit 'AT' nas flags.\n  // Seu início é após os campos de cabeçalho.\n  const ATTESTED_CREDENTIAL_DATA_OFFSET = SIGN_COUNT_OFFSET + SIGN_COUNT_LENGTH; // 37\n  const AAGUID_LENGTH = 16;\n  const CREDENTIAL_ID_LENGTH_BYTES = 2;\n\n  const CREDENTIAL_ID_LENGTH_OFFSET = ATTESTED_CREDENTIAL_DATA_OFFSET + AAGUID_LENGTH; // 53\n  const CREDENTIAL_ID_OFFSET = CREDENTIAL_ID_LENGTH_OFFSET + CREDENTIAL_ID_LENGTH_BYTES; // 55\n\n  // 3. Extrai o comprimento do ID da credencial. Este é um inteiro de 2 bytes (Big Endian).\n  // Usamos um DataView para garantir a interpretação correta dos bytes.\n  const idLenBytes = authData.slice(\n    CREDENTIAL_ID_LENGTH_OFFSET,\n    CREDENTIAL_ID_OFFSET\n  );\n  const dataView = new DataView(idLenBytes.buffer);\n  const credentialIdLength = dataView.getUint16(0);\n\n  // 4. Extrai o ID da credencial e a chave pública usando os comprimentos e offsets calculados.\n  const credentialId = authData.slice(\n    CREDENTIAL_ID_OFFSET,\n    CREDENTIAL_ID_OFFSET + credentialIdLength\n  );\n  const publicKeyBytes = authData.slice(\n    CREDENTIAL_ID_OFFSET + credentialIdLength\n  );\n\n  // 5. Retorna os dados extraídos, codificados em Base64 para facilitar o transporte e armazenamento.\n  return {\n    credentialId: base64FromBuffer(credentialId.buffer),\n    publicKeyObject: base64FromBuffer(publicKeyBytes.buffer),\n  };\n}\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Extrai e formata os dados de autenticação de registro de uma credencial WebAuthn (`PublicKeyCredential`).\n * A função processa os vários `ArrayBuffer`s da credencial, convertendo-os para formatos úteis (como Base64)\n * e decodificando a estrutura de dados interna do autenticador.\n *\n * @param {PublicKeyCredential} credential - O objeto de credencial WebAuthn retornado pelo navegador após um registro bem-sucedido.\n * @returns {object} Um objeto estruturado contendo os dados de registro prontos para serem enviados a um servidor.\n * @throws {Error} Lança um erro se ocorrer um problema durante o processamento da credencial (ex: formato inválido).\n */\nfunction getRegistrationAuthData(credential) {\n  const response = credential.response;\n\n  // Analisa a estrutura de bytes do `attestationObject` para extrair dados internos.\n  const parsedAuthData = parseAuthenticatorData(response.attestationObject);\n\n  // Decodifica o `clientDataJSON` de ArrayBuffer para uma string UTF-8 legível.\n  const clientDataJSONDecoded = new TextDecoder().decode(\n    response.clientDataJSON\n  );\n\n  // Constrói o objeto de retorno final com todos os dados relevantes convertidos para Base64.\n  // Isso prepara os dados para serem serializados (ex: como JSON) e enviados para o servidor.\n  return {\n    // Dados de nível superior da credencial\n    rawId: base64FromBuffer(credential.rawId),\n    id: credential.id,\n    type: credential.type,\n    authenticatorAttachment: credential.authenticatorAttachment,\n    clientExtensionResults: credential.getClientExtensionResults(),\n\n    // Dados extraídos e analisados do `authData`\n    authData: parsedAuthData,\n\n    // Dados da resposta do autenticador, convertidos para formatos apropriados\n    response: {\n      attestationObject: base64FromBuffer(response.attestationObject),\n      authenticatorData: base64FromBuffer(response.getAuthenticatorData()),\n      clientDataJSON: base64FromBuffer(response.clientDataJSON),\n      clientDataJSONDecoded,\n      transports: response.getTransports() || [],\n      publicKey: base64FromBuffer(response.getPublicKey()),\n      publicKeyAlgorithm: response.getPublicKeyAlgorithm(),\n    },\n  };\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = getRegistrationAuthData;\n\n// ------------------------------------------------------------------------------------------------","/**\n * @file Módulo para iniciar o processo de autenticação WebAuthn no navegador.\n * @author Seu Nome <seu.email@example.com>\n * @version 1.0.0\n */\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Valida se o objeto de propriedades fornecido contém todos os campos necessários\n * para uma chamada `navigator.credentials.get()`. Lança um erro se a validação falhar.\n *\n * @private\n * @param {PublicKeyCredentialRequestOptions} props - O objeto de opções a ser validado.\n * @throws {Error} Lança um erro descritivo se um campo obrigatório estiver ausente ou for inválido.\n */\nfunction validateAuthenticationOptions(props) {\n  // Valida a presença do 'challenge', que é essencial para prevenir ataques de repetição.\n  if (!props.challenge) {\n    throw new Error(\"No challenge provided\");\n  }\n\n  // Valida a lista de credenciais permitidas. O autenticador usará esta lista\n  // para encontrar uma credencial correspondente que o usuário possa usar para assinar.\n  if (\n    !props.allowCredentials ||\n    !Array.isArray(props.allowCredentials) ||\n    props.allowCredentials.length === 0\n  ) {\n    throw new Error(\"No allowCredentials provided\");\n  }\n\n  // Itera sobre cada credencial permitida para garantir que sua estrutura está correta.\n  for (const cred of props.allowCredentials) {\n    if (!cred.id) {\n      throw new Error(\n        \"No allowCredentials (id) provided - The credential ID registered on the registration phase\"\n      );\n    }\n    if (!cred.type) {\n      throw new Error(\"No allowCredentials (type) provided\");\n    }\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Inicia o processo de autenticação WebAuthn no navegador e retorna uma asserção de autenticação.\n * Esta função é um wrapper para `navigator.credentials.get()`, adicionando validações\n * e suporte a um callback opcional para retrocompatibilidade.\n *\n * @param {PublicKeyCredentialRequestOptions} props - O objeto contendo as opções para solicitar uma asserção de autenticação.\n * @param {Function} [callback] - Função de callback opcional que será chamada com a asserção obtida como argumento.\n * @returns {Promise<PublicKeyCredential|string>} Uma promessa que resolve para o objeto `PublicKeyCredential` (a asserção),\n * ou para a string \"WebAuthn not supported\" se a API não estiver disponível.\n * @throws {Error} Lança um erro se ocorrer um problema durante o processo de autenticação (ex: validação falha, usuário cancela).\n */\nasync function getWebAuthnAuthenticationAssertion(props, callback) {\n  // 1. Verificação de Suporte da API\n  // Garante que a API WebAuthn para obter credenciais está disponível no navegador.\n  if (typeof navigator?.credentials?.get !== \"function\") {\n    return \"WebAuthn not supported\";\n  }\n\n  // 2. Validação dos Parâmetros\n  // Executa uma verificação rigorosa das opções para garantir que a chamada à API será bem-sucedida.\n  validateAuthenticationOptions(props);\n\n  // 3. Obtenção da Asserção\n  // Invoca a API nativa do navegador para solicitar uma asserção de autenticação.\n  // O `await` pausa a execução até que o usuário prove sua identidade ao autenticador.\n  const assertion = await navigator.credentials.get({\n    publicKey: props,\n  });\n\n  // 4. Execução do Callback (Opcional)\n  // Se um callback válido for fornecido, ele é invocado com a asserção.\n  if (typeof callback === \"function\") {\n    return callback(assertion);\n  }\n\n  // 5. Retorno da Promessa\n  // Se nenhum callback for usado, a função retorna a asserção, resolvendo a promessa.\n  return assertion;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = getWebAuthnAuthenticationAssertion;\n\n// ------------------------------------------------------------------------------------------------\n","/**\n * @file Módulo para iniciar o processo de registro WebAuthn no navegador.\n * @author Seu Nome <seu.email@example.com>\n * @version 1.0.0\n */\n\n// ------------------------------------------------------------------------------------------------\n/**\n * Valida se o objeto de propriedades fornecido contém todos os campos necessários\n * para uma chamada `navigator.credentials.create()`. Lança um erro se a validação falhar.\n *\n * @private\n * @param {PublicKeyCredentialCreationOptions} props - O objeto de opções a ser validado.\n * @throws {Error} Lança um erro descritivo se um campo obrigatório estiver ausente ou for inválido.\n */\nfunction validateCreationOptions(props) {\n  // Valida a presença do 'challenge', que é essencial para a segurança do protocolo.\n  if (!props.challenge) {\n    throw new Error(\"No challenge provided\");\n  }\n\n  // Valida as informações da Relying Party (RP).\n  if (!props.rp) {\n    throw new Error(\"No RP (Relying Party) provided\");\n  }\n  if (!props.rp.name) {\n    throw new Error(\"No RP (Relying Party) name provided\");\n  }\n\n  // Valida as informações do usuário.\n  if (!props.user) {\n    throw new Error(\"No user provided\");\n  }\n  if (!props.user.id) {\n    throw new Error(\"No user id provided\");\n  }\n  if (!props.user.displayName) {\n    throw new Error(\"No user display name provided\");\n  }\n  if (!props.user.name) {\n    throw new Error(\"No user name provided\");\n  }\n\n  // Valida os parâmetros dos tipos de credenciais de chave pública aceitos.\n  // Deve ser um array não vazio.\n  if (\n    !props.pubKeyCredParams ||\n    !Array.isArray(props.pubKeyCredParams) ||\n    props.pubKeyCredParams.length === 0\n  ) {\n    throw new Error(\"No pubKeyCredParams provided\");\n  }\n\n  // Itera sobre cada parâmetro para garantir que a estrutura está correta.\n  for (const param of props.pubKeyCredParams) {\n    if (!param.hasOwnProperty(\"alg\")) {\n      throw new Error(\"No pubKeyCredParams.alg provided\");\n    }\n    if (!param.hasOwnProperty(\"type\")) {\n      throw new Error(\"No pubKeyCredParams.type provided\");\n    }\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n/**\n * Inicia o processo de registro WebAuthn no navegador e retorna uma nova credencial.\n * Esta função é um wrapper para `navigator.credentials.create()`, adicionando validações\n * e suporte a um callback opcional.\n *\n * @param {PublicKeyCredentialCreationOptions} [props={}] - O objeto contendo as opções para a criação de uma nova credencial de chave pública.\n * @param {Function} [callback] - Função de callback opcional que será chamada com a credencial criada como argumento.\n * @returns {Promise<PublicKeyCredential|string>} Uma promessa que resolve para o objeto `PublicKeyCredential` criado,\n * ou para a string \"WebAuthn not supported\" se a API não estiver disponível no navegador.\n * @throws {Error} Lança um erro se ocorrer um problema durante o processo de criação da credencial (ex: validação falha, cancelamento do usuário).\n */\nasync function getWebAuthnRegistrationCredential(props = {}, callback) {\n  // 1. Verificação de Suporte da API\n  // Garante que a API WebAuthn está disponível no objeto `navigator` antes de prosseguir.\n  // Esta função destina-se apenas a ambientes de navegador.\n  if (typeof navigator?.credentials?.create !== \"function\") {\n    return \"WebAuthn not supported\";\n  }\n\n  // 2. Validação dos Parâmetros\n  // Executa uma verificação rigorosa das opções fornecidas para garantir que a chamada à API\n  // seja bem-sucedida e evitar erros inesperados.\n  validateCreationOptions(props);\n\n  // 3. Criação da Credencial\n  // Invoca a API nativa do navegador para solicitar a criação de uma nova credencial.\n  // O `await` pausa a execução até que o usuário interaja com o prompt (ex: usando biometria)\n  // e a promessa seja resolvida ou rejeitada.\n  const credential = await navigator.credentials.create({\n    publicKey: props,\n  });\n\n  // 4. Execução do Callback (Opcional)\n  // Se um callback foi fornecido e é uma função válida, ele é invocado com a credencial.\n  // Este padrão é mantido para garantir a retrocompatibilidade com a assinatura original.\n  if (typeof callback === \"function\") {\n    return callback(credential);\n  }\n\n  // 5. Retorno da Promessa\n  // Se nenhum callback for usado, a função retorna a credencial, resolvendo a promessa.\n  return credential;\n}\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Exporta a função para uso em módulos CommonJS.\n */\nmodule.exports = getWebAuthnRegistrationCredential;\n\n// ------------------------------------------------------------------------------------------------\n","/**\n * @file Utilitário para decodificar Base64 para um ArrayBuffer.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.1.0\n */\n\n/**\n * @summary Converte uma string Base64 em um ArrayBuffer, compatível com ambos ambientes.\n *\n * @description\n * Esta função decodifica uma string Base64 para sua representação binária em um ArrayBuffer.\n * A implementação é cross-environment, garantindo um comportamento consistente e\n * retornando sempre um `ArrayBuffer` tanto no Node.js quanto em navegadores.\n *\n * @param {string} [base64String=\"\"] - A string em formato Base64 a ser decodificada.\n *\n * @returns {ArrayBuffer} O `ArrayBuffer` decodificado. Retorna um `ArrayBuffer` vazio\n * (de 0 bytes) se a entrada for inválida, vazia ou se ocorrer um erro de decodificação.\n *\n * @example\n * const b64 = 'AAECAwQFBgcICQoLDA0ODw=='; // Bytes 0-15\n * const buffer = base64ToBuffer(b64);\n *\n * // `buffer` é sempre um ArrayBuffer.\n * const view = new Uint8Array(buffer);\n * console.log(view[10]); // 10\n */\nfunction base64ToBuffer(base64String = \"\") {\n  // Valida a entrada para garantir que é uma string.\n  if (typeof base64String !== 'string' || base64String.length === 0) {\n    // Retorna um ArrayBuffer vazio para entradas inválidas, conforme esperado pelos testes.\n    return new ArrayBuffer(0);\n  }\n\n  try {\n    // **Ambiente Node.js:**\n    if (typeof window === 'undefined') {\n      // Cria um Buffer do Node.js a partir da string Base64.\n      const nodeBuffer = Buffer.from(base64String, 'base64');\n\n      // Extrai o ArrayBuffer subjacente do Buffer do Node.js para manter a consistência do retorno.\n      // O `slice` é crucial para garantir que obtenhamos a porção exata da memória\n      // que corresponde a este buffer, já que o Node.js pode reutilizar pools de memória maiores.\n      return nodeBuffer.buffer.slice(\n        nodeBuffer.byteOffset,\n        nodeBuffer.byteOffset + nodeBuffer.byteLength\n      );\n    }\n\n    // **Ambiente do Navegador:**\n    // Decodifica a string Base64 para uma \"string binária\".\n    const binaryString = window.atob(base64String);\n    const len = binaryString.length;\n\n    // Cria um Uint8Array (uma visão de dados sobre um ArrayBuffer) com o tamanho necessário.\n    const bytes = new Uint8Array(len);\n\n    // Popula o array de bytes com os valores numéricos correspondentes a cada caractere.\n    for (let i = 0; i < len; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n\n    // Retorna o `ArrayBuffer` subjacente, que contém os dados binários brutos.\n    return bytes.buffer;\n\n  } catch (error) {\n    // Retorna um ArrayBuffer vazio em caso de erro\n    return new ArrayBuffer(0);\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = base64ToBuffer;","/**\n * @file Utilitário para comparação binária de ArrayBuffers.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.0.0\n */\n\n/**\n * @summary Compara dois ArrayBuffers para verificar se contêm os mesmos bytes.\n *\n * @description\n * Realiza uma comparação binária eficiente de dois ArrayBuffers. A função é otimizada\n * para diferentes ambientes: no Node.js, utiliza o método nativo e rápido `Buffer.equals()`,\n * enquanto no navegador, emprega uma técnica de comparação por blocos para acelerar o processo.\n *\n * @param {ArrayBuffer} buffer1 - O primeiro ArrayBuffer para a comparação.\n * @param {ArrayBuffer} buffer2 - O segundo ArrayBuffer para a comparação.\n *\n * @returns {boolean} Retorna `true` se os buffers forem idênticos, caso contrário, `false`.\n *\n * @example\n * const buf1 = new Uint8Array([1, 2, 3, 4, 5]).buffer;\n * const buf2 = new Uint8Array([1, 2, 3, 4, 5]).buffer;\n * const buf3 = new Uint8Array([1, 2, 3, 4, 9]).buffer;\n *\n * console.log(bufferCompare(buf1, buf2)); // true\n * console.log(bufferCompare(buf1, buf3)); // false\n */\nfunction bufferCompare(buffer1, buffer2) {\n  // 1. Validação de tipo: garante que ambos os argumentos são instâncias de ArrayBuffer.\n  if (!(buffer1 instanceof ArrayBuffer) || !(buffer2 instanceof ArrayBuffer)) {\n    return false;\n  }\n\n  // 2. Verificação de tamanho: a forma mais rápida de identificar buffers diferentes.\n  // Se os tamanhos não batem, é impossível que sejam iguais.\n  if (buffer1.byteLength !== buffer2.byteLength) {\n    return false;\n  }\n\n  // **Otimização para ambiente Node.js:**\n  if (typeof window === 'undefined') {\n    // Converte os ArrayBuffers para Buffers do Node.js e usa o método `equals`,\n    // que é uma implementação nativa e extremamente performática.\n    const buf1 = Buffer.from(buffer1);\n    const buf2 = Buffer.from(buffer2);\n    return buf1.equals(buf2);\n  }\n\n  // **Otimização para ambiente do Navegador:**\n  // Em vez de comparar byte a byte, compara em blocos maiores (4 bytes ou 32 bits por vez).\n  const view1_32 = new Uint32Array(buffer1);\n  const view2_32 = new Uint32Array(buffer2);\n\n  // Compara a maior parte do buffer em blocos de 32 bits.\n  for (let i = 0; i < view1_32.length; i++) {\n    if (view1_32[i] !== view2_32[i]) {\n      return false;\n    }\n  }\n\n  // Calcula onde a comparação de 32 bits parou para checar os bytes restantes.\n  const remainingOffset = view1_32.length * 4;\n\n  // Compara os bytes restantes (caso o tamanho do buffer não seja múltiplo de 4).\n  const view1_8 = new Uint8Array(buffer1);\n  const view2_8 = new Uint8Array(buffer2);\n  for (let i = remainingOffset; i < view1_8.length; i++) {\n    if (view1_8[i] !== view2_8[i]) {\n      return false;\n    }\n  }\n\n  // Se todas as comparações passaram, os buffers são idênticos.\n  return true;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = bufferCompare;","/**\n * @file Utilitário para converter uma string para um buffer de bytes.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.0.0\n */\n\n/**\n * @summary Converte uma string para um buffer de bytes (`Uint8Array`).\n *\n * @description\n * Esta função converte uma string de texto para sua representação binária, retornando um `Uint8Array`.\n * A função é universalmente compatível, usando `Buffer` no Node.js e `TextEncoder` no navegador.\n *\n * O objeto `Buffer` do Node.js é uma subclasse de `Uint8Array`, então o tipo de retorno\n * é consistente e interoperável entre os dois ambientes.\n *\n * @param {string} txtString - A string a ser convertida para um buffer.\n * @param {BufferEncoding} [encoding=\"utf-8\"] - **(Apenas Node.js)** A codificação a ser usada.\n * **No ambiente do navegador, este parâmetro é ignorado e a codificação será sempre UTF-8**,\n * devido a limitações da API `TextEncoder`.\n *\n * @returns {Uint8Array | null} Um `Uint8Array` representando os bytes da string.\n * Retorna `null` se a entrada não for uma string.\n *\n * @example\n * const buffer = bufferFromString('Olá, Mundo! 👋');\n *\n * // `buffer` será um `Buffer` no Node.js e um `Uint8Array` no navegador,\n * // mas ambos se comportam como um Uint8Array.\n * console.log(buffer.length); // 17\n * console.log(buffer[0]); // 79 ('O')\n * console.log(buffer[12]); // 240 (primeiro byte do emoji 👋)\n */\nfunction bufferFromString(txtString, encoding = \"utf-8\") {\n  // 1. Validação de tipo: garante que a entrada é uma string.\n  if (typeof txtString !== 'string') {\n    return null;\n  }\n\n  // **Ambiente Node.js:**\n  if (typeof window === 'undefined') {\n    // `Buffer.from` é a forma otimizada de criar um buffer no Node.js e\n    // respeita o parâmetro `encoding`. O Buffer resultante já é uma instância de Uint8Array.\n    return Buffer.from(txtString, encoding);\n  }\n\n  // **Ambiente do Navegador:**\n  // `TextEncoder` é a API padrão da web para converter strings em bytes.\n  // O método `.encode()` retorna diretamente um `Uint8Array`.\n  return new TextEncoder().encode(txtString);\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = bufferFromString;","/**\n * Retrieves the appropriate cryptographic module for the current environment.\n *\n * This function performs environment detection to determine whether the code is executing\n * in a browser or Node.js environment, then returns the corresponding cryptographic module.\n * The function prioritizes browser environments when `window` is available, falling back\n * to Node.js crypto module when running in server-side environments.\n *\n * @returns {Crypto|Object} The cryptographic module appropriate for the current environment:\n *                          - Browser: Returns `window.crypto` (Web Crypto API)\n *                          - Node.js: Returns the native `crypto` module\n *\n * @throws {Error} When cryptographic capabilities are unavailable:\n *                 - Browser: When `window.crypto` is undefined (typically HTTP contexts)\n *                 - Node.js: When the `crypto` module cannot be loaded\n *\n * @example\n * // Browser environment - Web Crypto API usage\n * const crypto = getCrypto();\n * const encoder = new TextEncoder();\n * const data = encoder.encode('hello world');\n * crypto.subtle.digest('SHA-256', data).then(hash => {\n *   console.log(new Uint8Array(hash));\n * });\n *\n * @example\n * // Node.js environment - crypto module usage\n * const crypto = getCrypto();\n * const hash = crypto.createHash('sha256')\n *   .update('hello world', 'utf8')\n *   .digest('hex');\n * console.log(hash);\n *\n * @example\n * // Universal usage pattern with error handling\n * try {\n *   const crypto = getCrypto();\n *   // Use crypto based on environment capabilities\n * } catch (error) {\n *   console.error('Cryptographic module unavailable:', error.message);\n * }\n */\nfunction getCrypto() {\n  // Check for browser environment by testing window object availability\n  if (typeof window !== 'undefined') {\n    // Validate that Web Crypto API is available in the browser context\n    if (!window.crypto) {\n      throw new Error(\n        'window.crypto is not defined - Only works with HTTPS Protocol'\n      );\n    }\n    \n    // Return browser's Web Crypto API\n    return window.crypto;\n  }\n  \n  // Server-side environment detected - load Node.js crypto module\n  // Using direct require since we're already in Node.js context\n  return require('crypto');\n}\n\n// ------------------------------------------------------------------------------------------------\n\n// Export for CommonJS compatibility (Node.js)\nmodule.exports = getCrypto;","/**\n * @file Módulo para validação de RPID (Relying Party ID) usando dependências específicas.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.0.0\n */\n\n// Importa as utilidades necessárias de outros módulos.\n// A responsabilidade pela implementação de baixo nível é delegada a essas funções.\nconst base64ToBuffer = require(\"../../utils/base64ToBuffer\");\nconst bufferCompare = require(\"../../utils/bufferCompare\");\nconst bufferFromString = require(\"../../utils/bufferFromString\");\nconst getCrypto = require(\"../../crypto/getCrypto.js\");\n\n// ------------------------------------------------------------------------------------------------\n/**\n * Valida de forma assíncrona que o RPID original corresponde ao RPID de verificação após a aplicação de um hash.\n * Esta função orquestra chamadas a utilitários criptográficos e de buffer para realizar a validação.\n *\n * @param {string} originalRPID - O identificador RPID original (string UTF-8) a ser validado.\n * @param {string} verifyRPID - A representação em Base64 do RPID a ser verificado. Espera-se que contenha o hash do RPID original.\n * @param {string} [algorithm=\"SHA-256\"] - O algoritmo de hash a ser usado. Deve ser compatível com a implementação de `getCrypto`.\n * @returns {Promise<boolean>} Retorna uma promessa que resolve para `true` se os RPIDs corresponderem.\n * @throws {Error} Lança um erro se `originalRPID` ou `verifyRPID` não forem fornecidos, ou se os RPIDs não corresponderem.\n */\nasync function validateRPID(originalRPID, verifyRPID, algorithm = \"SHA-256\") {\n  // 1. Validação dos Parâmetros de Entrada\n  // Garante que os argumentos essenciais foram fornecidos antes de qualquer processamento.\n  if (!originalRPID || typeof originalRPID !== \"string\") {\n    throw new Error(\"originalRPID is required\");\n  }\n  originalRPID = originalRPID.trim();\n  if (!originalRPID) {\n    throw new Error(\"originalRPID is required\");\n  }\n\n  if (!verifyRPID || typeof verifyRPID !== \"string\") {\n    throw new Error(\"verifyRPID is required\");\n  }\n\n  verifyRPID = verifyRPID.trim();\n  if (!verifyRPID) {\n    throw new Error(\"verifyRPID is required\");\n  }\n\n  // 2. Preparação para o Hashing\n  // Obtém a interface de criptografia do ambiente (Node.js ou navegador) através do utilitário.\n  const crypto = getCrypto();\n  // Converte a string do RPID original em um formato de buffer, que é o tipo de entrada\n  // esperado pela API de criptografia para a operação de digest.\n  const originalRPIDBuffer = bufferFromString(originalRPID);\n\n  // 3. Geração do Hash\n  // Calcula o hash do buffer do RPID original usando o algoritmo especificado.\n  // A operação `digest` é assíncrona e retorna o hash resultante (geralmente como um ArrayBuffer).\n  const digestOfOriginalRPID = await crypto.subtle.digest(\n    algorithm,\n    originalRPIDBuffer\n  );\n\n  // 4. Decodificação e Extração do Hash de Verificação\n  // Decodifica a string base64 `verifyRPID` para seu formato de buffer correspondente.\n  const verifyRPIDBuffer = base64ToBuffer(verifyRPID);\n  // Extrai os primeiros 32 bytes do buffer decodificado. Este segmento é assumido\n  // como sendo o hash a ser comparado (consistente com o tamanho de um hash SHA-256).\n  const digestToVerify = verifyRPIDBuffer.slice(0, 32);\n\n  // 5. Comparação Segura\n  // Compara o hash recém-gerado com o hash extraído do parâmetro de verificação.\n  // É crucial que `bufferCompare` implemente uma comparação segura contra ataques de temporização.\n  const areDigestsEqual = bufferCompare(digestOfOriginalRPID, digestToVerify);\n\n  if (!areDigestsEqual) {\n    // Se a comparação falhar, lança um erro específico para indicar a incompatibilidade.\n    throw new Error(\n      `Registration RPID does not match the authentication RPID.`\n    );\n  }\n\n  // Se a comparação for bem-sucedida, a validação está completa.\n  return true;\n}\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Exporta a função `validateRPID` para uso em módulos CommonJS (padrão do Node.js).\n */\nmodule.exports = validateRPID;\n\n// ------------------------------------------------------------------------------------------------\n","const getCrypto = require('./getCrypto');\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Verifies digital signatures using the Web Crypto API in a cross-platform manner.\n *\n * This function provides a unified interface for cryptographic signature verification\n * across different environments (browser and Node.js). It leverages the Web Crypto API's\n * subtle.verify method to perform secure signature validation using various cryptographic\n * algorithms including RSA-PSS, RSA-PKCS1-v1_5, ECDSA, and HMAC.\n *\n * The verification process involves comparing a provided signature against the expected\n * signature for given data using the specified public key and algorithm. This is essential\n * for ensuring data integrity and authenticity in cryptographic workflows.\n *\n * @param {Object|string} algorithm - Algorithm specification for signature verification:\n *                          - Object: Detailed parameters (e.g., { name: 'RSA-PSS', saltLength: 32 })\n *                          - String: Simple algorithm name (e.g., 'RSA-PSS', 'ECDSA')\n *                          Common algorithms:\n *                          - RSA-PSS: RSA with PSS padding\n *                          - RSA-PKCS1-v1_5: RSA with PKCS#1 v1.5 padding\n *                          - ECDSA: Elliptic Curve Digital Signature Algorithm\n *                          - HMAC: Hash-based Message Authentication Code\n *\n * @param {CryptoKey} key - The cryptographic key used for signature verification:\n *                          - For asymmetric algorithms: Must be a public key with 'verify' usage\n *                          - For symmetric algorithms (HMAC): Can be the same key used for signing\n *                          - Must be compatible with the specified algorithm\n *                          - Key must have been imported with 'verify' in keyUsages array\n *\n * @param {BufferSource|ArrayBuffer|Uint8Array} signature - The digital signature to verify:\n *                          - Binary signature data as BufferSource (ArrayBuffer, Uint8Array, etc.)\n *                          - Must be in the format produced by the corresponding sign operation\n *                          - Length and format depend on the algorithm used:\n *                            - RSA signatures: typically 256 bytes (2048-bit) or 512 bytes (4096-bit)\n *                            - ECDSA signatures: varies by curve (64 bytes for P-256, 96 bytes for P-384)\n *                            - HMAC signatures: depends on hash function (32 bytes for SHA-256)\n *\n * @param {BufferSource|ArrayBuffer|Uint8Array} data - The original data that was signed:\n *                          - Binary data as BufferSource that needs to be verified against signature\n *                          - Must be exactly the same data used during the signing process\n *                          - Any modification to this data will cause verification to fail\n *                          - For text data, ensure consistent encoding (typically UTF-8)\n *\n * @returns {Promise<boolean>} Promise resolving to verification result:\n *                          - true: Signature is valid and data integrity is confirmed\n *                          - false: Signature is invalid, data may have been tampered with\n *                          Note: This method never rejects for invalid signatures, only for\n *                          operational errors (invalid keys, unsupported algorithms, etc.)\n *\n * @throws {Error} Throws an error when:\n *                 - Crypto module is unavailable in the current environment\n *                 - Invalid algorithm specification or unsupported algorithm\n *                 - Key is inappropriate for the algorithm or missing 'verify' usage\n *                 - Signature or data parameters are malformed or incompatible\n *                 - Environment doesn't support the specified cryptographic operations\n *\n * @example\n * // Verify RSA-PSS signature\n * const publicKey = await importCryptoKey(/* RSA public key parameters *);\n * const signatureBytes = new Uint8Array([...]); // RSA signature\n * const originalData = new TextEncoder().encode('Hello, World!');\n * \n * const isValid = await verifySignature(\n *   {\n *     name: 'RSA-PSS',\n *     saltLength: 32\n *   },\n *   publicKey,\n *   signatureBytes,\n *   originalData\n * );\n * console.log('Signature valid:', isValid);\n *\n * @example\n * // Verify ECDSA signature with P-256 curve\n * const ecdsaKey = await importCryptoKey(/* ECDSA public key parameters *);\n * const ecdsaSignature = new Uint8Array([...]); // ECDSA signature (64 bytes for P-256)\n * const messageData = new Uint8Array([...]); // Original message\n * \n * const result = await verifySignature(\n *   { name: 'ECDSA', hash: 'SHA-256' },\n *   ecdsaKey,\n *   ecdsaSignature,\n *   messageData\n * );\n *\n * @example\n * // Verify HMAC signature (symmetric)\n * const hmacKey = await importCryptoKey(/* HMAC key parameters *);\n * const hmacSignature = new Uint8Array(32); // HMAC-SHA256 signature\n * const payload = new TextEncoder().encode('{\"user\": \"john\", \"action\": \"login\"}');\n * \n * try {\n *   const verified = await verifySignature(\n *     { name: 'HMAC', hash: 'SHA-256' },\n *     hmacKey,\n *     hmacSignature,\n *     payload\n *   );\n *   if (verified) {\n *     console.log('Message authenticated successfully');\n *   } else {\n *     console.warn('Message authentication failed - possible tampering');\n *   }\n * } catch (error) {\n *   console.error('Verification error:', error.message);\n * }\n */\nasync function verifySignature(algorithm, key, signature, data) {\n  // Retrieve the appropriate crypto module for the current environment\n  const crypto = getCrypto();\n  \n  // Perform signature verification using the Web Crypto API\n  // The subtle.verify method handles the cryptographic verification process\n  // and returns a boolean indicating signature validity\n  return await crypto.subtle.verify(algorithm, key, signature, data);\n}\n\n// ------------------------------------------------------------------------------------------------\n\n// Export for CommonJS compatibility (Node.js)\nmodule.exports = verifySignature;","const getCrypto = require('./getCrypto.js');\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Imports cryptographic keys using the Web Crypto API in a cross-platform manner.\n *\n * This function provides a unified interface for importing cryptographic keys across\n * different environments (browser and Node.js). It handles the environment-specific\n * crypto module retrieval and delegates the actual key import operation to the\n * appropriate Web Crypto API implementation.\n *\n * The function supports all standard key formats and algorithms supported by the\n * Web Crypto API, including RSA, ECDSA, ECDH, AES, and HMAC keys.\n *\n * @param {string} format - The data format of the key to import. Supported values:\n *                          - 'raw': Raw key data (typically for symmetric keys)\n *                          - 'spki': SubjectPublicKeyInfo format (for public keys)\n *                          - 'pkcs8': PKCS #8 format (for private keys)\n *                          - 'jwk': JSON Web Key format\n *\n * @param {BufferSource|ArrayBuffer|Uint8Array|Object} keyData - The key material to import:\n *                          - For 'raw', 'spki', 'pkcs8': BufferSource (ArrayBuffer, Uint8Array, etc.)\n *                          - For 'jwk': JavaScript object representing the JSON Web Key\n *\n * @param {Object|string} algorithm - Algorithm specification for the key:\n *                          - Object: Detailed algorithm parameters (e.g., { name: 'RSA-PSS', hash: 'SHA-256' })\n *                          - String: Simple algorithm name (e.g., 'AES-GCM', 'RSA-OAEP')\n *\n * @param {boolean} extractable - Key extractability flag:\n *                          - true: Key can be exported using crypto.subtle.exportKey()\n *                          - false: Key cannot be extracted (more secure for sensitive keys)\n *\n * @param {string[]} keyUsages - Array of permitted key operations:\n *                          - 'encrypt', 'decrypt': For encryption/decryption operations\n *                          - 'sign', 'verify': For digital signature operations\n *                          - 'deriveKey', 'deriveBits': For key derivation operations\n *                          - 'wrapKey', 'unwrapKey': For key wrapping operations\n *\n * @returns {Promise<CryptoKey>} Promise resolving to the imported CryptoKey object.\n *                          The CryptoKey can be used with other Web Crypto API methods\n *                          for cryptographic operations based on the specified keyUsages.\n *\n * @throws {Error} Throws an error if:\n *                 - The crypto module is unavailable in the current environment\n *                 - Invalid key format or algorithm specification\n *                 - Key data is malformed or incompatible with the specified format\n *                 - Requested key usages are incompatible with the algorithm\n *                 - Environment doesn't support the specified algorithm\n *\n * @example\n * // Import RSA public key from SPKI format\n * const publicKeyData = new Uint8Array([...]); // DER-encoded SPKI data\n * const publicKey = await importCryptoKey(\n *   'spki',\n *   publicKeyData,\n *   {\n *     name: 'RSA-OAEP',\n *     hash: 'SHA-256'\n *   },\n *   false,\n *   ['encrypt']\n * );\n *\n * @example\n * // Import AES symmetric key from raw bytes\n * const keyBytes = crypto.getRandomValues(new Uint8Array(32)); // 256-bit key\n * const aesKey = await importCryptoKey(\n *   'raw',\n *   keyBytes,\n *   { name: 'AES-GCM' },\n *   true,\n *   ['encrypt', 'decrypt']\n * );\n *\n * @example\n * // Import key from JSON Web Key format\n * const jwkData = {\n *   kty: 'RSA',\n *   use: 'sig',\n *   n: '...', // base64url-encoded modulus\n *   e: 'AQAB', // base64url-encoded exponent\n *   // ... other JWK properties\n * };\n * const rsaKey = await importCryptoKey(\n *   'jwk',\n *   jwkData,\n *   { name: 'RSA-PSS', hash: 'SHA-256' },\n *   false,\n *   ['verify']\n * );\n */\nasync function importCryptoKey(format, keyData, algorithm, extractable, keyUsages) {\n  // Retrieve the appropriate crypto module for the current environment\n  const crypto = getCrypto();\n  \n  // Delegate key import operation to the Web Crypto API\n  // The subtle.importKey method handles the actual cryptographic key parsing and validation\n  return await crypto.subtle.importKey(\n    format,\n    keyData,\n    algorithm,\n    extractable,\n    keyUsages\n  );\n}\n\n// ------------------------------------------------------------------------------------------------\n\n// Export for CommonJS compatibility (Node.js)\nmodule.exports = importCryptoKey;","/**\n * @fileoverview Fornece uma função para verificar se um valor é um número finito.\n */\n\n/**\n * Verifica se um valor fornecido é um número finito.\n *\n * @summary Verifica se um valor é um número real e finito.\n * @description Esta função determina se o valor fornecido é do tipo `number` e não é\n * `NaN`, `Infinity` ou `-Infinity`. Diferente de outras verificações como `!isNaN()`,\n * esta função não tenta converter a entrada para um número, sendo mais rigorosa e segura.\n *\n * @param {*} value - O valor a ser verificado.\n * @returns {boolean} Retorna `true` se o valor for um número finito; caso contrário, `false`.\n * @example\n * // Casos verdadeiros\n * isNumber(123);      // true\n * isNumber(-1.23);    // true\n * isNumber(0);        // true\n *\n * // Casos falsos\n * isNumber(Infinity); // false\n * isNumber(NaN);      // false\n * isNumber('123');    // false (não converte string)\n * isNumber(null);     // false\n * isNumber({});       // false\n */\nfunction isNumber(value) {\n  // A função estática Number.isFinite() já realiza as três verificações do código\n  // original de forma nativa:\n  // 1. Garante que o tipo seja 'number'.\n  // 2. Garante que não seja NaN.\n  // 3. Garante que não seja Infinity ou -Infinity.\n  return Number.isFinite(value);\n}\n\n// ------------------------------------------------------------------------------------------------\nmodule.exports = isNumber;\n// ------------------------------------------------------------------------------------------------","/**\n * @file Utilitário cross-environment para decodificação de Base64.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.0.0\n */\n\n/**\n * @summary Decodifica uma string em Base64 para uma string de texto UTF-8.\n *\n * @description\n * Esta função fornece uma maneira robusta e compatível com múltiplos ambientes (Node.js e navegadores)\n * para decodificar uma string Base64. Ela detecta automaticamente o ambiente de execução e utiliza\n * as APIs nativas mais apropriadas para garantir a máxima performance e corretude.\n *\n * A implementação lida corretamente com caracteres multi-byte (UTF-8), como acentos e emojis,\n * que são frequentemente corrompidos pela função `atob()` nativa do navegador.\n *\n * @param {string} [text=\"\"] - A string em formato Base64 a ser decodificada.\n *\n * @returns {string} A string decodificada em UTF-8. Retorna uma string vazia se a entrada\n * for inválida, vazia ou se ocorrer um erro durante a decodificação.\n *\n * @example\n * // Decodificando texto ASCII simples\n * const hello = base64From('SGVsbG8gV29ybGQh');\n * console.log(hello); // \"Hello World!\"\n *\n * // Decodificando texto com caracteres UTF-8 (acentos e símbolos)\n * const complex = base64From('U3VjZXNzbyEg4pyT');\n * console.log(complex); // \"Sucesso! ✓\"\n */\nfunction base64From(text = \"\") {\n  // Valida a entrada para garantir que é uma string não vazia.\n  if (typeof text !== \"string\" || text.length === 0) {\n    return \"\";\n  }\n\n  try {\n    // A maneira padrão de verificar se o código está rodando fora de um navegador (ex: Node.js).\n    if (typeof window === \"undefined\") {\n      // **Ambiente Node.js:**\n      // Utiliza a classe `Buffer`, que é altamente otimizada e a forma canônica\n      // de lidar com dados binários e encodings no Node.js.\n      return Buffer.from(text, \"base64\").toString(\"utf-8\");\n    }\n    // **Ambiente do Navegador:**\n    // A função `atob()` sozinha não lida bem com caracteres UTF-8.\n    // A abordagem moderna abaixo garante a decodificação correta.\n    const binaryString = window.atob(text);\n\n    // Converte a string binária decodificada em um array de bytes (Uint8Array).\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n\n    // A API `TextDecoder` interpreta corretamente o array de bytes como uma string UTF-8.\n    return new window.TextDecoder().decode(bytes);\n  } catch (error) {\n    // Captura exceções que podem ocorrer se a string `text` não for um Base64 válido.\n    // Retorna uma string vazia para um comportamento consistente e previsível.\n    // console.error(\"Falha ao decodificar Base64:\", error); // Descomente para depuração\n    return \"\";\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = base64From;\n","/**\n * @file Módulo otimizado para validação de asserção de autenticação WebAuthn.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.2.0\n */\n\nconst verifySignature = require(\"../../crypto/verifySignature\");\nconst importCryptoKey = require(\"../../crypto/importCryptoKey\");\nconst validateRPID = require(\"./validateRPID\");\nconst isNumber = require(\"../../helpers/isNumber\");\nconst base64ToBuffer = require(\"../../utils/base64ToBuffer\");\nconst base64From = require(\"../../utils/base64From\");\nconst bufferConcatenate = require(\"../../utils/bufferConcatenate\");\nconst convertECDSAASN1Signature = require(\"./convertECDSAASN1Signature\");\n\n// ------------------------------------------------------------------------------------------------\n/**\n * Recupera os parâmetros do algoritmo para importar uma chave pública com base no identificador do algoritmo.\n * @private\n */\nfunction getImportPublicKeyAlgorithm(publicKeyAlgorithm) {\n  switch (publicKeyAlgorithm) {\n    case -7: // ES256\n      return { name: \"ECDSA\", namedCurve: \"P-256\" };\n    case -257: // RS256\n      return { name: \"RSASSA-PKCS1-v1_5\", hash: { name: \"SHA-256\" } };\n    case -8: // Ed25519\n      throw new Error(\"Ed25519 is not supported by crypto.subtle directly\");\n    default:\n      throw new Error(`Unsupported algorithm: ${publicKeyAlgorithm}`);\n  }\n}\n\n/**\n * Recupera os parâmetros do algoritmo para verificar uma assinatura com base no identificador do algoritmo.\n * @private\n */\nfunction getAlgorithmVerifySignatureParam(publicKeyAlgorithm) {\n  switch (publicKeyAlgorithm) {\n    case -7: // ES256\n      return { name: \"ECDSA\", hash: { name: \"SHA-256\" } };\n    case -257: // RS256\n      return { name: \"RSASSA-PKCS1-v1_5\", hash: { name: \"SHA-256\" } };\n    case -8: // Ed25519\n      throw new Error(\n        \"Ed25519 is not supported by crypto.subtle. Use an external library.\"\n      );\n    default:\n      throw new Error(`Unsupported algorithm: ${publicKeyAlgorithm}`);\n  }\n}\n\n/**\n * Gera um hash combinado a partir dos dados do autenticador e do clientDataJSON da asserção.\n * Este é o payload que foi originalmente assinado pelo autenticador.\n * @private\n */\nasync function generateDataToVerify(assertion) {\n  const authenticatorDataBuffer = base64ToBuffer(\n    assertion.response.authenticatorData\n  );\n  const clientDataJSONBuffer = base64ToBuffer(assertion.response.clientDataJSON);\n  const clientDataJSONHash = await crypto.subtle.digest(\n    \"SHA-256\",\n    clientDataJSONBuffer\n  );\n\n  return bufferConcatenate(authenticatorDataBuffer, clientDataJSONHash);\n}\n\n// ------------------------------------------------------------------------------------------------\n/**\n * Valida de forma assíncrona uma asserção de autenticação WebAuthn em um fluxo otimizado.\n *\n * @param {object} credential - O objeto da credencial armazenado, contendo a chave pública.\n * @param {object} assertion - A asserção de autenticação recebida do cliente.\n * @param {object} [expectedProps={}] - Propriedades esperadas para validação (challenge, origin, etc.).\n * @param {object} [incomingProps={}] - Propriedades recebidas na requisição (contador da asserção).\n * @param {object} [publicKeyProps={}] - Opções para a importação da chave pública.\n * @param {boolean} [convertECDSignature=true] - Se deve converter a assinatura ECDSA do formato bruto para ASN.1.\n * @returns {Promise<boolean>} Retorna `true` se a validação for bem-sucedida.\n * @throws {Error} Lança um erro detalhado na primeira falha de validação.\n */\nasync function validateAuthentication(\n  credential,\n  assertion,\n  expectedProps = {},\n  incomingProps = {},\n  publicKeyProps = {},\n  convertECDSignature = true\n) {\n  // ## 1. Validação Estrutural dos Objetos\n  if (!credential) {\n    throw new Error(\"Missing credential\");\n  }\n  if (!credential.id) {\n    throw new Error(\"Missing credential ID\");\n  }\n  if (!credential.rawId) {\n    throw new Error(\"Missing credential rawId\");\n  }\n  if (credential.type !== \"public-key\") {\n    throw new Error(\"Credential type must be 'public-key'\");\n  }\n\n  if (!assertion) {\n    throw new Error(\"Missing assertion\");\n  }\n  if (!assertion.id) {\n    throw new Error(\"Missing assertion ID\");\n  }\n  if (!assertion.rawId) {\n    throw new Error(\"Missing assertion rawId\");\n  }\n  if (assertion.type !== \"public-key\") {\n    throw new Error(\"Assertion type must be 'public-key'\");\n  }\n\n  // ## 2. Validação de Consistência entre Credencial e Asserção\n  if (credential.id !== assertion.id) {\n    throw new Error(\"Credential ID does not match assertion ID\");\n  }\n  if (credential.rawId !== assertion.rawId) {\n    throw new Error(\"Credential rawId does not match assertion rawId\");\n  }\n\n  // ## 3. Validação do Contador de Assinatura (Prevenção de Replay/Clonagem)\n  const { counterCredential } = expectedProps;\n  const { counterAssertion } = incomingProps;\n  if (!isNumber(counterCredential) || counterCredential < 0) {\n    throw new Error(\"counterCredential must be a number >= 0\");\n  }\n  if (!isNumber(counterAssertion) || counterAssertion < 0) {\n    throw new Error(\"counterAssertion must be a number >= 0\");\n  }\n  // A especificação WebAuthn exige que o contador da nova asserção seja maior que o contador armazenado.\n  // Isso previne ataques de repetição e detecta clonagem de autenticadores.\n  // Uma exceção é quando um autenticador não suporta contadores e sempre retorna 0.\n  // A lógica abaixo acomoda este cenário: a verificação só é imposta se o novo contador for diferente de zero.\n  if (counterAssertion !== 0) {\n    if (counterAssertion <= counterCredential) {\n      throw new Error(\n        `Invalid signature counter. The assertion counter (${counterAssertion}) must be strictly greater than the stored credential counter (${counterCredential}).`\n      );\n    }\n  }\n\n  // ## 4. Validação dos Parâmetros da Requisição (Client Data)\n  const clientDataJSON = JSON.parse(assertion.response.clientDataJSONDecoded);\n  const assertionChallenge = base64From(clientDataJSON?.challenge || \"\");\n  if (expectedProps.challenge !== assertionChallenge) {\n    throw new Error(\"Challenge provided does not match assertion challenge.\");\n  }\n  if (expectedProps.origin !== clientDataJSON?.origin) {\n    throw new Error(\n      `Origin does not match. Expected: ${expectedProps.origin} Actual: ${\n        clientDataJSON?.origin ?? \"none\"\n      }`\n    );\n  }\n  if (expectedProps.type !== clientDataJSON?.type) {\n    throw new Error(\n      `Type does not match. Expected: ${expectedProps.type} Actual: ${\n        clientDataJSON?.type ?? \"none\"\n      }`\n    );\n  }\n\n  // ## 5. Validação das Flags do Autenticador\n  if (!assertion.authData.flags.up) {\n    throw new Error(\"User Present flag (up) is required for authentication.\");\n  }\n  if (!assertion.authData.flags.uv) {\n    throw new Error(\"User Verified flag (uv) is required for authentication.\");\n  }\n\n  // ## 6. Validação do RP ID\n  await validateRPID(expectedProps.rpID, assertion.authData.rpIdHash);\n\n  // ## 7. Verificação da Assinatura Criptográfica\n  const importAlgo = getImportPublicKeyAlgorithm(\n    credential.response.publicKeyAlgorithm\n  );\n  const verifyAlgo = getAlgorithmVerifySignatureParam(\n    credential.response.publicKeyAlgorithm\n  );\n\n  const publicKey = await importCryptoKey(\n    publicKeyProps?.importKey?.format || \"spki\",\n    base64ToBuffer(credential.response.publicKey),\n    importAlgo,\n    publicKeyProps?.importKey?.extractable || false,\n    [\"verify\"]\n  );\n\n  let signature = new Uint8Array(base64ToBuffer(assertion.response.signature));\n  // Assinaturas ECDSA de autenticadores vêm em formato bruto (r||s), mas a Web Crypto API espera ASN.1.\n  if (convertECDSignature && credential.response.publicKeyAlgorithm === -7) {\n    signature = convertECDSAASN1Signature(signature);\n  }\n\n  const dataToVerify = await generateDataToVerify(assertion);\n\n  return verifySignature(verifyAlgo, publicKey, signature, dataToVerify);\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = validateAuthentication;\n\n// ------------------------------------------------------------------------------------------------\n","/**\n * @file Módulo otimizado para validação de credencial de registro WebAuthn.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.0.0\n */\n\nconst base64ToBuffer = require(\"../../utils/base64ToBuffer\");\nconst cbor = require(\"cbor-x\");\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Valida uma credencial de registro WebAuthn de forma eficiente.\n *\n * Esta função executa uma série de validações em um fluxo único e otimizado:\n * 1. Valida a estrutura e as propriedades essenciais da credencial.\n * 2. Valida os parâmetros da requisição (challenge, origin, type) contra os valores esperados.\n * 3. Decodifica e valida o formato e a declaração do objeto de atestado.\n *\n * @param {object} credential - A credencial WebAuthn a ser validada.\n * @param {object} [expectedProps={}] - Um objeto contendo as propriedades esperadas para a validação.\n * @param {string} [expectedProps.challenge] - O challenge esperado, conforme enviado ao cliente.\n * @param {string} [expectedProps.origin] - A origem (domínio) esperada da requisição.\n * @param {string} [expectedProps.type] - O tipo de operação esperado (ex: 'webauthn.create').\n * @returns {true} Retorna `true` se a credencial for válida em todos os aspectos.\n * @throws {Error} Lança um erro descritivo no primeiro ponto em que a validação falhar.\n */\nfunction validateRegistration(credential, expectedProps = {}) {\n  // ## 1. Validação Estrutural da Credencial\n  // Garante que o objeto da credencial e suas propriedades fundamentais existem e são do tipo correto.\n  if (!credential) {\n    throw new Error(\"Missing credential\");\n  }\n  if (!credential.id) {\n    throw new Error(\"Missing credential ID\");\n  }\n  if (!credential.rawId) {\n    throw new Error(\"Missing credential rawId\");\n  }\n  if (!credential.type || credential.type !== \"public-key\") {\n    throw new Error(\n      \"Missing credential type or credential type is not public-key\"\n    );\n  }\n\n  // ## 2. Validação dos Parâmetros da Requisição (Client Data)\n  // Compara os dados da requisição (challenge, origin, type) com os valores esperados.\n  const clientDataJSON = JSON.parse(credential.response.clientDataJSONDecoded);\n\n  if (expectedProps.challenge !== clientDataJSON?.challenge) {\n    throw new Error(\n      `Challenge does not match. Provided challenge: ${\n        clientDataJSON?.challenge ?? \"none\"\n      }.`\n    );\n  }\n\n  if (expectedProps.origin !== clientDataJSON?.origin) {\n    throw new Error(\n      `Origin does not match. Expected: ${expectedProps.origin} Actual: ${\n        clientDataJSON?.origin ?? \"none\"\n      }`\n    );\n  }\n\n  if (expectedProps.type !== clientDataJSON?.type) {\n    throw new Error(\n      `Type does not match. Expected: ${expectedProps.type} Actual: ${\n        clientDataJSON?.type ?? \"none\"\n      }`\n    );\n  }\n\n  // ## 3. Validação do Objeto de Atestado (Attestation Object)\n  // Decodifica e valida o formato e a declaração de atestado.\n  const attestationObjectBuffer = base64ToBuffer(\n    credential.response.attestationObject\n  );\n  // A biblioteca `cbor.decode` é altamente otimizada para essa operação.\n  const attestationObject = cbor.decode(new Uint8Array(attestationObjectBuffer));\n\n  if (!attestationObject.fmt) {\n    throw new Error(\"Missing attestation object format\");\n  }\n\n  // Para o formato 'none', a declaração de atestado (attStmt) deve estar vazia.\n  // A biblioteca cbor-x decodifica mapas CBOR em objetos Map do JS, que possuem a propriedade `.size`.\n  if (attestationObject.fmt === \"none\") {\n    if (attestationObject.attStmt && attestationObject.attStmt.size > 0) {\n      throw new Error(\"None attestation had unexpected attestation statement\");\n    }\n  } else {\n    // Atualmente, apenas o formato 'none' é suportado por esta validação.\n    throw new Error(`Unsupported Attestation Format: ${attestationObject.fmt}`);\n  }\n\n  // Se todas as validações passarem, a função retorna `true`.\n  return true;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = validateRegistration;\n\n// ------------------------------------------------------------------------------------------------\n","module.exports = {\n  convertECDSAASN1Signature: require(\"./convertECDSAASN1Signature\"),\n  getAuthenticationAuthData: require(\"./getAuthenticationAuthData\"),\n  getRegistrationAuthData: require(\"./getRegistrationAuthData\"),\n  getWebAuthnAuthenticationAssertion: require(\"./getWebAuthnAuthenticationAssertion\"),\n  getWebAuthnRegistrationCredential: require(\"./getWebAuthnRegistrationCredential\"),\n  validateRPID: require(\"./validateRPID\"),\n  validateAuthentication: require(\"./validateAuthentication\"),\n  validateRegistration: require(\"./validateRegistration\"),\n};\n","/**\n * @fileoverview Centraliza constantes de formatação e padrões para uso geral na aplicação.\n * @description Este módulo exporta formatos de data, máscaras para documentos brasileiros, e\n * expressões regulares (Regex) para validações de formato.\n */\nmodule.exports = {\n  // ==============================================================================================\n  // SEÇÃO: Formatos de Data (para bibliotecas como date-fns, dayjs, etc.)\n  // ==============================================================================================\n\n  // ----------------------------------------------------------------------------------------------\n  // Padrões de Data ISO 8601\n\n  /**\n   * Formato de data ISO 8601 completo com timezone (UTC/Zulu).\n   * @example \"2025-08-18T20:49:08.123Z\"\n   */\n  DATE_ISO_FORMAT_TZ: `yyyy-MM-dd'T'HH:mm:ss.SSS'Z'`,\n\n  /**\n   * Formato de data ISO 8601 sem informação de timezone.\n   * @example \"2025-08-18T20:49:08.123\"\n   */\n  DATE_ISO_FORMAT: `yyyy-MM-dd'T'HH:mm:ss.SSS`,\n\n  // ----------------------------------------------------------------------------------------------\n  // Padrões de Data Brasileiros\n\n  /**\n   * Formato de data brasileiro (dia-mês-ano) separado por hífen.\n   * @example \"18-08-2025\"\n   */\n  DATE_BR_FORMAT_D: `dd-MM-yyyy`,\n\n  /**\n   * Formato de data brasileiro (dia/mês/ano) separado por barra.\n   * @example \"18/08/2025\"\n   */\n  DATE_BR_FORMAT_FS: `dd/MM/yyyy`,\n\n  /**\n   * Formato de data e hora brasileiro separado por hífen.\n   * @example \"18-08-2025 20:49:08\"\n   */\n  DATE_BR_HOUR_FORMAT_D: `dd-MM-yyyy HH:mm:ss`,\n\n  /**\n   * Formato de data e hora brasileiro separado por barra.\n   * @example \"18/08/2025 20:49:08\"\n   */\n  DATE_BR_HOUR_FORMAT_FS: `dd/MM/yyyy HH:mm:ss`,\n\n  /**\n   * Formato de data brasileiro (mês-ano) separado por hífen.\n   * @example \"08-2025\"\n   */\n  DATE_BR_MONTH_FORMAT_D: `MM-yyyy`,\n\n  /**\n   * Formato de data brasileiro (mês/ano) separado por barra.\n   * @example \"08/2025\"\n   */\n  DATE_BR_MONTH_FORMAT_FS: `MM/yyyy`,\n\n  // ----------------------------------------------------------------------------------------------\n  // Padrões de Data Americanos\n\n  /**\n   * Formato de data americano (ano-mês-dia) separado por hífen.\n   * @example \"2025-08-18\"\n   */\n  DATE_EUA_FORMAT_D: `yyyy-MM-dd`,\n\n  /**\n   * Formato de data americano (ano/mês/dia) separado por barra.\n   * @example \"2025/08/18\"\n   */\n  DATE_EUA_FORMAT_FS: `yyyy/MM/dd`,\n\n  /**\n   * Formato de data e hora americano separado por hífen.\n   * @example \"2025-08-18 20:49:08\"\n   */\n  DATE_EUA_HOUR_FORMAT_D: `yyyy-MM-dd HH:mm:ss`,\n\n  /**\n   * Formato de data e hora americano separado por barra.\n   * @example \"2025/08/18 20:49:08\"\n   */\n  DATE_EUA_HOUR_FORMAT_FS: `yyyy/MM/dd HH:mm:ss`,\n\n  /**\n   * Formato de data americano (ano-mês) separado por hífen.\n   * @example \"2025-08\"\n   */\n  DATE_EUA_MONTH_FORMAT_D: `yyyy-MM`,\n\n  /**\n   * Formato de data americano (ano/mês) separado por barra.\n   * @example \"2025/08\"\n   */\n  DATE_EUA_MONTH_FORMAT_FS: `yyyy/MM`,\n\n  // ==============================================================================================\n  // SEÇÃO: Máscaras de Formatação (para bibliotecas de input mask)\n  // ==============================================================================================\n\n  /**\n   * Máscara para CAD/ICMS do estado do Paraná (PR).\n   * @example \"90312851-11\"\n   */\n  STRING_FORMAT_CADICMSPR: \"########-##\",\n\n  /**\n   * Máscara para CNPJ alfanumérico.\n   * 'S' representa um caractere alfanumérico [A-Z0-9] e '#' um dígito [0-9].\n   * @example \"AB.123.CD4/567E-89\"\n   */\n  STRING_FORMAT_CNPJ: \"##.###.###/####-##\",\n\n  /**\n   * Máscara para CNPJ Raiz alfanumérico.\n   * 'S' representa um caractere alfanumérico [A-Z0-9] e '#' um dígito [0-9].\n   * @example \"AB.123.CD4\"\n   */\n  STRING_FORMAT_CNPJ_RAIZ: \"##.###.###\",\n\n  /**\n   * Máscara para CPF.\n   * @example \"123.456.789-00\"\n   */\n  STRING_FORMAT_CPF: \"###.###.###-##\",\n\n  /**\n   * Máscara para Protocolo do estado do Paraná (PR).\n   * @example \"123.456.789.1\"\n   */\n  STRING_FORMAT_PROTOCOLPR: \"###.###.###.#\",\n\n  /**\n   * Máscara para CEP (Código de Endereçamento Postal).\n   * @example \"80000-000\"\n   */\n  STRING_FORMAT_CEP: \"#####-###\",\n\n  /**\n   * Máscara para Telefone Celular com 9 dígitos + DDD.\n   * @example \"(41) 98888-8888\"\n   */\n  STRING_FORMAT_PHONE: \"(##) # ####-####\",\n\n  // ==============================================================================================\n  // SEÇÃO: Expressões Regulares (Regex) para Validação de Formato\n  // ==============================================================================================\n\n  /**\n   * Regex para validar a estrutura de um CNPJ alfanumérico.\n   * Verifica 12 caracteres alfanuméricos seguidos de 2 dígitos numéricos. Case-insensitive.\n   */\n  REGEX_CNPJ_ALPHANUMERIC: /^([A-Z\\d]){12}(\\d){2}$/i,\n\n  /**\n   * Regex para validar um e-mail em formato padrão.\n   */\n  REGEX_EMAIL:\n    /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/,\n\n  /**\n   * Regex para validar um UUID v4 (usado em Chave Aleatória PIX).\n   */\n  REGEX_UUID_V4:\n    /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i,\n\n  /**\n   * Regex para validar um número de telefone brasileiro, com ou sem o código do país (+55).\n   * Aceita números de 10 (fixo) ou 11 (celular) dígitos, além do DDI.\n   * @example /^(?:\\+55)?\\d{10,11}$/\n   */\n  REGEX_PHONE_BR: /^(?:\\+55)?\\d{10,11}$/,\n\n  // ==============================================================================================\n  // SEÇÃO: Dados Geográficos - Brasil\n  // ==============================================================================================\n\n  /**\n   * Objeto (chave-valor) com as siglas e nomes de todos os estados brasileiros e o Distrito Federal.\n   * @example { \"PR\": \"Paraná\", \"SP\": \"São Paulo\", ... }\n   */\n  BRAZILIAN_STATES: {\n    AC: \"Acre\",\n    AL: \"Alagoas\",\n    AP: \"Amapá\",\n    AM: \"Amazonas\",\n    BA: \"Bahia\",\n    CE: \"Ceará\",\n    DF: \"Distrito Federal\",\n    ES: \"Espírito Santo\",\n    GO: \"Goiás\",\n    MA: \"Maranhão\",\n    MT: \"Mato Grosso\",\n    MS: \"Mato Grosso do Sul\",\n    MG: \"Minas Gerais\",\n    PA: \"Pará\",\n    PB: \"Paraíba\",\n    PR: \"Paraná\",\n    PE: \"Pernambuco\",\n    PI: \"Piauí\",\n    RJ: \"Rio de Janeiro\",\n    RN: \"Rio Grande do Norte\",\n    RS: \"Rio Grande do Sul\",\n    RO: \"Rondônia\",\n    RR: \"Roraima\",\n    SC: \"Santa Catarina\",\n    SP: \"São Paulo\",\n    SE: \"Sergipe\",\n    TO: \"Tocantins\",\n  },\n\n  /**\n   * Array com as siglas de todos os estados brasileiros e o Distrito Federal.\n   * Útil para popular seletores (dropdowns) ou para validações.\n   * @example [\"AC\", \"AL\", \"AP\", ...]\n   */\n  BRAZILIAN_STATES_ABBR: [\n    \"AC\",\n    \"AL\",\n    \"AP\",\n    \"AM\",\n    \"BA\",\n    \"CE\",\n    \"DF\",\n    \"ES\",\n    \"GO\",\n    \"MA\",\n    \"MT\",\n    \"MS\",\n    \"MG\",\n    \"PA\",\n    \"PB\",\n    \"PR\",\n    \"PE\",\n    \"PI\",\n    \"RJ\",\n    \"RN\",\n    \"RS\",\n    \"RO\",\n    \"RR\",\n    \"SC\",\n    \"SP\",\n    \"SE\",\n    \"TO\",\n  ],\n};\n","/**\n * @file Utilitário para converter um buffer de bytes para uma string.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.0.0\n */\n\n/**\n * @summary Converte um buffer de bytes (`ArrayBuffer`, `Buffer`, etc.) para uma string.\n *\n * @description\n * Esta função converte dados binários para sua representação como string de texto.\n * A função é universalmente compatível, usando o método `toString()` do `Buffer` no Node.js\n * e a API `TextDecoder` no navegador.\n *\n * @param {ArrayBuffer | Buffer | Uint8Array} buffer - O buffer a ser convertido para string.\n * @param {BufferEncoding} [encoding=\"utf-8\"] - **(Apenas Node.js)** A codificação a ser usada\n * para interpretar os bytes. Exemplos: 'utf-8', 'hex', 'base64', 'latin1'.\n * **No ambiente do navegador, este parâmetro é ignorado e a decodificação será sempre UTF-8**,\n * devido a limitações da API `TextDecoder`.\n *\n * @returns {string} A string resultante da decodificação do buffer. Retorna uma string vazia\n * se a entrada for inválida ou vazia.\n *\n * @example\n * // Criando um buffer a partir de uma string (exemplo)\n * const myBuffer = new TextEncoder().encode('Olá, Mundo! 👋');\n *\n * const text = bufferToString(myBuffer);\n * console.log(text); // \"Olá, Mundo! 👋\"\n *\n * // Exemplo específico do Node.js com 'hex'\n * // const hexBuffer = Buffer.from('4f6c612c204d756e646f2120f09f918b', 'hex');\n * // const textFromHex = bufferToString(hexBuffer, 'utf-8'); // \"Olá, Mundo! 👋\"\n */\nfunction bufferToString(buffer, encoding = \"utf-8\") {\n  // 1. Validação da entrada: retorna string vazia para entradas nulas ou indefinidas.\n  if (buffer == null) {\n    return \"\";\n  }\n\n  // **Ambiente Node.js:**\n  if (typeof window === 'undefined') {\n    // Garante que estamos trabalhando com um Buffer do Node.js para usar seu método `toString`.\n    const nodeBuffer = Buffer.isBuffer(buffer) ? buffer : Buffer.from(buffer);\n    // Usa o método nativo do Buffer, que é otimizado e suporta múltiplos encodings.\n    return nodeBuffer.toString(encoding);\n  }\n\n  // **Ambiente do Navegador:**\n  try {\n    // `TextDecoder` é a API padrão da web para converter bytes em string.\n    // Ela sempre decodifica como UTF-8, ignorando o parâmetro `encoding`.\n    return new TextDecoder().decode(buffer);\n  } catch (error) {\n    // Retorna uma string vazia se o buffer de entrada for inválido para a API.\n    return \"\";\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = bufferToString;","const getCrypto = require(\"./getCrypto\");\nconst bufferToString = require(\"../utils/bufferToString\");\nconst base64ToBuffer = require(\"../utils/base64ToBuffer\");\nconst importCryptoKey = require(\"./importCryptoKey.js\");\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Asynchronously decrypts an encrypted message using a provided private key.\n * \n * This function performs RSA-OAEP decryption using the Web Crypto API, supporting both\n * Node.js and browser environments. It handles PEM-formatted private keys and base64-encoded\n * encrypted messages, providing a secure and efficient decryption process.\n *\n * @async\n * @function decrypt\n * @param {string} privateKey - The PEM-encoded private key used for decryption\n * @param {string} encryptedMessage - The base64-encoded encrypted message to decrypt\n * @param {Object} [props={}] - Configuration options for the decryption process\n * @param {string} [props.format=\"pkcs8\"] - Private key format specification\n * @param {Object} [props.algorithm] - Cryptographic algorithm configuration\n * @param {string} [props.algorithm.name=\"RSA-OAEP\"] - Algorithm name\n * @param {Object} [props.algorithm.hash] - Hash algorithm configuration\n * @param {string} [props.algorithm.hash.name=\"SHA-256\"] - Hash algorithm name\n * @param {boolean} [props.extractable=true] - Whether the imported key can be extracted\n * @param {string[]} [props.keyUsages=[\"decrypt\"]] - Permitted key usage operations\n * @param {string} [props.padding=\"RSA-OAEP\"] - Padding scheme for decryption operation\n * @returns {Promise<string>} The decrypted message as a UTF-8 string\n * @throws {Error} When decryption fails due to invalid key, corrupted data, or crypto errors\n * \n * @example\n * const decryptedText = await decrypt(pemPrivateKey, base64EncryptedMessage);\n * \n * @example\n * const decryptedText = await decrypt(pemPrivateKey, base64EncryptedMessage, {\n *   algorithm: { name: \"RSA-OAEP\", hash: { name: \"SHA-1\" } },\n *   extractable: false\n * });\n */\nasync function decrypt(privateKey, encryptedMessage, props = {}) {\n  // Early return for empty encrypted messages to avoid unnecessary processing\n  if (!encryptedMessage) {\n    return \"\";\n  }\n\n  // Destructure configuration with optimized defaults\n  const {\n    format = \"pkcs8\",\n    algorithm = { name: \"RSA-OAEP\", hash: { name: \"SHA-256\" } },\n    extractable = true,\n    keyUsages = [\"decrypt\"],\n    padding = \"RSA-OAEP\"\n  } = props;\n\n  // Get crypto implementation (Node.js or browser)\n  const crypto = getCrypto();\n\n  // Clean and convert PEM private key to binary format\n  // Removes PEM headers, footers, and whitespace in a single operation\n  const cleanedPrivateKey = privateKey.replace(\n    /-----(BEGIN|END) (?:RSA )?(?:PRIVATE|PUBLIC) KEY-----|\\s/g,\n    \"\"\n  );\n  const binaryPrivateKey = base64ToBuffer(cleanedPrivateKey);\n\n  // Import the private key for cryptographic operations\n  const importedKey = await importCryptoKey(\n    format,\n    binaryPrivateKey,\n    algorithm,\n    extractable,\n    keyUsages\n  );\n\n  // Convert base64 encrypted message to binary data\n  const encryptedData = base64ToBuffer(encryptedMessage);\n\n  // Perform decryption using the Web Crypto API\n  const decryptedBuffer = await crypto.subtle.decrypt(\n    { name: padding },\n    importedKey,\n    encryptedData\n  );\n\n  // Convert decrypted binary data back to string\n  return bufferToString(decryptedBuffer);\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = decrypt;\n\n// ------------------------------------------------------------------------------------------------","const getCrypto = require(\"./getCrypto.js\");\nconst bufferFromString = require(\"../utils/bufferFromString\");\nconst base64FromBuffer = require(\"../utils/base64FromBuffer.js\");\nconst importCryptoKey = require(\"./importCryptoKey.js\");\nconst base64ToBuffer = require(\"../utils/base64ToBuffer.js\");\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Encrypts a message using asymmetric cryptography with public key encryption.\n *\n * This function provides a complete encryption workflow that handles PEM-formatted\n * public keys, performs key importation, and encrypts plaintext messages using\n * industry-standard cryptographic algorithms. It supports various RSA encryption\n * schemes and is designed for secure data transmission scenarios where the sender\n * has access to the recipient's public key.\n *\n * The function automatically handles key format conversion from PEM to binary,\n * imports the key into the Web Crypto API, performs the encryption operation,\n * and returns the result as a base64-encoded string for easy transmission.\n *\n * @async\n * @param {string} publicKey - The public key in PEM format for encryption:\n *                            - Must be a valid PEM-encoded public key string\n *                            - Supports standard PEM headers (BEGIN/END PUBLIC KEY)\n *                            - Can include RSA-specific headers (BEGIN/END RSA PUBLIC KEY)\n *                            - Whitespace and line breaks are automatically handled\n *                            - Key should be compatible with the specified algorithm\n *\n * @param {string} message - The plaintext message to encrypt:\n *                          - UTF-8 encoded string that will be converted to binary\n *                          - Empty strings are handled gracefully (returns empty result)\n *                          - Message length is limited by the key size and padding:\n *                            - RSA-OAEP with 2048-bit key: ~190 bytes max\n *                            - RSA-OAEP with 4096-bit key: ~446 bytes max\n *                          - For larger messages, consider hybrid encryption approaches\n *\n * @param {Object} [props={}] - Configuration options for encryption parameters:\n * @param {string} [props.format='spki'] - Public key import format:\n *                            - 'spki': SubjectPublicKeyInfo format (most common for public keys)\n *                            - 'raw': Raw key data (not typical for RSA keys)\n *                            - 'jwk': JSON Web Key format\n *\n * @param {Object} [props.algorithm] - Cryptographic algorithm specification:\n *                            Default: { name: 'RSA-OAEP', hash: { name: 'SHA-256' } }\n *                            Supported algorithms:\n *                            - RSA-OAEP: Optimal Asymmetric Encryption Padding\n *                            - RSA-PKCS1-v1_5: PKCS#1 v1.5 padding (legacy, less secure)\n *                            Hash options: SHA-1, SHA-256, SHA-384, SHA-512\n *\n * @param {boolean} [props.extractable=true] - Key extractability setting:\n *                            - true: Key can be exported after import (default)\n *                            - false: Key cannot be extracted (more secure)\n *                            - Generally safe to leave as true for public keys\n *\n * @param {string[]} [props.keyUsages=['encrypt']] - Permitted key operations:\n *                            - ['encrypt']: Only encryption operations (default)\n *                            - ['encrypt', 'wrapKey']: Encryption and key wrapping\n *                            - Must include 'encrypt' for this function to work\n *\n * @param {string} [props.padding='RSA-OAEP'] - Encryption padding scheme:\n *                            - 'RSA-OAEP': Optimal Asymmetric Encryption Padding (recommended)\n *                            - 'RSA-PKCS1-v1_5': PKCS#1 v1.5 padding (legacy)\n *                            - Should match the algorithm.name parameter\n *\n * @returns {Promise<string>} Promise resolving to encrypted data:\n *                           - Base64-encoded string representation of encrypted bytes\n *                           - Ready for transmission over text-based protocols\n *                           - Can be stored safely in JSON, XML, or database text fields\n *                           - Returns empty string if input message is empty\n *\n * @throws {Error} Throws an error when:\n *                 - Public key is malformed or invalid PEM format\n *                 - Key is incompatible with the specified algorithm\n *                 - Message exceeds maximum size for the key/padding combination\n *                 - Cryptographic operation fails due to invalid parameters\n *                 - Required crypto modules are unavailable in the environment\n *\n * @example\n * // Basic RSA-OAEP encryption with default parameters\n * const publicKeyPem = `-----BEGIN PUBLIC KEY-----\n * MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...\n * -----END PUBLIC KEY-----`;\n *\n * const encrypted = await encrypt(publicKeyPem, 'Hello, World!');\n * console.log('Encrypted message:', encrypted);\n *\n * @example\n * // Advanced encryption with custom algorithm parameters\n * const customEncrypted = await encrypt(\n *   publicKeyPem,\n *   'Sensitive data',\n *   {\n *     algorithm: {\n *       name: 'RSA-OAEP',\n *       hash: { name: 'SHA-512' }\n *     },\n *     extractable: false,\n *     keyUsages: ['encrypt'],\n *     padding: 'RSA-OAEP'\n *   }\n * );\n *\n * @example\n * // Handle encryption errors gracefully\n * try {\n *   const result = await encrypt(publicKey, message);\n *   // Transmit or store the encrypted result\n *   await sendSecureMessage(result);\n * } catch (error) {\n *   console.error('Encryption failed:', error.message);\n *   // Implement fallback or error reporting\n * }\n *\n * @example\n * // Empty message handling\n * const emptyResult = await encrypt(publicKey, '');\n * console.log(emptyResult === ''); // true\n */\nasync function encrypt(publicKey, message, props = {}) {\n  // Handle empty message case early for performance\n  if (!message) return \"\";\n\n  // Extract crypto module for the current environment\n  const crypto = getCrypto();\n\n  // Clean and convert PEM-formatted public key to binary format\n  // Remove PEM headers, footers, and whitespace to get pure base64 content\n  const cleanedPublicKey = publicKey.replace(\n    /(-----(BEGIN|END) (RSA )?(PRIVATE|PUBLIC) KEY-----|\\s)/g,\n    \"\"\n  );\n  const binaryPublicKey = base64ToBuffer(cleanedPublicKey);\n\n  // Import the public key into Web Crypto API format\n  // Use provided parameters or sensible defaults for RSA-OAEP encryption\n  const importedKey = await importCryptoKey(\n    props.format || \"spki\",\n    binaryPublicKey,\n    props.algorithm || {\n      name: \"RSA-OAEP\",\n      hash: { name: \"SHA-256\" },\n    },\n    props.extractable !== undefined ? props.extractable : true,\n    props.keyUsages || [\"encrypt\"]\n  );\n\n  // Convert message string to binary format for encryption\n  const messageBuffer = bufferFromString(message);\n\n  // Perform the actual encryption operation using the imported key\n  // The padding parameter determines the encryption scheme used\n  const encryptedBuffer = await crypto.subtle.encrypt(\n    { name: props.padding || \"RSA-OAEP\" },\n    importedKey,\n    messageBuffer\n  );\n\n  // Convert encrypted binary data to base64 for safe text transmission\n  return base64FromBuffer(encryptedBuffer);\n}\n\n// ------------------------------------------------------------------------------------------------\n\n// Export for CommonJS compatibility (Node.js)\nmodule.exports = encrypt;\n","const getCrypto = require(\"./getCrypto\");\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Computes a cryptographic hash (digest) of the given data using the specified algorithm.\n * \n * This function provides a unified interface for cryptographic hashing that works seamlessly\n * across both Node.js and browser environments. It automatically handles string-to-binary\n * conversion and selects the appropriate hashing implementation based on the runtime environment.\n *\n * @async\n * @function digest\n * @param {string} algorithm - The hash algorithm identifier (e.g., 'SHA-256', 'SHA-1', 'SHA-512')\n * @param {string|Uint8Array} data - The input data to hash - string or binary array\n * @returns {Promise<Uint8Array>} The computed cryptographic hash as a Uint8Array\n * @throws {Error} When the algorithm is unsupported or hashing operation fails\n *\n * @example\n * // Hash a string using SHA-256\n * const hash = await digest('SHA-256', 'hello world');\n * console.log(Array.from(hash).map(b => b.toString(16).padStart(2, '0')).join(''));\n *\n * @example\n * // Hash binary data using SHA-1\n * const binaryData = new Uint8Array([72, 101, 108, 108, 111]);\n * const hash = await digest('SHA-1', binaryData);\n * console.log(hash);\n *\n * @example\n * // Hash large text content\n * const content = 'Lorem ipsum dolor sit amet...';\n * const hash = await digest('SHA-512', content);\n * console.log(hash.length); // 64 bytes for SHA-512\n */\nasync function digest(algorithm, data) {\n  // Convert string data to Uint8Array using optimized approach\n  const binaryData = typeof data === \"string\" \n    ? new TextEncoder().encode(data)\n    : data;\n\n  // Get the appropriate crypto implementation for current environment\n  const crypto = getCrypto();\n\n  // Use Web Crypto API in browser environment for better performance and security\n  if (typeof window !== \"undefined\") {\n    const hashBuffer = await crypto.subtle.digest(algorithm, binaryData);\n    return new Uint8Array(hashBuffer);\n  }\n\n  // Use Node.js crypto module in server environment\n  // Convert Web Crypto API algorithm names to Node.js format if needed\n  const nodeAlgorithm = algorithm.toLowerCase().replace('-', '');\n  const hash = crypto.createHash(nodeAlgorithm).update(binaryData).digest();\n  \n  // Ensure consistent Uint8Array return type across environments\n  return new Uint8Array(hash);\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = digest;\n\n// ------------------------------------------------------------------------------------------------","module.exports = {\n  getCrypto: require(\"./getCrypto\"),\n  decrypt: require(\"./decrypt\"),\n  encrypt: require(\"./encrypt\"),\n  digest: require(\"./digest\"),\n  importCryptoKey: require(\"./importCryptoKey\"),\n  verifySignature: require(\"./verifySignature\"),\n};\n","/**\n * @fileoverview Fornece uma função utilitária que encapsula o operador nativo \"instanceof\".\n */\n\n/**\n * Verifica se um objeto é uma instância de um determinado tipo (construtor).\n *\n * @summary Verifica se um objeto pertence a uma determinada classe ou tipo.\n * @description Esta função é um encapsulamento direto do operador `instanceof` do JavaScript.\n * Ele verifica se a propriedade `prototype` de um construtor aparece em algum lugar\n * na cadeia de protótipos de um objeto.\n *\n * @param {*} object - O objeto a ser verificado.\n * @param {Function} instanceType - O construtor (classe) contra o qual o objeto será verificado.\n * @returns {boolean} Retorna `true` se o objeto for uma instância do tipo fornecido; caso contrário, `false`.\n * @throws {TypeError} Lança um erro se `instanceType` não for um objeto com um construtor\n * (ex: `null`, `undefined`), replicando o comportamento nativo do operador `instanceof`.\n *\n * @example\n * // Usando construtores nativos\n * isInstanceOf(new Date(), Date);     // Retorna true\n * isInstanceOf([], Array);           // Retorna true\n * isInstanceOf(\"texto\", String);     // Retorna false (primitivas não são instâncias diretas)\n *\n * // Usando classes personalizadas\n * class Carro {}\n * const meuCarro = new Carro();\n * isInstanceOf(meuCarro, Carro);      // Retorna true\n */\nfunction isInstanceOf(object, instanceType) {\n  // A função é um encapsulamento direto do operador nativo 'instanceof'.\n  // Esta é a forma mais performática e direta de realizar a verificação.\n  return object instanceof instanceType;\n}\n\n// ------------------------------------------------------------------------------------------------\nmodule.exports = isInstanceOf;\n// ------------------------------------------------------------------------------------------------\n","const { DATE_ISO_FORMAT } = require(\"../constants.js\");\nconst { parse } = require(\"date-fns/parse\");\nconst isInstanceOf = require(\"../helpers/isInstanceOf\");\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @summary Converte uma string para um objeto Date, com base em um padrão de formato.\n *\n * @description\n * Esta função utiliza a biblioteca `date-fns` para analisar uma string de data com um\n * formato específico e retornar um objeto `Date`.\n *\n * Um passo importante desta função é que ela trata os valores da string como se\n * estivessem em UTC. Por exemplo, a string \"2025-08-21 10:30:00\" (sem fuso) será convertida para\n * um objeto `Date` que, em UTC, representa `2025-08-21T10:30:00.000Z`.\n *\n * @param {string} stringDate - A string da data a ser analisada.\n * @param {string} [stringFormat=DATE_ISO_FORMAT] - O padrão de formatação da `stringDate`,\n * compatível com `date-fns`.\n * @param {Date} [defaultDate=new Date()] - O valor a ser retornado se a análise falhar.\n * Se `defaultDate` for `null` ou `undefined`, a função retorna `false`.\n *\n * @returns {Date | false} O objeto `Date` resultante, o `defaultDate` em caso de falha,\n * ou `false` se a análise falhar e não houver `defaultDate`.\n */\nfunction stringToDate(\n  stringDate,\n  stringFormat = DATE_ISO_FORMAT,\n  defaultDate = new Date()\n) {\n  let dateToProcess;\n\n  // 1. Tenta analisar a string ou define o fallback inicial.\n  if (typeof stringDate === 'string') {\n    const parsedDate = parse(stringDate, stringFormat, new Date());\n\n    // Verifica se a análise foi bem-sucedida.\n    if (isInstanceOf(parsedDate, Date) && !isNaN(parsedDate.getTime())) {\n      dateToProcess = parsedDate;\n    } else {\n      // Se a análise falhar, usa a data padrão como fallback.\n      dateToProcess = defaultDate;\n    }\n  } else {\n    // Se a entrada não for uma string, usa a data padrão.\n    dateToProcess = defaultDate;\n  }\n\n  // 2. Valida a data a ser processada (seja ela a analisada ou a padrão).\n  if (dateToProcess == null) {\n    // Se a data padrão era nula/indefinida, retorna `false`.\n    return false;\n  }\n  \n  if (!isInstanceOf(dateToProcess, Date) || isNaN(dateToProcess.getTime())) {\n      // Se a data padrão fornecida for inválida, retorna `false`.\n      return false;\n  }\n\n  // 3. Aplica o ajuste de fuso horário a QUALQUER data válida que saia da função.\n  // Isso garante um comportamento consistente tanto para datas analisadas quanto para as padrão.\n  const timezoneOffsetMillis = dateToProcess.getTimezoneOffset() * 60 * 1000;\n  return new Date(dateToProcess.getTime() - timezoneOffsetMillis);\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = stringToDate;","const isInstanceOf = require(\"../helpers/isInstanceOf.js\");\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário para obter o início de um dia a partir de um objeto Date.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.1.0\n */\n\n/**\n * @summary Retorna uma nova data representando o início do dia (00:00:00).\n *\n * @description\n * Esta função recebe um objeto `Date` e retorna um **novo** objeto `Date` ajustado para o\n * primeiro momento daquele dia (00:00:00.000), no fuso horário local.\n *\n * A função é **não-mutável**, o que significa que o objeto `Date` original passado como\n * argumento não é modificado.\n *\n * @param {Date} date - O objeto `Date` de referência.\n *\n * @returns {Date | false} Um novo objeto `Date` representando o início do dia, ou `false`\n * se a entrada não for um objeto `Date` válido.\n *\n * @example\n * const dataOriginal = new Date('2025-08-21T15:30:00');\n * const inicioDoDia = dateFirstHourOfDay(dataOriginal); // Retorna um novo objeto Date\n *\n * const invalido = dateFirstHourOfDay('não é uma data'); // Retorna false\n */\nfunction dateFirstHourOfDay(date) {\n  // 1. Validação do tipo e do valor da data.\n  // A checagem `isNaN` trata casos como `new Date('data inválida')`.\n  if (!isInstanceOf(date, Date) || isNaN(date.getTime())) {\n    // Retorna `false` para alinhar com o comportamento esperado pelos testes.\n    return false;\n  }\n\n  // 2. Cria uma nova instância da data para evitar a mutação do objeto original.\n  const newDate = new Date(date.getTime());\n\n  // 3. Define a hora, minutos, segundos e milissegundos para zero de uma só vez.\n  // `setHours(0, 0, 0, 0)` é uma forma concisa e eficiente de zerar o tempo do dia.\n  newDate.setHours(0, 0, 0, 0);\n\n  return newDate;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = dateFirstHourOfDay;","const isInstanceOf = require(\"../helpers/isInstanceOf.js\");\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário para obter o final de um dia a partir de um objeto Date.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.0.0\n */\n\n/**\n * @summary Retorna uma nova data representando o final do dia (23:59:59.999).\n *\n * @description\n * Esta função recebe um objeto `Date` e retorna um **novo** objeto `Date` ajustado para o\n * último momento daquele dia (23:59:59.999), no fuso horário local.\n *\n * A função é **não-mutável**, o que significa que o objeto `Date` original passado como\n * argumento não é modificado.\n *\n * @param {Date} date - O objeto `Date` de referência.\n *\n * @returns {Date | false} Um novo objeto `Date` representando o final do dia, ou `false`\n * se a entrada não for um objeto `Date` válido.\n *\n * @example\n * const dataOriginal = new Date('2025-08-21T15:30:00');\n * const finalDoDia = dateLastHourOfDay(dataOriginal);\n *\n * // O objeto original permanece inalterado\n * console.log(dataOriginal.toLocaleTimeString()); // \"15:30:00\"\n *\n * // O novo objeto representa o final daquele dia\n * console.log(finalDoDia.toLocaleTimeString());  // \"23:59:59\"\n */\nfunction dateLastHourOfDay(date) {\n  // 1. Validação do tipo e do valor da data.\n  // A checagem `isNaN` trata casos como `new Date('data inválida')`.\n  if (!isInstanceOf(date, Date) || isNaN(date.getTime())) {\n    return false;\n  }\n\n  // 2. Cria uma nova instância da data para evitar a mutação do objeto original.\n  const newDate = new Date(date.getTime());\n\n  // 3. Define a hora para o último momento do dia.\n  // `setHours` pode receber todos os valores de tempo, tornando o código mais conciso.\n  newDate.setHours(23, 59, 59, 999);\n\n  return newDate;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = dateLastHourOfDay;","/**\n * @fileoverview Utilitário para formatar condições de busca por intervalo de datas\n * em objetos de consulta, com dependências de conversão e ajuste de data/hora.\n */\n\n// --- Dependências do Módulo ---\nconst { DATE_BR_FORMAT_D } = require(\"../../../constants.js\");\nconst stringToDate = require(\"../../../utils/stringToDate.js\");\nconst dateFirstHourOfDay = require(\"../../../utils/dateFirstHourOfDay.js\");\nconst dateLastHourOfDay = require(\"../../../utils/dateLastHourOfDay.js\");\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Cria uma condição de busca por intervalo de datas (BETWEEN) em um objeto.\n *\n * @summary Formata um intervalo de datas para uma condição de ORM.\n * @description Esta função modifica um objeto de consulta, convertendo strings de data em\n * objetos `Date` e criando uma cláusula `$and` com condições `$gte` (maior ou igual a)\n * e/ou `$lte` (menor ou igual a).\n *\n * **Efeitos Colaterais:**\n * 1.  Adiciona uma nova chave (`key`) ao objeto com a condição de intervalo.\n * 2.  **Remove** as chaves originais de data (`afterKey`, `beforeKey`) do objeto.\n *\n * @param {object} object - O objeto de consulta que será **modificado**.\n * @param {string} [fromFormat=DATE_BR_FORMAT_D] - O formato em que as strings de data de entrada estão.\n * @param {string} [key=\"created_at\"] - A chave principal no objeto onde a condição `$and` será criada.\n * @param {string} [beforeKey=\"created_at_until\"] - A chave que contém a data final do intervalo (`<=`).\n * @param {string} [afterKey=\"created_at_from\"] - A chave que contém a data inicial do intervalo (`>=`).\n * @param {boolean} [resetHMS=true] - Se `true`, ajusta a data inicial para o primeiro momento do dia (00:00:00) e a data final para o último (23:59:59).\n * @returns {object|null} Retorna o objeto modificado se alguma condição for aplicada, ou `null` se nenhuma for.\n *\n * @example\n * // Filtro de entrada\n * const filter = { created_at_from: '01-08-2025', created_at_until: '18-08-2025' };\n *\n * setConditionBetweenDates(filter);\n *\n * // O objeto 'filter' é modificado para:\n * // {\n * //   created_at: {\n * //     $and: [\n * //       { $gte: new Date('2025-08-01T00:00:00.000') },\n * //       { $lte: new Date('2025-08-18T23:59:59.999') }\n * //     ]\n * //   }\n * // }\n * // Note que 'created_at_from' e 'created_at_until' foram removidos.\n */\nfunction setConditionBetweenDates(\n  object,\n  fromFormat = DATE_BR_FORMAT_D,\n  key = \"created_at\",\n  beforeKey = \"created_at_until\",\n  afterKey = \"created_at_from\",\n  resetHMS = true\n) {\n  // Guarda de validação: retorna null se o objeto não existir ou se nenhuma das chaves de\n  // intervalo de data estiver presente, mantendo o comportamento original.\n  if (!object || (!object[afterKey] && !object[beforeKey])) {\n    return null;\n  }\n\n  const conditions = [];\n\n  // Processa a data inicial do intervalo ('de')\n  if (object[afterKey]) {\n    // Converte a string de data para um objeto Date.\n    const fromDate = stringToDate(object[afterKey], fromFormat);\n\n    // Ajusta a data para o início do dia, se solicitado.\n    const finalDate = resetHMS ? dateFirstHourOfDay(fromDate) : fromDate;\n\n    conditions.push({ $gte: finalDate });\n\n    // Remove a chave original do objeto, conforme a lógica original.\n    delete object[afterKey];\n  }\n\n  // Processa a data final do intervalo ('até')\n  if (object[beforeKey]) {\n    const untilDate = stringToDate(object[beforeKey], fromFormat);\n\n    // Ajusta a data para o final do dia, se solicitado.\n    const finalDate = resetHMS ? dateLastHourOfDay(untilDate) : untilDate;\n\n    conditions.push({ $lte: finalDate });\n\n    // Remove a chave original do objeto.\n    delete object[beforeKey];\n  }\n\n  // Adiciona a nova chave de condição ao objeto.\n  object[key] = {\n    $and: conditions,\n  };\n\n  // Retorna o objeto modificado, mantendo o comportamento original.\n  return object;\n}\n\n// ------------------------------------------------------------------------------------------------\nmodule.exports = setConditionBetweenDates;\n// ------------------------------------------------------------------------------------------------\n","/**\n * @fileoverview Fornece uma função utilitária para formatar condições de busca\n * por intervalo (BETWEEN) em objetos de consulta de banco de dados.\n */\n\n/**\n * Cria uma condição de busca por intervalo (BETWEEN) em um objeto de consulta.\n *\n * @summary Formata um valor de objeto para uma condição de intervalo (BETWEEN) de ORM.\n * @description Modifica um objeto de consulta para adicionar uma cláusula `$and` com condições\n * `$gte` (maior ou igual a) e/ou `$lte` (menor ou igual a). Esta função é útil para filtrar\n * por um intervalo de valores (ex: datas, preços). **A função modifica o objeto de entrada diretamente**.\n *\n * @param {object} object - O objeto de consulta que será **modificado**.\n * @param {string} [key=\"value\"] - A chave principal no objeto onde a condição `$and` será criada.\n * @param {string} [beforeKey=\"value_until\"] - A chave no objeto que contém o valor final do intervalo (`<=`).\n * @param {string} [afterKey=\"value_from\"] - A chave no objeto que contém o valor inicial do intervalo (`>=`).\n * @returns {object|void} Retorna o objeto modificado se ao menos uma condição (`beforeKey` ou `afterKey`)\n * for aplicada. Retorna `undefined` (implicitamente) se nenhuma condição for encontrada no objeto.\n * @example\n * // Caso com ambas as chaves\n * const query = { value_from: '2025-01-01', value_until: '2025-01-31' };\n * setConditionBetweenValues(query);\n * // query é modificado para:\n * // {\n * //   value_from: '2025-01-01',\n * //   value_until: '2025-01-31',\n * //   value: { $and: [ { $gte: '2025-01-01' }, { $lte: '2025-01-31' } ] }\n * // }\n *\n * // Caso com apenas a chave inicial\n * const query2 = { value_from: 100 };\n * setConditionBetweenValues(query2);\n * // query2 é modificado para: { value_from: 100, value: { $and: [ { $gte: 100 } ] } }\n */\nfunction setConditionBetweenValues(\n  object,\n  key = \"value\",\n  beforeKey = \"value_until\",\n  afterKey = \"value_from\"\n) {\n  // Guarda de validação: se o objeto não existe, ou se nenhuma das chaves de\n  // intervalo (`afterKey` ou `beforeKey`) está presente, a função não faz nada.\n  // Preserva o retorno implícito de `undefined` do código original.\n  if (!object || (!object[afterKey] && !object[beforeKey])) {\n    return;\n  }\n\n  const conditions = [];\n\n  // Adiciona a condição de limite inferior se a chave correspondente existir.\n  if (object[afterKey]) {\n    conditions.push({ $gte: object[afterKey] });\n  }\n\n  // Adiciona a condição de limite superior se a chave correspondente existir.\n  if (object[beforeKey]) {\n    conditions.push({ $lte: object[beforeKey] });\n  }\n\n  // Atribui a nova estrutura de condição ao objeto na chave especificada.\n  object[key] = {\n    $and: conditions,\n  };\n\n  // Preserva o retorno do objeto modificado do código original.\n  return object;\n}\n\n// ------------------------------------------------------------------------------------------------\nmodule.exports = setConditionBetweenValues;\n// ------------------------------------------------------------------------------------------------\n","/**\n * @fileoverview Fornece uma função utilitária para formatar condições de busca\n * textual (LIKE) em objetos de consulta de banco de dados.\n */\n\n/**\n * Modifica um objeto para criar uma condição de busca textual (LIKE/ILIKE).\n *\n * @summary Formata um valor de objeto para uma condição LIKE de ORM.\n * @description Esta função é um utilitário para construir cláusulas de consulta para ORMs (como Sequelize).\n * Ela pega o valor de uma chave no objeto, o envolve com wildcards (`%`) e o reatribui\n * à mesma chave no formato `{ $iLike: '%valor%' }` ou `{ $like: '%valor%' }`.\n * A função modifica o objeto de entrada diretamente (mutação).\n *\n * @param {object} object - O objeto de consulta que será **modificado**.\n * @param {string} key - A chave no objeto cujo valor será formatado.\n * @param {boolean} [insensitive=true] - Se `true`, usa `$iLike` (case-insensitive). Se `false`, usa `$like` (case-sensitive).\n * @returns {void} Esta função não retorna um valor; ela modifica o objeto passado como referência.\n * @example\n * const query = { name: 'Maria' };\n * setConditionStringLike(query, 'name');\n * // O objeto 'query' agora é: { name: { $iLike: '%Maria%' } }\n *\n * const filter = { email: 'TESTE@' };\n * setConditionStringLike(filter, 'email', false);\n * // O objeto 'filter' agora é: { email: { $like: '%TESTE@%' } }\n *\n * const emptyQuery = { name: '' };\n * setConditionStringLike(emptyQuery, 'name');\n * // O objeto 'emptyQuery' não é modificado, pois o valor inicial é \"falsy\".\n */\nfunction setConditionStringLike(object, key, insensitive = true) {\n  // Guarda de validação: se o objeto, a chave ou o valor na chave não existirem\n  // ou forem \"falsy\" (como uma string vazia), a função não faz nada.\n  if (!object || !key || !object[key]) {\n    return;\n  }\n\n  // Determina o operador a ser usado com base na opção 'insensitive'.\n  const operator = insensitive ? '$iLike' : '$like';\n  \n  // Armazena o valor original para evitar problemas na reatribuição.\n  const value = object[key];\n\n  // Modifica o objeto, reatribuindo a chave com a nova estrutura de condição.\n  // Usa a sintaxe de nome de propriedade computada ([operator]) para definir a chave dinamicamente.\n  object[key] = {\n    [operator]: `%${value}%`,\n  };\n}\n\n// ------------------------------------------------------------------------------------------------\nmodule.exports = setConditionStringLike;\n// ------------------------------------------------------------------------------------------------","/**\n * @fileoverview Fornece uma classe para gerenciar estados de espera assíncronos (Promises).\n * @description Este módulo exporta uma instância única (singleton) da WaitPlugin.\n */\n\n/**\n * @class WaitPlugin\n * @summary Gerencia a criação e resolução de Promises \"on-demand\".\n * @description Utiliza um Map internamente para máxima performance em adições e remoções,\n * enquanto expõe a lista de esperas como um Objeto para compatibilidade e depuração.\n */\nclass WaitPlugin {\n  \n  /**\n   * Inicializa o plugin.\n   * @constructor\n   */\n  constructor() {\n    /**\n     * Armazena as esperas ativas. É um Map privado para performance.\n     * @private\n     * @type {Map<string, {promise: Promise<any>, resolve: Function, reject: Function}>}\n     */\n    this._waitList = new Map();\n  }\n\n  /**\n   * Getter público para a lista de esperas.\n   * @description Converte o Map interno em um Objeto simples para fins de compatibilidade\n   * com testes ou para facilitar a depuração.\n   * @returns {Object<string, {promise: Promise<any>, resolve: Function, reject: Function}>}\n   */\n  get waitList() {\n    return Object.fromEntries(this._waitList);\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Finaliza uma espera, resolvendo ou rejeitando a Promise correspondente.\n   *\n   * @param {string} name - O nome único da espera a ser finalizada.\n   * @param {boolean} [isSuccessful=true] - Se `true`, a Promise será resolvida. Se `false`, será rejeitada.\n   * @param {*} [returnParam] - O valor a ser passado para o `resolve` ou `reject` da Promise.\n   * @returns {any} Retorna `false` se a espera não existir. Em caso de erro interno, retorna o\n   * próprio objeto de erro. Em sucesso, o retorno é indefinido.\n   */\n  finishWait(name, isSuccessful = true, returnParam) {\n    try {\n      const waitItem = this._waitList.get(name);\n      if (!waitItem) {\n        return false;\n      }\n\n      if (isSuccessful) {\n        waitItem.resolve(returnParam);\n      } else {\n        waitItem.reject(returnParam);\n      }\n    } catch (error) {\n      return error;\n    } finally {\n      // A operação delete do Map é segura e performática.\n      this._waitList.delete(name);\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Inicia uma nova espera e retorna uma Promise associada a ela.\n   *\n   * @param {string} name - O nome único para a nova espera.\n   * @returns {Promise<any>|undefined} Retorna a Promise que aguardará a finalização.\n   * Retorna `undefined` se uma espera com o mesmo nome já existir.\n   */\n  startWait(name) {\n    if (this._waitList.has(name)) {\n      return;\n    }\n    \n    let resolve, reject;\n    const promise = new Promise((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n    \n    this._waitList.set(name, { promise, resolve, reject });\n    \n    return promise;\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Finaliza todas as esperas ativas de uma só vez.\n   *\n   * @param {boolean} isSuccessful - Se `true`, todas as Promises serão resolvidas. Se `false`, serão rejeitadas.\n   * @param {*} [returnParam] - O valor a ser passado para cada `resolve` ou `reject`.\n   */\n  finishAll(isSuccessful, returnParam) {\n    // Cria uma cópia das chaves antes de iterar. É a forma mais segura de\n    // modificar uma coleção (neste caso, o Map) enquanto ela está sendo percorrida.\n    const allWaitKeys = Array.from(this._waitList.keys());\n    \n    for (const key of allWaitKeys) {\n      this.finishWait(key, isSuccessful, returnParam);\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n}\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Instância única (singleton) do WaitPlugin.\n * @type {WaitPlugin}\n */\nconst WP = new WaitPlugin();\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = WP;","/**\n * @fileoverview Fornece uma função para retornar um valor numérico válido ou um valor\n * padrão caso o valor principal seja inválido.\n */\n\n/**\n * Retorna um valor numérico válido ou o valor padrão (`defaultValue`) caso o valor\n * verificado (`checkValue`) não seja um número finito ou seja menor que 1.\n *\n * @summary Retorna um valor numérico válido ou o valor padrão fornecido.\n * @description Esta função garante que o valor retornado seja um número inteiro, finito\n * e maior ou igual a 1. Caso contrário, retorna o valor padrão fornecido. É útil para\n * cenários onde limites, quantidades ou índices não podem ser negativos, nulos, NaN ou infinitos.\n *\n * @param {*} checkValue - O valor a ser verificado.\n * @param {number} defaultValue - O valor padrão a ser retornado caso `checkValue` seja inválido.\n * @returns {number} Retorna o número validado ou `defaultValue` caso `checkValue` seja inválido.\n * @example\n * // Casos de substituição\n * defaultNumeric(\"abc\", 10);     // Retorna 10\n * defaultNumeric(NaN, 5);        // Retorna 5\n * defaultNumeric(-3, 1);         // Retorna 1\n * defaultNumeric(Infinity, 2);   // Retorna 2\n *\n * // Casos válidos\n * defaultNumeric(7, 1);          // Retorna 7\n * defaultNumeric(\"12\", 1);       // Retorna 12\n * defaultNumeric(1.9, 1);        // Retorna 1 (arredondado para baixo)\n */\nfunction defaultNumeric(checkValue, defaultValue) {\n  const num = Number(checkValue);\n  return Number.isFinite(num) && !isNaN(num) ? num : defaultValue;\n}\n\n// ------------------------------------------------------------------------------------------------\nmodule.exports = defaultNumeric;\n// ------------------------------------------------------------------------------------------------\n","// =================================================================================================\n// ARQUIVO:      BulkProcessor.js\n// OBJETIVO:     Fornecer uma classe genérica e de alta performance para processamento de dados\n//               em lote (bulk). Abstrai a complexidade de acumular itens, enviá-los em\n//               batches, e gerenciar concorrência e finalização segura.\n// =================================================================================================\nconst defaultNumeric = require(\"../helpers/defaultNumeric.js\");\n\n/**\n * @typedef {object} Logger\n * @description Define a interface para um logger compatível.\n * @property {(message: string, context?: object) => void} info - Função para logar mensagens informativas.\n * @property {(message: string, context?: object) => void} error - Função para logar mensagens de erro.\n */\n\n/**\n * @typedef {object} BulkProcessorOptions\n * @property {number} [limit=1000] - O número de itens a acumular antes de disparar o processamento do lote. Será forçado para no mínimo 1.\n * @property {Logger} [logger] - Uma instância de logger estruturado. Se não for fornecido, um logger silencioso será usado.\n * @property {any} [payload={}] - Um objeto de dados estático que será passado para todos os callbacks.\n * @property {any} [serviceContext=null] - Um contexto de serviço ou de dados que será passado para os callbacks.\n * @property {(params: { batch: any[], payload: any, serviceContext: any, logger: Logger }) => Promise<void>} [onFlush] - Callback assíncrono chamado para processar um lote.\n * @property {(params: { buffer: any[], payload: any, item: any, serviceContext: any, logger: Logger }) => Promise<void>} [onAdd] - Callback assíncrono chamado a cada item adicionado.\n * @property {(params: { payload: any, serviceContext: any, logger: Logger }) => Promise<void>} [onEnd] - Callback assíncrono chamado quando o método `end()` é invocado, antes do flush final.\n */\n\n/**\n * @class BulkProcessor\n * @description Gerencia o processamento de itens em lote (bulk).\n * A classe acumula itens em um buffer interno e invoca um callback de processamento\n * assíncrono quando o tamanho do lote atinge um limite definido. É ideal para otimizar\n * operações de I/O, como inserções em banco de dados ou chamadas para APIs.\n *\n * @example\n * // Uso padrão com a nova API de opções\n * const processor = new BulkProcessor({\n * limit: 100,\n * onFlush: async ({ batch }) => {\n * console.log(`Processing ${batch.length} items.`);\n * // ...lógica de inserção no banco de dados...\n * }\n * });\n *\n * for (let i = 0; i < 1000; i++) {\n * processor.add({ id: i, data: `item-${i}` });\n * }\n * await processor.end();\n */\nclass BulkProcessor {\n  /** @private @type {any[]} */\n  #buffer = [];\n  /** @private @type {number} */\n  #limit;\n  /** @private @type {number} */\n  #maxBufferSize;\n  /** @private @type {number} */\n  #maxConcurrentFlushes;\n  /** @private @type {number} */\n  #activeFlushes = 0;\n  /** @private @type {boolean} */\n  #isEnding = false;\n  /** @private @type {Logger} */\n  #logger;\n  /** @private @type {any} */\n  #payload;\n  /** @private @type {any} */\n  #serviceContext;\n  /** @private @type {number} */\n  #retries;\n  /** @private @type {number} */\n  #retryDelayMs;\n  /** @private @type {number} */\n  #flushTimeoutMs;\n  /** @private @type {{onAdd?: Function, onFlush?: Function, onEnd?: Function, onBackpressure?: Function, onFlushFailure?: Function}} */\n  #callbacks;\n\n  /**\n   * Constrói e configura uma nova instância do BulkProcessor.\n   * Este método é projetado para ser flexível, suportando tanto uma assinatura\n   * moderna baseada em um único objeto de opções quanto uma assinatura legada\n   * para garantir a retrocompatibilidade.\n   *\n   * @param {BulkProcessorOptions | object} [arg1={}] - O objeto de opções ou o `payload` (legado).\n   * @param {object} [arg2={}] - O objeto `callbackFunctions` (legado).\n   * @param {object} [arg3={}] - O objeto `options` (legado).\n   */\n  constructor(arg1 = {}, arg2 = {}, arg3 = {}) {\n    let options;\n\n    // Bloco de compatibilidade para a assinatura legada (payload, callbacks, options).\n    // Se os argumentos 2 ou 3 forem fornecidos, o construtor assume que a assinatura\n    // antiga está em uso e remapeia os parâmetros para o novo formato de 'options'.\n    if (Object.keys(arg2).length > 0 || Object.keys(arg3).length > 0) {\n      const payload = arg1;\n      const callbackFunctions = arg2;\n      const otherOptions = arg3;\n      options = {\n        ...otherOptions,\n        payload: otherOptions.payload || payload,\n        onAdd: otherOptions.onAdd || callbackFunctions.onAddCallback,\n        onFlush: otherOptions.onFlush || callbackFunctions.onFlushCallback,\n        onEnd: otherOptions.onEnd || callbackFunctions.onEndCallback,\n      };\n    } else {\n      options = arg1;\n    }\n\n    // Define os padrões para todas as configurações e extrai os valores fornecidos pelo usuário.\n    const {\n      limit: userLimit = 1000,\n      maxBufferSize,\n      maxConcurrentFlushes = 3,\n      flushTimeoutMs = 30000,\n      retries = 0,\n      retryDelayMs = 1000,\n      logger = {\n        info: () => {},\n        error: () => {},\n        warn: () => {},\n        debug: () => {},\n      },\n      payload = {},\n      serviceContext = null,\n      onFlush,\n      onAdd,\n      onEnd,\n      onBackpressure,\n      onFlushFailure,\n    } = options;\n\n    // --- Sanitização e Validação dos Parâmetros ---\n    // Esta seção \"blinda\" o processador contra configurações inválidas ou inseguras,\n    // garantindo que os valores numéricos sejam válidos e estejam dentro de limites razoáveis.\n    this.#limit = Math.max(defaultNumeric(userLimit, 1), 1);\n    // O buffer deve ter espaço para pelo menos dois lotes completos para evitar backpressure prematuro.\n    this.#maxBufferSize = Math.max(\n      this.#limit * 2,\n      defaultNumeric(maxBufferSize, 0)\n    );\n    // Deve haver pelo menos 1 slot de processamento concorrente (comportamento sequencial).\n    this.#maxConcurrentFlushes = Math.max(\n      1,\n      defaultNumeric(maxConcurrentFlushes, 3)\n    );\n    // O número de retries não pode ser negativo.\n    this.#retries = Math.max(0, defaultNumeric(retries, 0));\n    // Garante um delay mínimo para evitar loops de retry muito agressivos.\n    this.#retryDelayMs = Math.max(100, defaultNumeric(retryDelayMs, 1000));\n    // Garante um timeout mínimo para o flush.\n    this.#flushTimeoutMs = Math.max(500, defaultNumeric(flushTimeoutMs, 30000));\n\n    // Atribuição das propriedades da instância.\n    this.#logger = logger;\n    this.#payload = payload;\n    this.#serviceContext = serviceContext;\n    this.#callbacks = { onFlush, onAdd, onEnd, onBackpressure, onFlushFailure };\n\n    // Log de inicialização para observabilidade, registrando a configuração final aplicada.\n    this.#logger.info(`BulkProcessor inicializado.`, {\n      limit: this.#limit,\n      maxBufferSize: this.#maxBufferSize,\n      maxConcurrentFlushes: this.#maxConcurrentFlushes,\n      retries: this.#retries,\n      retryDelayMs: this.#retryDelayMs,\n      flushTimeoutMs: this.#flushTimeoutMs,\n    });\n  }\n\n  /**\n   * Adiciona um item à fila de processamento de forma assíncrona.\n   *\n   * Este é o principal método para popular o processador. Ele gerencia a lógica de backpressure:\n   * se o buffer interno atingir sua capacidade máxima (`maxBufferSize`), a execução\n   * deste método será pausada até que haja espaço disponível. Isso previne o consumo\n   * excessivo de memória sob alta carga.\n   *\n   * A chamada ao callback `onAdd` é realizada de forma \"fire-and-forget\" e não bloqueia a adição do item.\n   *\n   * @param {*} item - O item a ser adicionado ao lote.\n   * @returns {Promise<void>} Uma promessa que resolve quando o item foi adicionado com sucesso ao buffer.\n   */\n  async add(item) {\n    // Trava de segurança para impedir a adição de itens durante o processo de finalização.\n    if (this.#isEnding) {\n      this.#logger.info(\n        \"Processador em estado de finalização. Novos itens estão sendo ignorados.\",\n        { item }\n      );\n      return;\n    }\n\n    // --- Lógica de Backpressure ---\n    // Se o buffer atingiu a capacidade máxima, o processador entra em estado de espera.\n    if (this.#buffer.length >= this.#maxBufferSize) {\n      // Notifica o sistema de que o backpressure foi ativado. A chamada é feita\n      // de forma não-bloqueante para não travar o processo principal.\n      if (this.#callbacks.onBackpressure) {\n        Promise.resolve(\n          this.#callbacks.onBackpressure({\n            bufferSize: this.#buffer.length,\n            maxBufferSize: this.#maxBufferSize,\n            item, // Informa qual item está aguardando para ser adicionado.\n          })\n        ).catch((error) => {\n          this.#logger.error(\"Erro no callback onBackpressure.\", {\n            errorMessage: error.message,\n          });\n        });\n      }\n\n      // Aguarda em um laço até que o buffer tenha espaço novamente.\n      while (this.#buffer.length >= this.#maxBufferSize) {\n        // Pausa a execução por um curto período para evitar consumo de CPU (busy-waiting)\n        // e permite que a event loop processe os flushes em andamento.\n        await new Promise((resolve) => setTimeout(resolve, 50));\n      }\n    }\n\n    // O item é adicionado ao buffer somente após a liberação do backpressure.\n    this.#buffer.push(item);\n\n    // O callback onAdd é invocado de forma não-bloqueante para não impactar a performance de adição.\n    if (this.#callbacks.onAdd) {\n      try {\n        // `Promise.resolve()` garante que mesmo um onAdd síncrono seja tratado como uma promessa.\n        Promise.resolve(\n          this.#callbacks.onAdd({\n            buffer: this.#buffer,\n            payload: this.#payload,\n            item,\n            serviceContext: this.#serviceContext,\n            logger: this.#logger,\n          })\n        ).catch((error) => {\n          this.#logger.error(`Erro não tratado no callback onAdd.`, {\n            errorMessage: error.message,\n          });\n        });\n      } catch (syncError) {\n        // Este catch é uma segurança extra para callbacks síncronos que podem lançar exceções.\n        this.#logger.error(`Erro síncrono no callback onAdd.`, {\n          errorMessage: syncError.message,\n        });\n      }\n    }\n\n    // Verifica se o buffer atingiu o limite para um lote e dispara o processamento.\n    if (this.#buffer.length >= this.#limit) {\n      this.flush();\n    }\n  }\n\n  /**\n   * Dispara o processamento de lotes de forma síncrona e não-bloqueante.\n   *\n   * Atua como um \"despachante\": ele verifica o estado atual do buffer e os slots\n   * de concorrência disponíveis e inicia quantas operações de processamento (`#executeFlush`)\n   * forem possíveis, até o limite de `maxConcurrentFlushes`.\n   *\n   * Este método é chamado automaticamente pelo `add()` e `end()`, mas também pode ser\n   * invocado manualmente para forçar o processamento de um lote parcial.\n   */\n  flush() {\n    // Este laço é o coração da concorrência. Enquanto houver itens e \"trabalhadores\" (slots)\n    // disponíveis, ele continuará despachando novos trabalhos.\n    while (\n      this.#buffer.length > 0 &&\n      this.#activeFlushes < this.#maxConcurrentFlushes\n    ) {\n      const batch = this.#buffer.splice(0, this.#limit);\n      // Dispara a execução sem esperar (fire-and-forget) para permitir que múltiplos\n      // flushes ocorram em paralelo. O gerenciamento do estado assíncrono é feito em #executeFlush.\n      this.#executeFlush(batch);\n    }\n  }\n\n  /**\n   * O motor de processamento assíncrono para um único lote.\n   *\n   * Este método privado encapsula toda a lógica complexa de uma operação de flush,\n   * incluindo:\n   * 1. Gerenciamento do timeout da operação (`flushTimeoutMs`).\n   * 2. Implementação da política de retries (`retries` e `retryDelayMs`).\n   * 3. Invocação do callback `onFlushFailure` para lotes que falham permanentemente.\n   * 4. Gerenciamento do contador de flushes ativos.\n   * 5. Disparo reativo do próximo ciclo de `flush` para manter o pipeline de processamento ativo.\n   *\n   * @private\n   * @param {any[]} batch - O lote de itens que esta execução irá processar.\n   * @returns {Promise<void>}\n   */\n  async #executeFlush(batch) {\n    // Incrementa o contador de operações ativas. Este é o início do ciclo de vida de um flush.\n    this.#activeFlushes++;\n    this.#logger.info(\n      `Iniciando processamento de lote com ${batch.length} itens. Ativos: ${\n        this.#activeFlushes\n      }`\n    );\n\n    let lastError = null;\n\n    // Laço de tentativas: executa a tentativa inicial (attempt 0) + o número de retries configurado.\n    for (let attempt = 0; attempt <= this.#retries; attempt++) {\n      try {\n        // Caso de borda: se nenhum onFlush for fornecido, descarta o lote intencionalmente.\n        if (!this.#callbacks.onFlush) {\n          this.#logger.info(\n            `Nenhum callback onFlush definido. Lote de ${batch.length} itens descartado.`\n          );\n          lastError = null; // Garante que não será tratado como uma falha.\n          break;\n        }\n\n        if (attempt > 0) {\n          this.#logger.info(\n            `Tentativa ${attempt}/${this.#retries} para o lote.`\n          );\n        }\n\n        // Executa o onFlush em uma \"corrida\" contra um timer de timeout.\n        let timeoutId;\n        const timeoutPromise = new Promise((_, reject) => {\n          timeoutId = setTimeout(\n            () =>\n              reject(\n                new Error(`Flush timed out after ${this.#flushTimeoutMs}ms`)\n              ),\n            this.#flushTimeoutMs\n          );\n        });\n\n        try {\n          await Promise.race([\n            this.#callbacks.onFlush({\n              batch,\n              payload: this.#payload,\n              serviceContext: this.#serviceContext,\n              logger: this.#logger,\n            }),\n            timeoutPromise,\n          ]);\n        } finally {\n          // CRÍTICO: Limpa o timeout para evitar que ele dispare mais tarde\n          // e cause um unhandled rejection, caso o flush termine antes do tempo.\n          clearTimeout(timeoutId);\n        }\n\n        // Se a execução chegou aqui, o lote foi processado com sucesso.\n        this.#logger.info(\n          `Lote de ${batch.length} itens processado com sucesso.`\n        );\n        lastError = null;\n        break; // Sai do laço de retries.\n      } catch (error) {\n        // Ocorreu uma falha (seja do onFlush ou do timeout).\n        lastError = error;\n\n        if (attempt >= this.#retries) {\n          // Se esta foi a última tentativa, registra um erro definitivo.\n          this.#logger.error(\n            `Falha definitiva ao processar o lote após ${attempt} tentativa(s).`,\n            {\n              errorMessage: error.message,\n              batchSize: batch.length,\n            }\n          );\n        } else {\n          // Se ainda há tentativas, avisa e aguarda o delay para tentar novamente.\n          this.#logger.warn(\n            `Falha na tentativa ${attempt} de processar o lote. Tentando novamente em ${\n              this.#retryDelayMs\n            }ms...`,\n            {\n              errorMessage: error.message,\n            }\n          );\n          await new Promise((resolve) =>\n            setTimeout(resolve, this.#retryDelayMs)\n          );\n        }\n      }\n    }\n\n    // --- Pós-processamento do Lote ---\n\n    // Se um erro persistiu após todas as retries, aciona o callback de falha definitiva.\n    // Este é o gancho para o usuário implementar uma \"dead-letter queue\".\n    if (lastError && this.#callbacks.onFlushFailure) {\n      try {\n        await this.#callbacks.onFlushFailure({\n          batch,\n          error: lastError,\n          payload: this.#payload,\n          serviceContext: this.#serviceContext,\n          logger: this.#logger,\n        });\n        this.#logger.info(\n          `Callback onFlushFailure executado para o lote com falha.`\n        );\n      } catch (failureCallbackError) {\n        // Segurança: captura erros no próprio callback de falha para não quebrar o processador.\n        this.#logger.error(`Erro CRÍTICO no próprio callback onFlushFailure.`, {\n          errorMessage: failureCallbackError.message,\n        });\n      }\n    }\n\n    // --- Finalização e Reativação ---\n\n    // Decrementa o contador de operações ativas, liberando um slot de concorrência.\n    this.#activeFlushes--;\n    this.#logger.info(\n      `Processamento de lote finalizado. Ativos: ${this.#activeFlushes}`\n    );\n    // Dispara um novo ciclo de flush. Esta chamada reativa é a chave para manter\n    // o processador funcionando em capacidade máxima, preenchendo o slot que acabou de ser liberado.\n    this.flush();\n  }\n\n  /**\n   * Finaliza o processador, garantindo que todos os itens pendentes sejam processados.\n   * Este método é idempotente (seguro para ser chamado múltiplas vezes) e DEVE ser\n   * invocado ao final do ciclo de vida da aplicação para evitar perda de dados.\n   *\n   * @param {number} [forceTimeoutMs=30000] - Tempo máximo em milissegundos para aguardar a\n   * finalização dos lotes em processamento. Se o tempo for excedido, o processo é\n   * encerrado e um aviso é logado com os itens restantes.\n   * @returns {Promise<void>} Uma promessa que resolve quando todos os itens forem\n   * processados ou quando o timeout for atingido.\n   */\n  async end(forceTimeoutMs = 30000) {\n    // Garante que a lógica de finalização execute apenas uma vez.\n    if (this.#isEnding) {\n      return;\n    }\n    // Sinaliza para outras partes do processador (como o método `add`) que o desligamento começou.\n    this.#isEnding = true;\n    const endStartTime = Date.now();\n\n    this.#logger.info(\"Finalizando o processador...\", {\n      itemsNoBuffer: this.#buffer.length,\n      activeFlushes: this.#activeFlushes,\n    });\n\n    // Executa o callback de finalização do usuário, se fornecido.\n    if (this.#callbacks.onEnd) {\n      try {\n        await this.#callbacks.onEnd({\n          /* ... */\n        });\n      } catch (error) {\n        this.#logger.error(`Erro no callback onEnd.`, {\n          errorMessage: error.message,\n        });\n      }\n    }\n\n    // Dispara um último ciclo de flush para processar qualquer item restante no buffer.\n    this.flush();\n\n    // Aguarda o \"esvaziamento\" do processador, respeitando o timeout.\n    // O laço continua enquanto houver itens no buffer ou operações de flush ativas.\n    while (\n      (this.#buffer.length > 0 || this.#activeFlushes > 0) &&\n      Date.now() - endStartTime < forceTimeoutMs\n    ) {\n      await new Promise((resolve) => setTimeout(resolve, 50));\n    }\n\n    // Se o laço terminou mas ainda há trabalho pendente, significa que o timeout foi atingido.\n    if (this.#buffer.length > 0 || this.#activeFlushes > 0) {\n      this.#logger.warn(\n        \"Finalização forçada por timeout. Itens não processados foram descartados.\",\n        {\n          remainingItems: this.#buffer.length,\n          activeFlushes: this.#activeFlushes,\n        }\n      );\n    }\n\n    this.#logger.info(\"Processador finalizado.\");\n  }\n}\n\n// =================================================================================================\n// Exportação da classe para o sistema de módulos do Node.js (CommonJS).\n// Permite que a classe seja importada e instanciada em outros arquivos via `require` ou `import`.\n// =================================================================================================\nmodule.exports = BulkProcessor;","/**\n * @fileoverview Fornece uma função para comparar se uma data é anterior a outra.\n * O código é compatível com ambientes Node.js e navegadores.\n */\n\n/**\n * Compara duas datas para determinar se a primeira (dateA) é anterior à segunda (dateB).\n *\n * @summary Verifica se a data A é anterior à data B.\n * @description Esta função compara duas instâncias de Date. Ela oferece opções para\n * ignorar a parte de horas/minutos/segundos, incluir datas iguais na validação e\n * controlar o comportamento em caso de erro.\n *\n * @param {Date} dateA A data que se espera ser a mais antiga.\n * @param {Date} dateB A data que se espera ser a mais recente.\n * @param {object} [options={}] Opções para customizar o comportamento da comparação.\n * @param {boolean} [options.considerHMS=false] Se `true`, a comparação inclui horas, minutos e segundos. Se `false`, apenas ano, mês e dia são considerados.\n * @param {boolean} [options.considerEquals=false] Se `true`, a função retorna `true` caso as datas sejam idênticas. Se `false`, retorna `false`.\n * @param {boolean} [options.ignoreErrors=false] Se `true`, retorna `null` caso os parâmetros não sejam instâncias de Date. Se `false`, lança um erro.\n * @returns {boolean|null} Retorna `true` se `dateA` for anterior (ou igual, se `considerEquals` for `true`) a `dateB`. Retorna `null` em caso de erro com `ignoreErrors` ativado.\n * @throws {TypeError} Lança um erro se `dateA` ou `dateB` não forem objetos Date e `ignoreErrors` for `false`.\n */\nfunction dateCompareAsc(dateA, dateB, options = {}) {\n  // 1. Configuração e Validação dos Parâmetros\n  const finalOptions = {\n    considerHMS: false,\n    ignoreErrors: false,\n    considerEquals: false,\n    ...options,\n  };\n\n  if (!(dateA instanceof Date) || !(dateB instanceof Date)) {\n    if (finalOptions.ignoreErrors) {\n      return null;\n    }\n    // Lança um erro mais específico (TypeError) para o tipo de problema.\n    const paramName = !(dateA instanceof Date) ? \"dateA\" : \"dateB\";\n    throw new TypeError(\n      `dateCompareAsc Function: ${paramName} provided is not a Date Object`\n    );\n  }\n\n  // 2. Lógica de Comparação\n  // O bloco try/catch é mantido para lidar com datas inválidas (ex: new Date('string-invalida')),\n  // que são instâncias de Date, mas cujos métodos (getFullYear, etc.) lançam erros.\n  try {\n    let timeA;\n    let timeB;\n\n    // Remove a parte de horas, minutos e segundos, se a opção estiver desativada.\n    if (!finalOptions.considerHMS) {\n      timeA = new Date(\n        dateA.getFullYear(),\n        dateA.getMonth(),\n        dateA.getDate()\n      ).getTime();\n      timeB = new Date(\n        dateB.getFullYear(),\n        dateB.getMonth(),\n        dateB.getDate()\n      ).getTime();\n    } else {\n      timeA = dateA.getTime();\n      timeB = dateB.getTime();\n    }\n\n    // A expressão booleana combina as duas condições para um retorno verdadeiro.\n    // 1. timeA é estritamente menor que timeB.\n    // 2. timeA é igual a timeB E a opção 'considerEquals' está ativada.\n    return timeA < timeB || (timeA === timeB && finalOptions.considerEquals);\n  } catch (error) {\n    if (finalOptions.ignoreErrors) {\n      return null;\n    }\n    // Re-lança o erro original se a opção de ignorar não estiver ativa.\n    throw error;\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\nmodule.exports = dateCompareAsc;\n// ------------------------------------------------------------------------------------------------\n","/**\n * @fileoverview Fornece uma função para comparar se uma data é posterior a outra.\n * O código é compatível com ambientes Node.js e navegadores.\n */\n\n/**\n * Compara duas datas para determinar se a primeira (dateA) é posterior à segunda (dateB).\n *\n * @summary Verifica se a data A é posterior à data B.\n * @description Esta função compara duas instâncias de Date. Ela oferece opções para\n * ignorar a parte de horas/minutos/segundos, incluir datas iguais na validação e\n * controlar o comportamento em caso de erro.\n *\n * @param {Date} dateA A data que se espera ser a mais recente.\n * @param {Date} dateB A data que se espera ser a mais antiga.\n * @param {object} [options={}] Opções para customizar o comportamento da comparação.\n * @param {boolean} [options.considerHMS=false] Se `true`, a comparação inclui horas, minutos e segundos. Se `false`, apenas ano, mês e dia são considerados.\n * @param {boolean} [options.considerEquals=false] Se `true`, a função retorna `true` caso as datas sejam idênticas. Se `false`, retorna `false`.\n * @param {boolean} [options.ignoreErrors=false] Se `true`, retorna `null` caso os parâmetros não sejam instâncias de Date. Se `false`, lança um erro.\n * @returns {boolean|null} Retorna `true` se `dateA` for posterior (ou igual, se `considerEquals` for `true`) a `dateB`. Retorna `null` em caso de erro com `ignoreErrors` ativado.\n * @throws {Error} Lança um erro se `dateA` ou `dateB` não forem objetos Date e `ignoreErrors` for `false`.\n */\nfunction dateCompareDesc(dateA, dateB, options = {}) {\n  // 1. Configuração e Validação dos Parâmetros\n  const finalOptions = {\n    considerHMS: false,\n    ignoreErrors: false,\n    considerEquals: false,\n    ...options,\n  };\n\n  // Valida 'dateA' e mantém a mensagem de erro original.\n  if (!(dateA instanceof Date)) {\n    if (finalOptions.ignoreErrors) {\n      return null;\n    }\n    throw new Error(\n      \"dateCompareDesc Function: dateA provided is not a Date Object\"\n    );\n  }\n\n  // Valida 'dateB' e mantém a mensagem de erro original.\n  if (!(dateB instanceof Date)) {\n    if (finalOptions.ignoreErrors) {\n      return null;\n    }\n    throw new Error(\n      \"dateCompareDesc Function: dateB provided is not a Date Object\"\n    );\n  }\n\n  // 2. Lógica de Comparação\n  try {\n    let timeA;\n    let timeB;\n\n    // Remove a parte de horas, minutos e segundos, se a opção estiver desativada.\n    if (!finalOptions.considerHMS) {\n      timeA = new Date(\n        dateA.getFullYear(),\n        dateA.getMonth(),\n        dateA.getDate()\n      ).getTime();\n      timeB = new Date(\n        dateB.getFullYear(),\n        dateB.getMonth(),\n        dateB.getDate()\n      ).getTime();\n    } else {\n      timeA = dateA.getTime();\n      timeB = dateB.getTime();\n    }\n\n    // A expressão booleana combina as duas condições para um retorno verdadeiro.\n    // 1. timeA é estritamente maior que timeB.\n    // 2. timeA é igual a timeB E a opção 'considerEquals' está ativada.\n    return timeA > timeB || (timeA === timeB && finalOptions.considerEquals);\n  } catch (error) {\n    if (finalOptions.ignoreErrors) {\n      return null;\n    }\n    // Re-lança o erro original se a opção de ignorar não estiver ativa.\n    throw error;\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\nmodule.exports = dateCompareDesc;\n// ------------------------------------------------------------------------------------------------\n","/**\n * @fileoverview Fornece uma função para retornar um valor padrão caso o valor\n * principal seja nulo ou indefinido.\n */\n\n/**\n * Retorna um valor padrão (`defaultValue`) se o valor verificado (`checkValue`) for `null` ou `undefined`.\n *\n * @summary Retorna um valor padrão para valores nulos ou indefinidos.\n * @description Esta função é um substituto seguro para o operador `||` em casos onde valores\n * como `0`, `false` ou `''` (string vazia) são considerados válidos e não devem ser\n * substituídos pelo valor padrão.\n *\n * @param {*} checkValue - O valor a ser verificado.\n * @param {*} defaultValue - O valor padrão a ser retornado caso `checkValue` seja `null` ou `undefined`.\n * @returns {*} Retorna `checkValue` se ele não for nulo ou indefinido; caso contrário, retorna `defaultValue`.\n * @example\n * // Casos de substituição\n * defaultValue(null, \"padrão\");       // Retorna \"padrão\"\n * defaultValue(undefined, 100);    // Retorna 100\n *\n * // Casos de não substituição (valores \"falsy\" válidos)\n * defaultValue(0, 10);               // Retorna 0\n * defaultValue(\"\", \"texto\");         // Retorna \"\"\n * defaultValue(false, true);         // Retorna false\n *\n * // Caso com valor válido\n * defaultValue(\"olá\", \"mundo\");      // Retorna \"olá\"\n */\nfunction defaultValue(checkValue, defaultValue) {\n  // O operador de coalescência nula (??) executa a mesma lógica da função original\n  // de forma nativa, concisa e performática.\n  return checkValue ?? defaultValue;\n}\n\n// ------------------------------------------------------------------------------------------------\nmodule.exports = defaultValue;\n// ------------------------------------------------------------------------------------------------\n","/**\n * @fileoverview Fornece uma função para verificar se um valor é um objeto.\n */\n\n/**\n * Verifica se um valor fornecido é um objeto, excluindo `null`.\n *\n * @summary Verifica se um valor é um objeto (mas não nulo).\n * @description Esta função retorna `true` para qualquer valor que o JavaScript considera\n * um objeto (`typeof valor === 'object'`), com a exceção explícita de `null`.\n * Note que, devido à natureza do JavaScript, isso inclui arrays e instâncias de outras\n * classes (como `Date`), mas não inclui tipos primitivos.\n *\n * @param {*} object - O valor a ser verificado.\n * @returns {boolean} Retorna `true` se o valor for um objeto e não for `null`; caso contrário, `false`.\n * @example\n * // Casos verdadeiros\n * isObject({});               // true\n * isObject({ a: 1 });       // true\n * isObject([]);               // true (arrays são objetos)\n * isObject(new Date());       // true (instâncias de classe são objetos)\n *\n * // Casos falsos\n * isObject(null);             // false (a principal exceção)\n * isObject(undefined);        // false\n * isObject(\"texto\");          // false (primitivo)\n * isObject(123);              // false (primitivo)\n * isObject(() => {});         // false (funções têm typeof 'function')\n */\nfunction isObject(object) {\n  // A verificação `object !== null` é crucial porque `typeof null` retorna 'object'.\n  // Esta linha combina as duas verificações da função original de forma mais concisa.\n  return object !== null && typeof object === \"object\";\n}\n\n// ------------------------------------------------------------------------------------------------\nmodule.exports = isObject;\n// ------------------------------------------------------------------------------------------------\n","module.exports = {\n  dateCompareAsc: require(\"./dateCompareAsc.js\"),\n  dateCompareDesc: require(\"./dateCompareDesc.js\"),\n  defaultNumeric: require(\"./defaultNumeric.js\"),\n  defaultValue: require(\"./defaultValue.js\"),\n  isInstanceOf: require(\"./isInstanceOf.js\"),\n  isNumber: require(\"./isNumber.js\"),\n  isObject: require(\"./isObject.js\"),\n};\n","/**\n * @file Módulo para mesclar objetos de forma imutável.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.0.0\n */\n\n/**\n * Cria uma cópia profunda (deep clone) de um valor.\n * Esta função auxiliar é a base para garantir a imutabilidade.\n * Ela lida com objetos, arrays e referências circulares.\n *\n * @param {*} source - O valor a ser clonado.\n * @param {WeakMap} [map=new WeakMap()] - Usado internamente para rastrear\n * referências e evitar loops infinitos em estruturas circulares.\n * @returns {*} Uma cópia profunda do valor de entrada.\n * @private\n */\nfunction deepClone(source, map = new WeakMap()) {\n  // Retorna valores primitivos e nulos, que não precisam ser clonados.\n  if (source === null || typeof source !== 'object') {\n    return source;\n  }\n\n  // Se este objeto já foi clonado (em caso de referência circular),\n  // retorna a referência do clone já existente para evitar recursão infinita.\n  if (map.has(source)) {\n    return map.get(source);\n  }\n\n  // Lida com Arrays.\n  if (Array.isArray(source)) {\n    const clone = [];\n    // Armazena o clone no mapa antes da recursão para lidar com\n    // arrays que contenham referências a si mesmos.\n    map.set(source, clone);\n    for (let i = 0; i < source.length; i++) {\n      clone[i] = deepClone(source[i], map);\n    }\n    return clone;\n  }\n\n  // Lida com Objetos.\n  const clone = {};\n  // Armazena o clone no mapa antes da recursão para lidar com\n  // objetos que contenham referências a si mesmos.\n  map.set(source, clone);\n  for (const key in source) {\n    // Garante que estamos copiando apenas as propriedades do próprio objeto.\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      clone[key] = deepClone(source[key], map);\n    }\n  }\n\n  return clone;\n}\n\n\n/**\n * Realiza uma clonagem profunda de dois objetos e, em seguida, mescla as propriedades\n * do objeto `source` no objeto `target`.\n *\n * @description\n * Esta função garante imutabilidade, pois opera em clones dos objetos de entrada,\n * deixando os originais intactos. A mesclagem em si é superficial (similar ao\n * `Object.assign`), o que significa que se uma propriedade existir em ambos os objetos,\n * a propriedade do `source` substituirá completamente a do `target`.\n *\n * @param {object} [target={}] - O objeto de destino. Suas propriedades serão a base\n * para o novo objeto.\n * @param {object} [source={}] - O objeto de origem. Suas propriedades serão mescladas\n * e irão sobrescrever as propriedades do `target` em caso de conflito.\n * @param {boolean} [throwsError=true] - Se `true`, a função lançará exceções em caso\n * de parâmetros inválidos. Se `false`, retornará `null`.\n *\n * @returns {object | null} Um novo objeto resultante da mesclagem ou `null` se\n * `throwsError` for `false` e ocorrer um erro.\n *\n * @throws {TypeError} Lançado se `target` ou `source` não forem objetos.\n * @throws {Error} Lançado se ocorrer um erro durante a operação (ex: stack overflow\n * em objetos excessivamente aninhados).\n *\n * @example\n * const defaults = { settings: { theme: 'dark', notifications: true }, user: 'admin' };\n * const userConfig = { settings: { notifications: false, timezone: 'UTC-3' } };\n *\n * const merged = assign(defaults, userConfig);\n * // Resultado:\n * // {\n * //   settings: { notifications: false, timezone: 'UTC-3' },\n * //   user: 'admin'\n * // }\n *\n * console.log(defaults.settings.theme); // 'dark' (original não foi modificado)\n */\nfunction assign(target = {}, source = {}, throwsError = true) {\n  // Validação rigorosa dos parâmetros de entrada.\n  // A verificação `param === null` é crucial, pois `typeof null` retorna 'object'.\n  if (target === null || typeof target !== 'object') {\n    if (throwsError) {\n      throw new TypeError(\"Assign Function: The target provided is not an object\");\n    }\n    return null;\n  }\n\n  if (source === null || typeof source !== 'object') {\n    if (throwsError) {\n      throw new TypeError(\"Assign Function: The source provided is not an object\");\n    }\n    return null;\n  }\n\n  try {\n    // Utiliza nossa implementação de clonagem profunda customizada e compatível.\n    // Isso garante que os objetos originais (`target` e `source`) não sejam modificados (imutabilidade).\n    const clonedTarget = deepClone(target);\n    const clonedSource = deepClone(source);\n\n    // `Object.assign` realiza a mesclagem superficial das propriedades do clone\n    // de `source` para o clone de `target`. Esta é a forma mais eficiente de\n    // combinar as propriedades no nível superior dos objetos.\n    return Object.assign(clonedTarget, clonedSource);\n  } catch (error) {\n    if (throwsError) {\n      // Repassa o erro original para fornecer um contexto de depuração mais rico.\n      throw error;\n    }\n    // Retorna null se a captura de erros estiver desativada e ocorrer uma falha.\n    return null;\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\n// Garante compatibilidade com o sistema de módulos CommonJS (Node.js).\nmodule.exports = assign;\n\n// ------------------------------------------------------------------------------------------------","/**\n * @file Utilitário para conversão de Base64URL para Base64 padrão.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.0.0\n */\n\n/**\n * @summary Converte uma string do formato Base64URL para o formato Base64 padrão.\n *\n * @description\n * O formato Base64URL é uma variação do Base64 projetada para ser segura em URLs e nomes de arquivo.\n * Ele substitui os caracteres `+` e `/` por `-` e `_`, respectivamente, e geralmente omite o\n * preenchimento (`=`) no final da string.\n *\n * Esta função reverte essas substituições e restaura o preenchimento (`=`)\n * necessário para que a string seja uma representação Base64 válida, cujo comprimento\n * deve ser um múltiplo de 4.\n *\n * @param {string} [urlSafeBase64=\"\"] - A string em formato Base64URL a ser convertida.\n *\n * @returns {string} A string convertida para o formato Base64 padrão.\n *\n * @example\n * // Exemplo com uma string que precisa de preenchimento\n * const urlSafeString = 'rqXRQrq_mSFhX4c2wSZJrA';\n * const standardBase64 = base64FromBase64URLSafe(urlSafeString);\n * console.log(standardBase64); // \"rqXRQrq/mSFhX4c2wSZJrA==\"\n *\n * // Exemplo com uma string que não precisa de preenchimento\n * const anotherUrlSafeString = 'Zm9vYg';\n * const anotherStandardBase64 = base64FromBase64URLSafe(anotherUrlSafeString);\n * console.log(anotherStandardBase64); // \"Zm9vYg==\"\n */\nfunction base64FromBase64URLSafe(urlSafeBase64 = \"\") {\n  // Validação explícita para garantir que a entrada é uma string não vazia.\n  if (typeof urlSafeBase64 !== 'string' || urlSafeBase64.length === 0) {\n    return \"\";\n  }\n\n  // 1. Substitui os caracteres específicos do Base64URL pelos do Base64 padrão.\n  // O uso da flag /g garante que todas as ocorrências sejam substituídas.\n  const base64 = urlSafeBase64.replace(/-/g, \"+\").replace(/_/g, \"/\");\n\n  // 2. Calcula e adiciona o preenchimento ('=') de forma eficiente.\n  // O método `padEnd` é mais performático e declarativo que um loop `while`.\n  // Ele calcula quantos caracteres `=` são necessários e os adiciona de uma só vez.\n  const requiredPadding = (4 - (base64.length % 4)) % 4;\n  return base64.padEnd(base64.length + requiredPadding, \"=\");\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = base64FromBase64URLSafe;","/**\n * @file Utilitário seguro e robusto para conversão de valores para string.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.1.0\n */\n\n/**\n * @summary Converte um valor de qualquer tipo para uma string de forma segura.\n *\n * @description\n * Esta função é uma versão mais robusta do construtor `String()`. Ela prioriza o método\n * `.toString()` customizado de um objeto. Apenas se um objeto não tiver um `.toString()`\n * customizado (resultando no padrão `\"[object Object]\"`), a função tentará convertê-lo\n * para uma string JSON.\n *\n * @param {*} [textObj=\"\"] - O valor a ser convertido para string.\n * @param {boolean} [objectToJSON=true] - Se `true` e a entrada for um objeto sem `.toString()`\n * customizado, tenta convertê-lo para uma string JSON.\n *\n * @returns {string} A representação do valor como string.\n *\n * @example\n * const custom = { toString: () => 'Custom!' };\n * toString(custom);           // 'Custom!'\n *\n * toString({ a: 1 });         // '{\"a\":1}'\n * toString({ a: 1 }, false);  // '[object Object]'\n * toString(123);              // '123'\n * toString(null);             // ''\n */\nfunction toString(textObj = \"\", objectToJSON = true) {\n  // 1. Lida com `null` e `undefined` primeiro, retornando uma string vazia.\n  if (textObj == null) {\n    return \"\";\n  }\n\n  // 2. Realiza a conversão inicial para string.\n  // O construtor `String()` invoca corretamente o método `.toString()` do objeto.\n  const initialString = String(textObj);\n\n  // 3. Verifica se a conversão inicial resultou na string genérica de objeto.\n  // O `typeof` previne que a string literal \"[object Object]\" seja convertida para JSON.\n  if (\n    objectToJSON &&\n    initialString === '[object Object]' &&\n    typeof textObj === 'object'\n  ) {\n    try {\n      // Se for um objeto genérico, tenta uma conversão JSON mais informativa.\n      return JSON.stringify(textObj);\n    } catch (error) {\n      // Se o JSON falhar (ex: referência circular), retorna a string genérica.\n      return initialString;\n    }\n  }\n\n  // 4. Se não for um objeto genérico (ou se for um primitivo, array, ou objeto customizado),\n  // a conversão inicial já é a correta.\n  return initialString;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = toString;","const toString = require(\"./toString\");\nconst base64To = require(\"./base64To\");\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário para codificação no formato Base64URL.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.0.0\n */\n\n/**\n * @summary Codifica uma entrada para o formato Base64URL.\n *\n * @description\n * Esta função converte qualquer valor de entrada para uma string no formato Base64URL.\n * O Base64URL é uma variação do Base64 padrão, segura para uso em URLs e nomes de arquivo,\n * pois substitui os caracteres `+` e `/` por `-` e `_`, respectivamente, e omite o\n * preenchimento final (`=`). A função é cross-environment, funcionando em Node.js e navegadores.\n *\n * @param {*} [text=\"\"] - O valor a ser codificado. Será convertido para string antes do processo.\n * @param {BufferEncoding} [fromFormat=\"utf8\"] - **(Apenas Node.js)** A codificação da entrada,\n * se for uma string em um formato diferente de UTF-8 (ex: 'hex').\n *\n * @returns {string} A string resultante no formato Base64URL.\n *\n * @example\n * // A string \"subjects?_id=1&_id=2\" contém caracteres que não são seguros em URLs.\n * const queryString = 'subjects?_id=1&_id=2';\n * const encodedQuery = base64URLEncode(queryString);\n * console.log(encodedQuery); // \"c3ViamVjdHM_X2lkPTEmX2lkPTI\"\n *\n * // A saída pode ser usada com segurança em uma URL:\n * // https://example.com/q=c3ViamVjdHM_X2lkPTEmX2lkPTI\n */\nfunction base64URLEncode(text = \"\", fromFormat = \"utf8\") {\n  // 1. Delega a conversão para string e a codificação Base64 para a função `base64To`.\n  // A função `base64To` já lida com diferentes tipos de entrada e remove o preenchimento (`=`).\n  const standardBase64 = base64To(toString(text), fromFormat);\n\n  // 2. Converte a saída do Base64 padrão para o formato URL-safe.\n  // Substitui os caracteres '+' por '-' e '/' por '_'.\n  return standardBase64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = base64URLEncode;","/**\n * @file Utilitário para calcular timestamps baseados em segundos.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.0.0\n */\n\n/**\n * @summary Calcula um timestamp futuro ou passado a partir do tempo atual.\n *\n * @description\n * Esta função adiciona ou subtrai um determinado número de segundos do tempo atual\n * (`Date.now()`) e retorna o resultado como um timestamp numérico (milissegundos\n * desde a Época Unix). A operação é puramente aritmética, garantindo alta performance.\n *\n * @param {number} seconds - O número de segundos a ser adicionado ou subtraído.\n * Deve ser um número finito.\n * @param {boolean} [add=true] - Determina a operação. Se `true`, os segundos são\n * adicionados (calculando um tempo futuro). Se `false`, são subtraídos\n * (calculando um tempo passado).\n *\n * @returns {number | null} O timestamp calculado em milissegundos, ou `null` se\n * o valor de `seconds` for inválido.\n *\n * @example\n * // Calcula o timestamp para 5 minutos (300 segundos) no futuro\n * const fiveMinutesFromNow = calculateSecondsInTime(300);\n * console.log(`Timestamp em 5 minutos: ${fiveMinutesFromNow}`);\n *\n * // Calcula o timestamp para 1 hora (3600 segundos) no passado\n * const oneHourAgo = calculateSecondsInTime(3600, false);\n * console.log(`Timestamp de 1 hora atrás: ${oneHourAgo}`);\n */\nfunction calculateSecondsInTime(seconds, add = true) {\n  // 1. Validação: garante que `seconds` é um número válido e finito.\n  // `isFinite` trata casos como `Infinity`, `-Infinity` e `NaN`.\n  if (typeof seconds !== 'number' || !isFinite(seconds)) {\n    return null;\n  }\n\n  // 2. Converte a entrada de segundos para milissegundos.\n  const offsetInMilliseconds = seconds * 1000;\n\n  // 3. Aplica a operação e retorna o timestamp final.\n  // Esta abordagem é mais direta e performática do que criar um novo objeto `Date`.\n  if (add) {\n    return Date.now() + offsetInMilliseconds;\n  }\n\n  return Date.now() - offsetInMilliseconds;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = calculateSecondsInTime;","const toString = require(\"./toString.js\");\nconst isNumber = require(\"../helpers/isNumber.js\");\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário para converter strings de moeda brasileira (BRL) para um número.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.1.0\n */\n\n/**\n * @summary Converte uma string de moeda no formato brasileiro (BRL) para um número de ponto flutuante.\n *\n * @description\n * Esta função analisa uma string que representa um valor monetário em Reais (ex: \"R$ 1.234,56\")\n * e a converte para um número puro (ex: 1234.56). Se a entrada já for um número válido,\n * ela é retornada diretamente.\n *\n * @param {string | number} moneyValue - O valor monetário a ser convertido.\n *\n * @returns {number | false} O número de ponto flutuante correspondente, ou `false` se a\n * conversão falhar ou a entrada for inválida.\n *\n * @example\n * currencyBRToFloat(\"R$ 1.234,56\"); // Retorna 1234.56\n * currencyBRToFloat(\"1A23,45\");      // Retorna false\n * currencyBRToFloat(\"\");            // Retorna false\n * currencyBRToFloat(150.75);        // Retorna 150.75\n */\nfunction currencyBRToFloat(moneyValue) {\n  // 1. Validação de Entrada\n  // Retorna `false` para entradas nulas ou indefinidas.\n  if (moneyValue == null) {\n    return false;\n  }\n\n  // Se a entrada já for um número válido, retorna-o diretamente.\n  if (isNumber(moneyValue)) {\n    return moneyValue;\n  }\n\n  // 2. Limpeza e Formatação da String\n  const cleanedString = toString(moneyValue)\n    // Remove o símbolo 'R$', espaços em branco e pontos (separador de milhar).\n    .replace(/R\\$|\\s|\\./g, \"\")\n    // Substitui a vírgula (separador decimal brasileiro) por um ponto.\n    .replace(\",\", \".\");\n\n  // 3. Validação de Caracteres Inválidos\n  // Esta verificação impede que `parseFloat` interprete parcialmente uma string\n  // inválida (ex: \"1A2B\" se tornaria 1). A regex `/[^0-9.]/` procura por\n  // qualquer caractere que não seja um dígito (0-9) ou um ponto (.).\n  if (/[^0-9.]/.test(cleanedString)) {\n    return false;\n  }\n\n  // Se a string ficar vazia ou contiver apenas um ponto após a limpeza, é inválida.\n  if (cleanedString === \"\" || cleanedString === \".\") {\n    return false;\n  }\n  \n  // 4. Conversão e Validação Final\n  const result = parseFloat(cleanedString);\n\n  // Verifica se o resultado do `parseFloat` é um número finito.\n  if (isNumber(result)) {\n    return result;\n  }\n\n  // Se a conversão falhou, retorna `false`.\n  return false;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = currencyBRToFloat;","const { DATE_BR_FORMAT_D } = require(\"../constants.js\");\nconst { format } = require(\"date-fns/format\");\nconst isInstanceOf = require(\"../helpers/isInstanceOf.js\");\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário para formatar objetos Date em strings usando date-fns.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.1.0\n */\n\n/**\n * @summary Formata um objeto Date em uma string, com base em um padrão de formato.\n *\n * @description\n * Esta função atua como um wrapper seguro para a função `format` da biblioteca `date-fns`.\n * Ela adiciona uma camada de validação robusta para garantir que apenas objetos `Date`\n * válidos sejam passados para a função de formatação, prevenindo erros.\n *\n * @param {Date} date - O objeto `Date` a ser formatado.\n * @param {string} [stringFormat=DATE_BR_FORMAT_D] - O padrão de formatação, compatível\n * com `date-fns`. O padrão no Brasil é 'dd/MM/yyyy'.\n *\n * @returns {string | false} A string da data formatada, ou `false` se a entrada\n * não for um objeto `Date` válido.\n *\n * @example\n * const myDate = new Date('2025-08-21T15:30:45');\n * dateToFormat(myDate); // \"21/08/2025\" (usando o padrão)\n * dateToFormat(myDate, 'yyyy-MM-dd HH:mm:ss.SSS'); // \"2025-08-21 15:30:45.000\"\n * dateToFormat('texto invalido'); // false\n */\nfunction dateToFormat(date, stringFormat = DATE_BR_FORMAT_D) {\n  // 1. Validação do tipo e do valor da data.\n  // A checagem `isNaN` trata casos como `new Date('data inválida')`.\n  if (!isInstanceOf(date, Date) || isNaN(date.getTime())) {\n    // Retorna o booleano `false` para manter a consistência com os testes do projeto.\n    return false;\n  }\n\n  // 2. Delega a formatação para a função `format` da biblioteca `date-fns`.\n  // Isso garante suporte completo a todos os tokens de formato que a biblioteca oferece.\n  return format(date, stringFormat);\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = dateToFormat;","/**\n * @file Utilitário para criar uma função \"debounced\".\n * @author Seu Nome <seu.email@example.com>\n * @version 2.0.0\n */\n\n/**\n * @summary Cria uma versão \"debounced\" de uma função, que atrasa sua execução.\n *\n * @description\n * Debounce é uma técnica que agrupa uma sequência de chamadas de uma função que ocorrem\n * rapidamente, executando-a apenas uma vez após um determinado período de inatividade.\n * É útil para controlar eventos que disparam com muita frequência, como a digitação em um\n * campo de busca, o redimensionamento da janela ou o scroll da página.\n *\n * Esta função retorna uma nova função que, ao ser invocada, reinicia um temporizador.\n * A função original (`callback`) só será executada quando o temporizador não for mais\n * reiniciado por um período igual a `timeout`.\n *\n * @param {Function} callback - A função que terá sua execução atrasada. Pode ser síncrona ou assíncrona.\n * @param {number} [timeout=1000] - O período de inatividade em milissegundos que deve\n * aguardar antes de executar o `callback`.\n *\n * @returns {(...args: any[]) => void} Uma nova função \"debounced\" que pode ser chamada no lugar da original.\n *\n * @throws {TypeError} Lança um erro se o `callback` não for uma função ou se `timeout` não for um número.\n *\n * @example\n * // Simula uma barra de busca que só pesquisa após o usuário parar de digitar.\n * const searchAPI = (query) => {\n * console.log(`Pesquisando por: \"${query}\"...`);\n * };\n *\n * const debouncedSearch = debouncer(searchAPI, 500);\n *\n * debouncedSearch('g');\n * debouncedSearch('ga');\n * debouncedSearch('gam');\n * debouncedSearch('gami');\n * // Após 500ms de inatividade, o console irá logar: \"Pesquisando por: \"gami\"...\"\n */\nfunction debouncer(callback, timeout = 1000) {\n  // 1. Validação dos parâmetros na criação da função.\n  if (typeof callback !== 'function') {\n    throw new TypeError('O callback fornecido para o debouncer deve ser uma função.');\n  }\n  if (typeof timeout !== 'number') {\n    throw new TypeError('O timeout do debouncer deve ser um número.');\n  }\n\n  // 2. Closure para manter a referência do temporizador entre as chamadas.\n  let timer;\n\n  // 3. Retorna a nova função \"debounced\".\n  // Usa uma função regular `function(...args)` para preservar o contexto `this` de quem a chama.\n  return function(...args) {\n    // Captura o contexto (`this`) e os argumentos da chamada atual.\n    const context = this;\n\n    // Cancela o temporizador anterior para reiniciar a contagem.\n    // Isso garante que o callback só execute após o período de inatividade.\n    clearTimeout(timer);\n\n    // Inicia um novo temporizador.\n    timer = setTimeout(() => {\n      // Executa o callback original, aplicando o contexto e os argumentos corretos da última chamada.\n      callback.apply(context, args);\n    }, timeout);\n  };\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = debouncer;","const isObject = require(\"../helpers/isObject.js\");\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário para remover chaves de um objeto de forma não-mutável.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.0.0\n */\n\n/**\n * @summary Cria um novo objeto omitindo um conjunto de chaves especificadas.\n *\n * @description\n * Esta função recebe um objeto e um array de chaves, e retorna um **novo** objeto\n * contendo todas as propriedades do objeto original, exceto aquelas especificadas\n * no array de chaves.\n *\n * A função é **não-mutável**, o que significa que o objeto original passado como\n * argumento não é modificado.\n *\n * @param {object} [object={}] - O objeto de origem.\n * @param {string[]} [keys=[]] - Um array com os nomes (string) das chaves a serem omitidas.\n *\n * @returns {object} Um novo objeto sem as chaves especificadas.\n *\n * @example\n * const user = {\n * id: 123,\n * name: 'Arthur',\n * email: 'arthur@example.com',\n * password: 'supersecret'\n * };\n *\n * const publicUser = deleteKeys(user, ['password', 'email']);\n *\n * console.log(publicUser); // { id: 123, name: 'Arthur' }\n * console.log(user);       // O objeto original permanece inalterado\n */\nfunction deleteKeys(object = {}, keys = []) {\n  // 1. Validação da entrada.\n  if (!isObject(object)) {\n    return object;\n  }\n  if (!Array.isArray(keys)) {\n    // Retorna uma cópia rasa se o array de chaves for inválido, garantindo a não-mutação.\n    return { ...object };\n  }\n\n  // 2. Cria uma cópia rasa do objeto para evitar a mutação do original.\n  const newObject = { ...object };\n\n  // 3. Itera sobre as chaves a serem removidas e as deleta da CÓPIA.\n  for (const key of keys) {\n    delete newObject[key];\n  }\n\n  // 4. Retorna o novo objeto modificado.\n  return newObject;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = deleteKeys;","const toString = require(\"./toString\");\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário para gerar um ID de string simples.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.0.0\n */\n\n/**\n * @summary Gera um ID de string simples com alta probabilidade de ser único.\n *\n * @description\n * Esta função cria um ID combinando um prefixo opcional, o timestamp atual em\n * milissegundos, e uma sequência de bytes aleatórios e criptograficamente seguros\n * convertidos para hexadecimal.\n *\n * O formato do ID resultante é: `[prefixo<separador>]<timestamp><separador><bytesAleatoriosHex>`\n *\n * A utilização de `crypto.getRandomValues` torna a parte aleatória do ID muito menos\n * previsível do que `Math.random()`, aumentando a resistência a colisões.\n *\n * @param {string | number} [id] - Um prefixo opcional para o ID. Será convertido para string.\n * @param {string} [separator=\"_\"] - O separador a ser usado entre as partes do ID.\n *\n * @returns {string} O novo ID de string gerado.\n *\n * @example\n * // Gera um ID com o prefixo \"user\"\n * // Exemplo de saída: \"user_1724276767000_a1b2c3d4e5f6\"\n * const userId = generateSimpleId(\"user\");\n *\n * // Gera um ID sem prefixo\n * // Exemplo de saída: \"1724276767000_a1b2c3d4e5f6\"\n * const eventId = generateSimpleId();\n */\nfunction generateSimpleId(id, separator = \"_\") {\n  // 1. Gera a parte aleatória do ID de forma segura.\n  // Cria um array de 6 bytes, que resultará em 12 caracteres hexadecimais.\n  const randomBytes = new Uint8Array(6);\n  globalThis.crypto.getRandomValues(randomBytes);\n\n  // Converte os bytes para uma string hexadecimal, garantindo que cada byte seja representado por 2 caracteres.\n  const randomHex = Array.from(randomBytes)\n    .map(byte => byte.toString(16).padStart(2, '0'))\n    .join('');\n\n  // 2. Constrói as partes do ID em um array para maior clareza.\n  const parts = [];\n  const idString = toString(id);\n\n  // Adiciona o prefixo apenas se ele for fornecido e não for uma string vazia.\n  if (idString) {\n    parts.push(idString);\n  }\n\n  // Adiciona o timestamp e a parte aleatória segura.\n  parts.push(Date.now());\n  parts.push(randomHex);\n\n  // 3. Junta as partes com o separador e retorna o ID final.\n  return parts.join(separator);\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = generateSimpleId;","/**\n * @file Utilitário para gerar strings aleatórias seguras.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.0.0\n */\n\n// Define os conjuntos de caracteres como constantes para clareza e reutilização.\nconst CHAR_SETS = {\n  LOWERCASE: 'abcdefghijklmnopqrstuvwxyz',\n  UPPERCASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n  ACCENTED: 'àáâãçèéêìíîðñòóôõùúûý',\n  DIGITS: '0123456789',\n  SYMBOLS: '!@#$%^&*-_+=;:,.<>?'\n};\n\n/**\n * @summary Gera uma string aleatória criptograficamente segura.\n *\n * @description\n * Esta função gera uma string aleatória com um tamanho especificado, usando um conjunto de\n * caracteres customizável. Ela utiliza a Web Crypto API (`crypto.getRandomValues`),\n * que está disponível em navegadores modernos e no Node.js, para garantir que os\n * caracteres sejam selecionados de forma segura e imprevisível, tornando-a adequada\n * para gerar senhas, tokens ou outros valores sensíveis.\n *\n * @param {number} [size=32] - O comprimento da string a ser gerada.\n * @param {object} [options={}] - Opções para customizar o conjunto de caracteres.\n * @param {boolean} [options.excludeLowerCaseChars=false] - Excluir caracteres minúsculos.\n * @param {boolean} [options.excludeUpperCaseChars=false] - Excluir caracteres maiúsculos.\n * @param {boolean} [options.excludeAccentedChars=false] - Excluir caracteres acentuados.\n * @param {boolean} [options.excludeDigits=false] - Excluir dígitos numéricos.\n * @param {boolean} [options.excludeSymbols=false] - Excluir símbolos padrão.\n * @param {string} [options.includeSymbols=\"\"] - Uma string com símbolos adicionais\n * para incluir no conjunto de caracteres.\n *\n * @returns {string} A string aleatória gerada.\n */\nfunction generateRandomString(size = 32, options = {}) {\n  // 1. Define as opções padrão e as mescla com as fornecidas pelo usuário.\n  // Isso garante que o envio de opções parciais (ex: { excludeDigits: true }) funcione corretamente.\n  const defaultOptions = {\n    excludeLowerCaseChars: false,\n    excludeUpperCaseChars: false,\n    excludeAccentedChars: false,\n    excludeDigits: false,\n    excludeSymbols: false,\n    includeSymbols: \"\"\n  };\n  const finalOptions = { ...defaultOptions, ...options };\n\n  // 2. Constrói a string de caracteres válidos com base nas opções.\n  let validChars = finalOptions.includeSymbols;\n  if (!finalOptions.excludeLowerCaseChars) validChars += CHAR_SETS.LOWERCASE;\n  if (!finalOptions.excludeUpperCaseChars) validChars += CHAR_SETS.UPPERCASE;\n  if (!finalOptions.excludeAccentedChars) validChars += CHAR_SETS.ACCENTED;\n  if (!finalOptions.excludeDigits) validChars += CHAR_SETS.DIGITS;\n  if (!finalOptions.excludeSymbols) validChars += CHAR_SETS.SYMBOLS;\n\n  // Se não houver caracteres válidos ou o tamanho for zero, retorna uma string vazia.\n  if (validChars.length === 0 || size <= 0) {\n    return \"\";\n  }\n\n  // 3. Gera a string aleatória usando uma fonte criptograficamente segura.\n  const randomValues = new Uint32Array(size);\n  // `crypto.getRandomValues` preenche o array com números aleatórios seguros.\n  // `globalThis` garante compatibilidade entre Node.js, navegadores e web workers.\n  globalThis.crypto.getRandomValues(randomValues);\n\n  let result = [];\n  for (let i = 0; i < size; i++) {\n    // Usa o operador de módulo para mapear o número aleatório a um índice válido.\n    const randomIndex = randomValues[i] % validChars.length;\n    result.push(validChars[randomIndex]);\n  }\n\n  return result.join('');\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = generateRandomString;","/**\n * @file Utilitário de alta precisão para medir o tempo de execução.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.0.0\n */\n\n/**\n * @summary Mede o tempo de execução com alta precisão (em milissegundos).\n *\n * @description\n * Esta função é um cronômetro de alta precisão que funciona de duas maneiras:\n * 1. **Sem argumentos:** `getExecutionTime()` - Retorna um \"token\" de tempo de alta resolução,\n * servindo como um ponto de partida para a medição.\n * 2. **Com argumento:** `getExecutionTime(startTime)` - Retorna a diferença de tempo (em milissegundos)\n * entre o momento atual e o `startTime` fornecido.\n *\n * Utiliza `process.hrtime.bigint()` no Node.js e `performance.now()` no navegador\n * para garantir a maior precisão possível em cada ambiente.\n *\n * @param {number | bigint} [time] - Opcional. Um marcador de tempo obtido previamente ao\n * chamar esta mesma função sem argumentos.\n *\n * @returns {number | bigint | string} Se `time` não for fornecido, retorna o marcador inicial (`bigint` no Node.js,\n * `number` no navegador). Se `time` for fornecido, retorna o tempo decorrido como uma `string`\n * formatada com 3 casas decimais.\n *\n * @example\n * const startTime = getExecutionTime();\n *\n * // Simula uma operação que demora ~50ms\n * await new Promise(resolve => setTimeout(resolve, 50));\n *\n * const duration = getExecutionTime(startTime);\n * console.log(`A operação demorou ${duration} ms.`); // Ex: \"A operação demorou 50.123 ms.\"\n */\nfunction getExecutionTime(time) {\n  // **Ambiente Node.js:** usa `process.hrtime.bigint()` para precisão em nanossegundos.\n  if (typeof process !== 'undefined' && typeof process.hrtime === 'function') {\n    // Modo 1: Retorna o tempo atual em nanossegundos como um BigInt para ser o marcador inicial.\n    if (time === undefined) {\n      return process.hrtime.bigint();\n    }\n\n    // Validação para o marcador de tempo do Node.js.\n    if (typeof time !== 'bigint') {\n        return '0.000';\n    }\n\n    // Modo 2: Calcula a diferença em nanossegundos.\n    const diffNanos = process.hrtime.bigint() - time;\n    // Converte a diferença para milissegundos e formata.\n    const diffMillis = Number(diffNanos) / 1e6;\n    return diffMillis.toFixed(3);\n  }\n\n  // **Ambiente do Navegador:** usa `performance.now()` para precisão em milissegundos.\n  if (typeof performance !== 'undefined' && typeof performance.now === 'function') {\n    // Modo 1: Retorna o tempo atual em milissegundos como o marcador inicial.\n    if (time === undefined) {\n      return performance.now();\n    }\n\n    // Validação para o marcador de tempo do navegador.\n    if (typeof time !== 'number' || !isFinite(time)) {\n      return '0.000';\n    }\n\n    // Modo 2: Calcula a diferença e formata.\n    const diffMillis = performance.now() - time;\n    return diffMillis.toFixed(3);\n  }\n\n  // Fallback para ambientes muito antigos (raro). Retorna o tempo atual em ms.\n  // Este modo não suporta medição de diferença de forma precisa.\n  return (Date.now()).toFixed(3);\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = getExecutionTime;","/**\n * @file Utilitário seguro para analisar (parse) strings JSON.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.0.0\n */\n\n/**\n * @summary Analisa uma string JSON de forma segura, com controle sobre o lançamento de erros.\n *\n * @description\n * Esta função é um wrapper para `JSON.parse()` que simplifica o tratamento de erros.\n * Em vez de precisar envolver cada chamada em um bloco `try...catch`, você pode\n * controlar o comportamento em caso de falha através do parâmetro `throwsError`.\n *\n * @param {string} text - A string JSON a ser analisada.\n * @param {boolean} [throwsError=true] - Se `true`, a função lançará uma exceção em caso de\n * JSON inválido (comportamento padrão de `JSON.parse`). Se `false`, retornará `null`.\n *\n * @returns {any | null} O valor ou objeto JavaScript resultante da análise, ou `null` se\n * a análise falhar e `throwsError` for `false`. `JSON.parse` pode retornar qualquer\n * tipo de dado JSON válido (objetos, arrays, strings, números, etc.).\n *\n * @throws {SyntaxError | TypeError} Lança um `TypeError` se a entrada não for uma string,\n * ou um `SyntaxError` se a string for um JSON inválido (e `throwsError` for `true`).\n *\n * @example\n * const jsonValido = '{\"id\": 1, \"name\": \"Arthur\"}';\n * const jsonInvalido = '{\"id\": 1, name: \"Arthur\"}'; // `name` sem aspas\n *\n * // Comportamento seguro (retorna null em caso de erro)\n * const resultado = JSONFrom(jsonInvalido, false);\n * console.log(resultado); // null\n *\n * // Comportamento padrão (lança erro)\n * try {\n * JSONFrom(jsonInvalido, true);\n * } catch (e) {\n * console.error(e.message); // Unexpected token n in JSON at position 11...\n * }\n *\n * const objeto = JSONFrom(jsonValido);\n * console.log(objeto.name); // \"Arthur\"\n */\nfunction JSONFrom(text, throwsError = true) {\n  // 1. Validação do tipo de entrada. `JSON.parse` espera uma string.\n  if (typeof text !== \"string\") {\n    if (throwsError) {\n      throw new TypeError(\"A entrada para JSONFrom deve ser uma string.\");\n    }\n    return null;\n  }\n\n  try {\n    // 2. Tenta analisar a string.\n    return JSON.parse(text);\n  } catch (error) {\n    // 3. Lida com erros de análise com base na opção fornecida.\n    if (throwsError) {\n      // Re-lança o erro original de `JSON.parse`.\n      throw error;\n    }\n\n    // Se os erros não devem ser lançados, retorna null.\n    return null;\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = JSONFrom;\n","/**\n * @file Utilitário seguro para converter valores JavaScript em strings JSON.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.0.0\n */\n\n/**\n * @summary Converte um valor JavaScript para uma string JSON de forma segura.\n *\n * @description\n * Esta função é um wrapper para `JSON.stringify()` que simplifica o tratamento de erros.\n * `JSON.stringify` pode lançar uma exceção ao tentar serializar estruturas com\n * referências circulares ou valores `BigInt`. Esta função permite capturar esses erros\n * e retornar `null` em vez de quebrar a execução do programa.\n *\n * @param {any} object - O valor JavaScript (objeto, array, primitivo, etc.) a ser convertido.\n * @param {boolean} [throwsError=true] - Se `true`, a função lançará uma exceção em caso de\n * erro na serialização. Se `false`, retornará `null`.\n *\n * @returns {string | null} A string JSON resultante, ou `null` se a serialização falhar e\n * `throwsError` for `false`.\n *\n * @throws {TypeError} Lança um `TypeError` se o valor contiver referências circulares\n * ou um `BigInt` (e `throwsError` for `true`).\n *\n * @example\n * const user = { id: 1, name: 'Arthur' };\n * const jsonString = JSONTo(user);\n * console.log(jsonString); // '{\"id\":1,\"name\":\"Arthur\"}'\n *\n * // Exemplo com referência circular, que normalmente quebraria a aplicação\n * const obj = { name: 'obj' };\n * obj.self = obj;\n *\n * // Comportamento seguro (retorna null)\n * const resultado = JSONTo(obj, false);\n * console.log(resultado); // null\n *\n * // Comportamento padrão (lança erro)\n * try {\n * JSONTo(obj, true);\n * } catch (e) {\n * console.error(e.message); // Ex: \"Converting circular structure to JSON...\"\n * }\n */\nfunction JSONTo(object = {}, throwsError = true) {\n  try {\n    // 1. Tenta converter o valor para uma string JSON.\n    return JSON.stringify(object);\n  } catch (error) {\n    // 2. Lida com erros de serialização (ex: referências circulares).\n    if (throwsError) {\n      // Re-lança o erro original, mantendo o comportamento padrão do JavaScript.\n      throw error;\n    }\n\n    // Se os erros não devem ser lançados, retorna null.\n    return null;\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = JSONTo;","const { encrypt } = require(\"../crypto\");\nconst base64To = require(\"../utils/base64To\");\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @summary Encripta uma mensagem em pedaços (chunks) usando RSA-OAEP.\n *\n * @description\n * Esta função assíncrona primeiro converte a mensagem para uma string Base64 para garantir\n * a consistência dos dados. Em seguida, divide essa string em pedaços e encripta cada\n * um em paralelo para máxima performance. O resultado é um array de strings, onde\n * cada uma representa um pedaço encriptado.\n *\n * @param {CryptoKey} publicKey - A chave pública RSA (formato `CryptoKey`) a ser usada.\n * @param {string} message - A mensagem de texto a ser encriptada.\n * @param {object} [props={}] - Propriedades adicionais para a encriptação.\n * @param {number} [props.chunkSize=190] - O tamanho de cada pedaço da string Base64.\n *\n * @returns {Promise<string[]>} Uma Promise que resolve para um array de pedaços encriptados.\n */\nasync function messageEncryptToChunks(publicKey, message, props = {}) {\n  // 1. Converte a mensagem para Base64 PRIMEIRO.\n  // Esta etapa é crucial para a consistência do sistema e o tratamento de caracteres especiais.\n  const message64 = base64To(message);\n\n  const chunkSize = props.chunkSize || 190;\n  const chunks = [];\n\n  // 2. Divide a string Base64 em pedaços (chunks).\n  for (let i = 0; i < message64.length; i += chunkSize) {\n    chunks.push(message64.substring(i, i + chunkSize));\n  }\n\n  // 3. Cria um array de Promises para encriptar cada pedaço da string Base64.\n  const encryptionPromises = chunks.map(chunk => \n    encrypt(publicKey, chunk, props)\n  );\n\n  // 4. Executa todas as encriptações em paralelo para máxima performance.\n  return Promise.all(encryptionPromises);\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = messageEncryptToChunks;","const { decrypt } = require(\"../crypto\");\nconst base64From = require(\"../utils/base64From\");\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @summary Decripta uma mensagem a partir de pedaços (chunks) encriptados.\n *\n * @description\n * Esta função assíncrona recebe um array de pedaços encriptados, decripta cada um\n * deles em paralelo para máxima performance, e então une os resultados (que são pedaços\n * de uma string Base64) para reconstruir e decodificar a mensagem de texto original.\n *\n * @param {CryptoKey} privateKey - A chave privada RSA (formato `CryptoKey`) a ser usada.\n * @param {string[]} messageChunks - Um array de strings, onde cada uma é um pedaço encriptado.\n * @param {object} [props={}] - Propriedades adicionais para a decriptação.\n *\n * @returns {Promise<string>} Uma Promise que resolve para a mensagem original decriptada.\n */\nasync function messageDecryptFromChunks(privateKey, messageChunks, props = {}) {\n  // 1. Cria um array de Promises, onde cada uma representa a decriptação de um pedaço.\n  const decryptionPromises = messageChunks.map(chunk =>\n    decrypt(privateKey, chunk, props)\n  );\n\n  // 2. Executa todas as decriptações em paralelo. O resultado é um array de pedaços de string Base64.\n  const decryptedChunks = await Promise.all(decryptionPromises);\n\n  // 3. Junta os pedaços de Base64 em uma única string.\n  const finalBase64 = decryptedChunks.join(\"\");\n\n  // 4. Decodifica a string Base64 final de volta para o texto original.\n  return base64From(finalBase64);\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = messageDecryptFromChunks;","const isNumber = require(\"../helpers/isNumber\");\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário para normalizar strings, removendo acentos.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.0.0\n */\n\n/**\n * @summary Remove acentos e outros caracteres diacríticos de uma string.\n *\n * @description\n * Esta função converte uma string para sua forma normalizada (NFD - Normalization Form\n * Canonical Decomposition), que separa os caracteres base de seus acentos (marcas\n * diacríticas combinadas). Em seguida, uma expressão regular remove essas marcas,\n * resultando em uma string \"limpa\", sem acentuação.\n *\n * A função processa apenas entradas do tipo `string` ou `number`, retornando\n * outros tipos de dados inalterados.\n *\n * @param {string | number} [text=\"\"] - O texto a ser normalizado.\n *\n * @returns {*} A string normalizada, ou o valor original se a entrada não for\n * uma string ou número.\n *\n * @example\n * const acentuado = 'Pão de Açúcar & Linguiça';\n * const normalizado = normalize(acentuado);\n * console.log(normalizado); // \"Pao de Acucar & Linguica\"\n *\n * normalize(123.45); // Retorna a string \"123.45\"\n * normalize({ a: 1 }); // Retorna o objeto { a: 1 } inalterado\n */\nfunction normalize(text = \"\") {\n  // 1. Verifica se a entrada é um tipo que pode ser normalizado (string ou número).\n  if (isNumber(text) || typeof text === \"string\") {\n    // 2. Converte para string (caso seja número) e aplica a normalização.\n    // \"NFD\" decompõe um caractere como \"ç\" em seus componentes: \"c\" + \"¸\".\n    // A regex /[\\u0300-\\u036f]/g então remove o componente de acentuação (o intervalo\n    // Unicode para \"Combining Diacritical Marks\").\n    return String(text)\n      .normalize(\"NFD\")\n      .replace(/[\\u0300-\\u036f]/g, \"\");\n  }\n\n  // 3. Se a entrada não for do tipo esperado, retorna-a inalterada.\n  return text;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = normalize;","/**\n * @fileoverview Fornece uma função para criar um novo objeto contendo apenas um\n * subconjunto de chaves de um objeto de origem.\n */\n\n/**\n * @summary Cria um novo objeto contendo apenas as chaves especificadas de um objeto de origem.\n * @description Itera sobre um array de chaves (`keysToPick`) e constrói um novo objeto\n * com as chaves e valores correspondentes do objeto de origem (`sourceObject`).\n * Chaves que existem em `keysToPick` mas não no `sourceObject` são ignoradas.\n * A função não modifica o objeto original.\n *\n * @param {object} sourceObject - O objeto do qual as propriedades serão selecionadas.\n * @param {string[]} keysToPick - Um array de nomes de chaves (strings) a serem incluídas no novo objeto.\n * @returns {object} Um novo objeto contendo apenas as propriedades selecionadas.\n *\n * @example\n * const user = {\n * id: 123,\n * name: 'John Doe',\n * email: 'john.doe@example.com',\n * isAdmin: true,\n * lastLogin: new Date()\n * };\n *\n * const keys = ['id', 'name', 'email'];\n * const publicUserData = pickKeys(user, keys);\n *\n * // Retorna: { id: 123, name: 'John Doe', email: 'john.doe@example.com' }\n * console.log(publicUserData);\n *\n * @example\n * // Chaves não existentes são simplesmente ignoradas\n * const partialData = pickKeys(user, ['id', 'nonExistentKey']);\n * // Retorna: { id: 123 }\n * console.log(partialData);\n */\nfunction pickKeys(sourceObject, keysToPick) {\n  // Validação de entradas para garantir robustez. Retorna um objeto vazio para entradas inválidas.\n  if (\n    sourceObject === null ||\n    typeof sourceObject !== \"object\" ||\n    Array.isArray(sourceObject)\n  ) {\n    return {};\n  }\n  if (!Array.isArray(keysToPick)) {\n    return {};\n  }\n\n  // Usa reduce para construir o novo objeto de forma eficiente e funcional.\n  return keysToPick.reduce((newObj, key) => {\n    // Verifica se a chave existe como uma propriedade própria do objeto de origem.\n    // Usar Object.prototype.hasOwnProperty.call é a forma mais segura de fazer essa checagem.\n    if (Object.prototype.hasOwnProperty.call(sourceObject, key)) {\n      newObj[key] = sourceObject[key];\n    }\n    return newObj;\n  }, {});\n}\n\n// ------------------------------------------------------------------------------------------------\nmodule.exports = pickKeys;\n// ------------------------------------------------------------------------------------------------\n","/**\n * @file Utilitário para adicionar mensagens a um array de log.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.1.0\n */\n\n/**\n * @typedef {object} LogEntry - Define a estrutura de uma entrada de log.\n * @property {string} time - O timestamp da entrada de log no formato ISO (UTC).\n * @property {string} message - A mensagem de log.\n * @property {*} [more_info] - Opcional. Informações adicionais ou metadados.\n */\n\n/**\n * @summary Adiciona uma nova entrada a um array de logs, modificando-o.\n *\n * @description\n * Esta função adiciona uma nova entrada de log (com timestamp, mensagem e informações\n * adicionais) diretamente a um array existente.\n *\n * **Atenção:** Esta função é **mutável**, o que significa que ela **modifica\n * diretamente** o array `logObj` passado como argumento. Se o `logObj` fornecido não\n * for um array, um novo array será criado e retornado.\n *\n * @param {LogEntry[]} logObj - O array de log a ser modificado.\n * @param {string} message - A mensagem de log a ser adicionada.\n * @param {*} [more_info] - Opcional. Qualquer informação ou objeto adicional a ser incluído no log.\n *\n * @returns {LogEntry[]} O mesmo array de log que foi passado, agora com a nova mensagem.\n *\n * @example\n * const meuLog = [{ time: '...', message: 'Serviço iniciado.' }];\n * pushLogMessage(meuLog, 'Usuário conectado.', { userId: 123 });\n *\n * // O array original FOI modificado\n * console.log(meuLog.length); // 2\n * console.log(meuLog[1].message); // \"Usuário conectado.\"\n *\n * // Se a variável de log não for um array, um novo é criado\n * let logInexistente; // undefined\n * logInexistente = pushLogMessage(logInexistente, 'Primeira mensagem.');\n * console.log(logInexistente.length); // 1\n */\nfunction pushLogMessage(logObj, message, more_info) {\n  // 1. Verifica se o `logObj` de entrada é um array.\n  // Se não for, um novo array é criado para a variável local `logObj`.\n  if (!Array.isArray(logObj)) {\n    logObj = [];\n  }\n\n  // 2. Cria a nova entrada de log.\n  const newEntry = {\n    time: new Date().toISOString(),\n    message,\n  };\n\n  // Adiciona o campo `more_info` ao objeto de log apenas se ele tiver sido fornecido.\n  if (more_info !== undefined) {\n    newEntry.more_info = more_info;\n  }\n\n  // 3. Adiciona a nova entrada diretamente ao array (mutação).\n  logObj.push(newEntry);\n\n  // 4. Retorna o array modificado.\n  return logObj;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = pushLogMessage;","const toString = require(\"./toString.js\");\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário para extrair apenas dígitos de um valor.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.0.0\n */\n\n/**\n * @summary Extrai apenas os dígitos de uma string ou de outro valor.\n *\n * @description\n * Esta função recebe um valor de qualquer tipo, o converte para uma string e remove\n * todos os caracteres que não são dígitos (0-9). É útil para limpar entradas de\n * usuário, como números de telefone, CEPs ou CPFs que podem conter máscaras\n * (pontos, traços, parênteses).\n *\n * @param {*} [text=\"\"] - O valor do qual os dígitos serão extraídos.\n *\n * @returns {string} Uma string contendo apenas os dígitos do valor de entrada.\n *\n * @example\n * const phoneNumber = '(11) 98765-4321';\n * const digits = regexDigitsOnly(phoneNumber);\n * console.log(digits); // \"11987654321\"\n *\n * const price = 'R$ 19,90';\n * const priceDigits = regexDigitsOnly(price);\n * console.log(priceDigits); // \"1990\"\n *\n * regexDigitsOnly(123.45); // Retorna \"12345\"\n */\nfunction regexDigitsOnly(text = \"\") {\n  // 1. Converte a entrada para uma string de forma segura.\n  const stringValue = toString(text);\n\n  // 2. Remove todos os caracteres que não são dígitos (0-9).\n  // A regex `/[^0-9]/g` encontra qualquer caractere que não esteja no intervalo de 0 a 9\n  // e o substitui por uma string vazia.\n  return stringValue.replace(/[^0-9]/g, \"\");\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = regexDigitsOnly;","const toString = require(\"./toString.js\");\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário para substituir caracteres em uma string com base em um conjunto permitido.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.1.0\n */\n\n/**\n * @summary Substitui caracteres em uma string que não pertencem a um conjunto de caracteres permitido.\n *\n * @description\n * Esta função cria dinamicamente uma expressão regular a partir de uma string que define um\n * conjunto de caracteres permitidos. Ela então remove ou substitui todos os caracteres da\n * string de entrada que não fazem parte desse conjunto. É uma ferramenta flexível\n * para limpar e sanitizar strings.\n *\n * @param {*} [text=\"\"] - O valor a ser processado, que será convertido para string.\n * @param {string} [regex=\"A-Za-zÀ-ú0-9 \"] - Uma string que define o conjunto de caracteres\n * a serem **mantidos**. Pode incluir intervalos, como `A-Z` ou `0-9`.\n * @param {string} [replacement=\"\"] - A string que substituirá cada caractere não permitido.\n * @param {boolean} [trim=true] - Se `true`, remove espaços em branco do início e do fim do resultado.\n *\n * @returns {string} A string resultante após a substituição e o trim opcional.\n *\n * @example\n * // Manter apenas letras e números, substituindo o resto por '*'\n * const text = \"Hello! @123 World_456\";\n * const allowed = \"A-Za-z0-9\";\n * const result = regexReplaceTrim(text, allowed, \"*\");\n * console.log(result); // \"Hello***123*World*456\"\n *\n * // Manter apenas letras maiúsculas e remover o resto\n * const textWithSpaces = \"   A B C   \";\n * const resultTrimmed = regexReplaceTrim(textWithSpaces, \"A-Z\", \"\");\n * console.log(resultTrimmed); // \"ABC\"\n */\nfunction regexReplaceTrim(\n  text = \"\",\n  regex = \"A-Za-zÀ-ú0-9 \",\n  replacement = \"\",\n  trim = true\n) {\n  // 1. Converte as entradas para string para garantir a operação.\n  const stringValue = toString(text);\n  const allowedChars = toString(regex);\n  const replacementValue = toString(replacement);\n\n  // 2. Constrói a expressão regular que corresponde a qualquer caractere NÃO presente no conjunto.\n  // A string `allowedChars` é inserida diretamente para permitir intervalos como 'A-Z'.\n  const filterRegex = new RegExp(`[^${allowedChars}]`, \"g\");\n\n  // 3. Realiza a substituição uma única vez para evitar duplicação de código.\n  let result = stringValue.replace(filterRegex, replacementValue);\n\n  // 4. Aplica o trim opcionalmente ao resultado.\n  if (trim) {\n    result = result.trim();\n  }\n\n  return result;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = regexReplaceTrim;","const toString = require(\"./toString.js\");\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário para extrair apenas letras de um valor.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.0.0\n */\n\n/**\n * @summary Extrai apenas caracteres alfabéticos (letras) de uma string ou de outro valor.\n *\n * @description\n * Esta função recebe um valor de qualquer tipo, o converte para uma string e remove\n * todos os caracteres que não são letras, como números, símbolos, espaços e\n * pontuação. Ela preserva tanto letras do alfabeto padrão (a-z, A-Z) quanto\n * a maioria das letras acentuadas comuns (à, ç, õ, etc.).\n *\n * @param {*} [text=\"\"] - O valor do qual as letras serão extraídas.\n *\n * @returns {string} Uma string contendo apenas as letras do valor de entrada.\n *\n * @example\n * const fullName = 'José \"Zé\" da Silva - 1985';\n * const letters = regexLettersOnly(fullName);\n * console.log(letters); // \"JoséZédaSilva\"\n *\n * const product = 'Camiseta (Polo) - Azul';\n * const productName = regexLettersOnly(product);\n * console.log(productName); // \"CamisetaPoloAzul\"\n */\nfunction regexLettersOnly(text = \"\") {\n  // 1. Converte a entrada para uma string de forma segura.\n  const stringValue = toString(text);\n\n  // 2. Remove todos os caracteres que não são letras.\n  // A regex `/[^A-Za-zÀ-ú]/g` encontra qualquer caractere que não esteja nos\n  // intervalos de 'A' a 'Z', 'a' a 'z', ou no intervalo de caracteres acentuados comuns.\n  return stringValue.replace(/[^A-Za-zÀ-ú]/g, \"\");\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = regexLettersOnly;","const toString = require(\"./toString.js\");\nconst isObject = require(\"../helpers/isObject\");\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário para remover substrings duplicadas de uma string.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.2.0\n */\n\n/**\n * @summary Remove substrings duplicadas de um texto, com opção de ignorar maiúsculas/minúsculas.\n *\n * @description\n * Esta função divide uma string em um array de substrings, remove as duplicatas\n * e une as substrings de volta em uma única string.\n *\n * **Comportamento Importante:**\n * - No modo padrão (sensível a maiúsculas/minúsculas), a **primeira** ocorrência de uma substring é mantida.\n * - No modo insensível a maiúsculas/minúsculas, a **última** ocorrência de uma substring é mantida, preservando sua capitalização original.\n *\n * @param {*} text - O valor a ser processado, que será convertido para string.\n * @param {string} [splitString=\" \"] - O caractere ou string usado para dividir o texto.\n * @param {boolean} [caseInsensitive=false] - Se `true`, a comparação de duplicatas\n * ignorará a diferença entre maiúsculas e minúsculas.\n *\n * @returns {string} Uma nova string com as substrings duplicadas removidas. Retorna uma\n * string vazia se a entrada for um objeto.\n *\n * @example\n * const phrase = 'apple Orange apple ORANGE';\n *\n * // Sensível a maiúsculas/minúsculas (mantém a primeira ocorrência)\n * removeDuplicatedStrings(phrase); // \"apple Orange ORANGE\"\n *\n * // Insensível a maiúsculas/minúsculas (mantém a última ocorrência)\n * removeDuplicatedStrings(phrase, ' ', true); // \"apple ORANGE\"\n */\nfunction removeDuplicatedStrings(\n  text,\n  splitString = \" \",\n  caseInsensitive = false\n) {\n  // 1. Validação da entrada.\n  if (isObject(text)) {\n    return \"\";\n  }\n\n  // 2. Prepara o array de substrings.\n  const separator = toString(splitString);\n  const array = toString(text)\n    .trim()\n    .split(separator)\n    .filter(v => v);\n\n  // 3. Lógica para remover duplicatas.\n  if (!caseInsensitive) {\n    // Mantém a PRIMEIRA ocorrência de cada item.\n    return [...new Set(array)].join(separator);\n  } else {\n    // Lógica para manter a ÚLTIMA ocorrência, de forma performática.\n    const seenIndexes = {};\n    // 1. Mapeia a versão minúscula de cada item para o seu último índice no array.\n    array.forEach((item, index) => {\n      seenIndexes[item.toLowerCase()] = index;\n    });\n\n    // 2. Extrai apenas os índices que devem ser mantidos (os das últimas ocorrências).\n    const indexesToKeep = new Set(Object.values(seenIndexes));\n\n    // 3. Filtra o array original, mantendo apenas os itens nos índices desejados.\n    // Isso preserva a ordem e a capitalização corretas.\n    return array\n      .filter((_item, index) => indexesToKeep.has(index))\n      .join(separator);\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = removeDuplicatedStrings;","/**\n * @file Utilitário para criar um atraso (delay) programático.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.0.0\n */\n\n/**\n * @summary Cria um atraso (delay) programático usando uma Promise.\n *\n * @description\n * Esta função é uma versão de `setTimeout` que pode ser usada com `async/await` para pausar\n * a execução de uma função assíncrona. Ela retorna uma Promise que será resolvida\n * ou rejeitada após o número de milissegundos especificado.\n *\n * @param {number} milliseconds - O número de milissegundos para esperar. Deve ser um número não negativo.\n * @param {*} [returnValue=true] - O valor com o qual a Promise será resolvida ou rejeitada.\n * @param {boolean} [throwError=false] - Se `true`, a Promise será rejeitada. Se `false` (padrão),\n * a Promise será resolvida.\n *\n * @returns {Promise<*>} Uma Promise que resolve ou rejeita após o atraso.\n *\n * @example\n * async function runProcess() {\n * console.log('Iniciando processo...'); // Ex: 17:18:43\n *\n * // Espera por 2 segundos e continua\n * await sleep(2000);\n * console.log('Processo continuado após 2 segundos.'); // Ex: 17:18:45\n *\n * try {\n * // Espera por 1 segundo e então rejeita a promise\n * await sleep(1000, 'Erro controlado', true);\n * } catch (error) {\n * console.error('Erro capturado:', error); // Erro capturado: Erro controlado\n * }\n * }\n *\n * runProcess();\n */\nfunction sleep(milliseconds, returnValue = true, throwError = false) {\n  // 1. Validação da entrada. Retorna uma promise já rejeitada para entradas inválidas.\n  if (typeof milliseconds !== 'number' || milliseconds < 0) {\n    const error = new TypeError('O tempo de espera (milliseconds) deve ser um número não negativo.');\n    return Promise.reject(error);\n  }\n\n  // A função retorna uma nova Promise, que é o padrão para operações assíncronas.\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      // 2. Decide se a promise deve ser resolvida ou rejeitada com base no parâmetro.\n      if (throwError) {\n        // Comportamento especial do código original: se o valor for o padrão `true`,\n        // rejeita com um erro genérico para maior clareza.\n        if (returnValue === true) {\n          return reject(new Error(\"Sleep Error\"));\n        }\n        // Caso contrário, rejeita com o valor personalizado fornecido.\n        return reject(returnValue);\n      }\n\n      // 3. Resolve a promise com o valor fornecido.\n      return resolve(returnValue);\n    }, milliseconds);\n  });\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = sleep;","/**\n * @file Utilitário seguro para dividir (split) strings.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.0.0\n */\n\n/**\n * @summary Divide uma string em um array de substrings com base em um separador.\n *\n * @description\n * Esta função é um wrapper seguro para o método nativo `String.prototype.split()`.\n * Ela lida com entradas que não são strings (como `null` ou `undefined`) de forma\n * graciosa, retornando um array vazio em vez de lançar um erro, o que a torna\n * mais segura para usar em pipelines de dados.\n *\n * @param {string} text - A string a ser dividida.\n * @param {string | RegExp} [char=\" \"] - O separador. Pode ser uma string ou uma Expressão Regular.\n *\n * @returns {string[]} Um array de substrings. Retorna um array vazio se a entrada\n * não for uma string válida ou for uma string vazia.\n *\n * @example\n * const fruits = 'maçã,banana,laranja';\n * const fruitArray = split(fruits, ',');\n * console.log(fruitArray); // ['maçã', 'banana', 'laranja']\n *\n * const empty = split(null);\n * console.log(empty); // []\n *\n * const sentence = \"O rato roeu a roupa\";\n * const words = split(sentence); // Usa o separador padrão \" \"\n * console.log(words); // [\"O\", \"rato\", \"roeu\", \"a\", \"roupa\"]\n */\nfunction split(text, char = \" \") {\n  // 1. Validação: Garante que a entrada é uma string válida e não vazia.\n  // Se não for, retorna um array vazio para evitar erros em tempo de execução.\n  if (!text || typeof text !== \"string\") {\n    return [];\n  }\n\n  // 2. Delega a operação para o método nativo e eficiente `split`.\n  return text.split(char);\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = split;","const { compressSync, strToU8 } = require(\"fflate\");\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário cross-platform e performático para compressão de strings.\n * @author Seu Nome <seu.email@example.com>\n * @version 3.0.0\n */\n\n/**\n * @typedef {object} CompressionOptions - Opções para a função de compressão.\n * @property {'base64' | 'buffer'} [outputType='base64'] - O formato da saída. 'base64' para uma string ou 'buffer' para um Uint8Array.\n * @property {number} [level=6] - O nível de compressão (0-9). Níveis mais altos são mais lentos mas podem gerar saídas menores.\n * @property {number} [mem=8] - O nível de uso de memória (1-12). Níveis mais altos são mais rápidos e podem comprimir melhor, mas usam mais memória.\n */\n\n/**\n * @summary Comprime uma string usando o algoritmo DEFLATE, retornando Base64 ou um buffer.\n *\n * @description\n * Esta função síncrona recebe uma string, a converte para bytes em UTF-8 e a comprime\n * de forma eficiente usando a biblioteca `fflate`. O resultado é retornado no formato\n * especificado pelo `outputType`: uma string Base64 (ideal para transmissão em texto)\n * ou um `Uint8Array` (para manipulação binária).\n *\n * @param {string} text - A string a ser comprimida.\n * @param {CompressionOptions} [options={}] - Opções para customizar a compressão e o formato de saída.\n *\n * @returns {string | Uint8Array} A string comprimida em Base64 ou o `Uint8Array` dos dados comprimidos.\n * Retorna um valor vazio apropriado (string ou Uint8Array) para entradas inválidas.\n *\n * @example\n * const textoOriginal = 'Um texto longo para ser comprimido. Repetir, repetir, repetir.';\n *\n * // Comprimir para Base64 (padrão)\n * const comprimidoB64 = stringCompress(textoOriginal);\n *\n * // Comprimir para um buffer binário com nível de compressão máximo\n * const comprimidoBuffer = stringCompress(textoOriginal, { outputType: 'buffer', level: 9 });\n */\nfunction stringCompress(text, options = {}) {\n  // 1. Define as opções padrão e as mescla com as fornecidas pelo usuário\n  // para garantir um comportamento robusto e previsível.\n  const finalOptions = {\n    outputType: 'base64',\n    level: 6,\n    mem: 8,\n    ...options\n  };\n\n  // 2. Valida a entrada.\n  if (typeof text !== 'string' || text.length === 0) {\n    // Retorna um valor vazio do tipo de saída esperado para manter a consistência.\n    return finalOptions.outputType === 'buffer' ? new Uint8Array() : \"\";\n  }\n\n  // 3. Converte a string de entrada para um buffer de bytes UTF-8.\n  // `strToU8` é um helper otimizado da biblioteca `fflate`.\n  const inputBuffer = strToU8(text);\n\n  // 4. Comprime o buffer usando as opções especificadas.\n  const compressedBuffer = compressSync(inputBuffer, {\n    level: finalOptions.level,\n    mem: finalOptions.mem,\n  });\n\n  // 5. Retorna o resultado no formato solicitado.\n  if (finalOptions.outputType === 'buffer') {\n    return compressedBuffer;\n  }\n\n  // Por padrão, retorna em Base64. A conversão de binário para Base64\n  // é feita de forma diferente e otimizada para cada ambiente.\n  if (typeof Buffer !== 'undefined' && typeof Buffer.from === 'function') {\n    // **Ambiente Node.js:**\n    // Converte o Uint8Array para um Buffer e então para Base64. É o método mais rápido.\n    return Buffer.from(compressedBuffer).toString('base64');\n  } else {\n    // **Ambiente do Navegador:**\n    // Converte o Uint8Array para uma \"binary string\" e usa a função nativa `btoa`.\n    let binary = '';\n    const len = compressedBuffer.byteLength;\n    for (let i = 0; i < len; i++) {\n      binary += String.fromCharCode(compressedBuffer[i]);\n    }\n    return btoa(binary);\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = stringCompress;","const { decompressSync, strFromU8 } = require(\"fflate\");\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário cross-platform e performático para descompressão de strings.\n * @author Seu Nome <seu.email@example.com>\n * @version 3.0.0\n */\n\n/**\n * @typedef {object} DecompressionOptions - Opções para a função de descompressão.\n * @property {'base64' | 'buffer'} [inputType='base64'] - O formato da entrada de dados comprimidos.\n */\n\n/**\n * @summary Descomprime dados (Base64 ou buffer) de volta para a string original.\n *\n * @description\n * Esta função síncrona é a contraparte da `stringCompress`. Ela recebe dados comprimidos,\n * seja como uma string Base64 ou um `Uint8Array`, e os descomprime para a string de\n * texto original em formato UTF-8, utilizando a biblioteca `fflate`.\n *\n * @param {string | Uint8Array} compressedData - Os dados comprimidos a serem descomprimidos.\n * @param {DecompressionOptions} [options={}] - Opções para customizar o tipo de entrada.\n *\n * @returns {string} A string original descomprimida. Retorna uma string vazia se a\n * entrada for inválida ou se a descompressão falhar (ex: dados corrompidos).\n *\n * @example\n * const textoOriginal = 'O texto original que será comprimido e depois descomprimido.';\n *\n * // 1. Comprime para Base64\n * const comprimidoB64 = stringCompress(textoOriginal);\n *\n * // 2. Descomprime de volta para o original\n * const descomprimido = stringDecompress(comprimidoB64);\n *\n * console.log(descomprimido === textoOriginal); // true\n */\nfunction stringDecompress(compressedData, options = {}) {\n  // 1. Define as opções padrão e as mescla com as fornecidas pelo usuário.\n  const finalOptions = {\n    inputType: 'base64',\n    ...options\n  };\n\n  // 2. Valida a entrada principal.\n  if (!compressedData) {\n    return \"\";\n  }\n\n  try {\n    let inputBuffer;\n\n    // 3. Normaliza a entrada para um formato de buffer binário (`Uint8Array`).\n    if (finalOptions.inputType === 'base64') {\n      // Garante que a entrada é uma string antes de tentar decodificar.\n      if (typeof compressedData !== 'string') {\n        return \"\";\n      }\n      \n      // A decodificação de Base64 para binário é feita de forma otimizada para cada ambiente.\n      if (typeof Buffer !== 'undefined' && typeof Buffer.from === 'function') {\n        // **Ambiente Node.js:**\n        // `Buffer.from` lida com Base64 nativamente e é muito rápido.\n        inputBuffer = Buffer.from(compressedData, 'base64');\n      } else {\n        // **Ambiente do Navegador:**\n        // Usa `atob` para decodificar para uma \"binary string\" e então converte para Uint8Array.\n        const binaryString = atob(compressedData);\n        const len = binaryString.length;\n        const bytes = new Uint8Array(len);\n        for (let i = 0; i < len; i++) {\n          bytes[i] = binaryString.charCodeAt(i);\n        }\n        inputBuffer = bytes;\n      }\n    } else {\n      // Se o tipo for 'buffer', assume que a entrada já está em um formato binário compatível.\n      inputBuffer = compressedData;\n    }\n\n    // Valida se a conversão ou a entrada resultou em um buffer com conteúdo.\n    if (!inputBuffer || inputBuffer.byteLength === 0) {\n      return \"\";\n    }\n\n    // 4. Descomprime o buffer. Esta operação pode falhar se os dados estiverem corrompidos.\n    const decompressedBuffer = decompressSync(inputBuffer);\n\n    // 5. Converte o buffer descomprimido de volta para uma string UTF-8.\n    return strFromU8(decompressedBuffer);\n  } catch (error) {\n    // Retorna uma string vazia se a descompressão falhar (ex: dados corrompidos ou Base64 inválido).\n    return \"\";\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = stringDecompress;","const { DATE_ISO_FORMAT, DATE_BR_HOUR_FORMAT_D } = require(\"../constants.js\");\nconst stringToDate = require(\"./stringToDate.js\");\nconst dateToFormat = require(\"./dateToFormat.js\");\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário para re-formatar strings de data.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.1.0\n */\n\n/**\n * @summary Re-formata uma string de data de um formato de entrada para um de saída.\n *\n * @description\n * Esta função é um utilitário de conveniência que combina a análise e a formatação\n * de datas em uma única etapa. Ela usa `stringToDate` para converter a string de entrada em um\n * objeto `Date` e, em seguida, usa `dateToFormat` para converter esse objeto de volta\n * para uma string no formato de saída desejado.\n *\n * @param {string} stringDate - A string da data a ser re-formatada.\n * @param {string} [fromFormat=DATE_ISO_FORMAT] - O padrão de formatação da string de entrada.\n * @param {string} [toFormat=DATE_BR_HOUR_FORMAT_D] - O padrão de formatação desejado para a saída.\n *\n * @returns {string | false} A nova string de data formatada, ou `false` se a\n * análise da data de entrada falhar.\n */\nfunction stringToDateToFormat(\n  stringDate,\n  fromFormat = DATE_ISO_FORMAT,\n  toFormat = DATE_BR_HOUR_FORMAT_D\n) {\n  try {\n    // 1. Converte a string de entrada para um objeto Date.\n    // `stringToDate` retorna um Date cujo tempo UTC corresponde aos números da string.\n    const dateObject = stringToDate(stringDate, fromFormat, false);\n\n    if (dateObject) {\n      // 2. Reverte o ajuste de fuso horário antes de formatar.\n      // `stringToDate` removeu o offset local para tratar a hora como UTC.\n      // Para que `dateToFormat` (que formata em hora local) exiba os números corretos,\n      // é necessário adicionar o offset de volta, criando uma nova data ajustada.\n      const timezoneOffsetMillis = dateObject.getTimezoneOffset() * 60 * 1000;\n      const localDate = new Date(dateObject.getTime() + timezoneOffsetMillis);\n\n      // 3. Formata o objeto Date (agora ajustado para a hora local correta) para a string de saída.\n      return dateToFormat(localDate, toFormat);\n    }\n  } catch (_) {}\n  // 4. Se a conversão inicial falhou, retorna `false`.\n  return false;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = stringToDateToFormat;\n","const toString = require(\"./toString.js\");\nconst regexDigitsOnly = require(\"./regexDigitsOnly\");\nconst { STRING_FORMAT_CNPJ } = require(\"../constants.js\");\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário para aplicar máscaras de formatação a strings.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.0.0\n */\n\n/**\n * @summary Aplica uma máscara de formatação a uma string ou valor.\n *\n * @description\n * Esta função formata uma string de entrada de acordo com um padrão (máscara).\n * Os caracteres `#` no padrão são substituídos sequencialmente pelos caracteres\n * da string de entrada. A função pode opcionalmente limpar a entrada para conter\n * apenas dígitos, e também lida com o preenchimento e truncamento da entrada\n * para que ela se ajuste perfeitamente à máscara.\n *\n * @param {*} [text] - O valor a ser formatado. Será convertido para string.\n * @param {string} [pattern=STRING_FORMAT_CNPJ] - A máscara de formatação, onde `#` é um placeholder.\n * @param {object} [options={}] - Opções para customizar o comportamento.\n * @param {boolean} [options.digitsOnly=false] - Se `true`, a string de entrada será primeiro limpa para conter apenas dígitos.\n * @param {string} [options.paddingChar='0'] - O caractere a ser usado para preencher a entrada à esquerda se ela for menor que o necessário.\n *\n * @returns {string} A string formatada com a máscara.\n *\n * @example\n * // Formatar um CNPJ (com limpeza de dígitos)\n * const cnpj = '12.345.678/0001-90';\n * stringToFormat(cnpj, '##.###.###/####-##', { digitsOnly: true });\n * // Retorna: \"12.345.678/0001-90\"\n *\n * // Formatar um valor com preenchimento à esquerda\n * stringToFormat('123', 'ID-######', { paddingChar: '0' });\n * // Retorna: \"ID-000123\"\n */\nfunction stringToFormat(\n  text,\n  pattern = STRING_FORMAT_CNPJ,\n  options = {}\n) {\n  // 1. Define e mescla as opções para um manuseio robusto de parâmetros.\n  const finalOptions = {\n    digitsOnly: false,\n    paddingChar: \"0\",\n    ...options\n  };\n\n  let processedText = toString(text);\n\n  // 2. Aplica a limpeza de dígitos opcionalmente.\n  if (finalOptions.digitsOnly) {\n    processedText = regexDigitsOnly(processedText);\n  }\n\n  // 3. Calcula o tamanho necessário com base nos placeholders '#' no padrão.\n  const requiredSize = (pattern.match(/#/g) || []).length;\n  if (requiredSize === 0) {\n      return pattern; // Se não houver placeholders, retorna o padrão literal.\n  }\n\n  // 4. Garante que o texto tenha o tamanho exato: trunca se for longo, preenche se for curto.\n  processedText = processedText.slice(0, requiredSize).padStart(requiredSize, finalOptions.paddingChar);\n\n  // 5. Aplica a máscara de forma funcional.\n  // A cada ocorrência de '#', a função de callback fornece o próximo\n  // caractere do texto processado para a substituição.\n  let charIndex = 0;\n  return pattern.replace(/#/g, () => processedText[charIndex++]);\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = stringToFormat;","const { zlibSync, strToU8 } = require(\"fflate\");\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário cross-platform para compressão de strings com Zlib.\n * @author Seu Nome <seu.email@example.com>\n * @version 1.0.0\n */\n\n/**\n * @typedef {object} ZlibOptions - Opções para a função de compressão Zlib.\n * @property {'base64' | 'buffer'} [outputType='base64'] - O formato da saída. 'base64' para uma string ou 'buffer' para um Uint8Array.\n * @property {number} [level=6] - O nível de compressão (0-9). Níveis mais altos são mais lentos mas podem gerar saídas menores.\n * @property {number} [mem=8] - O nível de uso de memória (1-12). Níveis mais altos são mais rápidos e podem comprimir melhor, mas usam mais memória.\n */\n\n/**\n * @summary Comprime uma string usando o algoritmo Zlib.\n *\n * @description\n * Esta função síncrona recebe uma string, a converte para bytes em UTF-8 e a comprime\n * de forma eficiente usando o formato Zlib da biblioteca `fflate`. O resultado é retornado no formato\n * especificado pelo `outputType`: uma string Base64 ou um `Uint8Array`.\n *\n * @param {string} text - A string a ser comprimida.\n * @param {ZlibOptions} [options={}] - Opções para customizar a compressão e o formato de saída.\n *\n * @returns {string | Uint8Array} A string comprimida em Base64 ou o `Uint8Array` dos dados comprimidos.\n * Retorna um valor vazio apropriado (string ou Uint8Array) para entradas inválidas.\n *\n * @example\n * const textoOriginal = 'Este texto será comprimido com o algoritmo Zlib.';\n *\n * // Comprimir para Base64 (padrão)\n * const comprimidoB64 = stringZLibCompress(textoOriginal);\n *\n * // Comprimir para um buffer binário com nível de compressão máximo\n * const comprimidoBuffer = stringZLibCompress(textoOriginal, { outputType: 'buffer', level: 9 });\n */\nfunction stringZLibCompress(text, options = {}) {\n  // 1. Define as opções padrão e as mescla com as fornecidas pelo usuário.\n  const finalOptions = {\n    outputType: 'base64',\n    level: 6,\n    mem: 8,\n    ...options\n  };\n\n  // 2. Valida a entrada.\n  if (typeof text !== 'string' || text.length === 0) {\n    // Retorna um valor vazio do tipo de saída esperado para manter a consistência.\n    return finalOptions.outputType === 'buffer' ? new Uint8Array() : \"\";\n  }\n\n  // 3. Converte a string de entrada para um buffer de bytes UTF-8.\n  const inputBuffer = strToU8(text);\n\n  // 4. Comprime o buffer usando as opções especificadas.\n  const compressedBuffer = zlibSync(inputBuffer, {\n    level: finalOptions.level,\n    mem: finalOptions.mem,\n  });\n\n  // 5. Retorna o resultado no formato solicitado.\n  if (finalOptions.outputType === 'buffer') {\n    return compressedBuffer;\n  }\n\n  // Por padrão, retorna em Base64, com a conversão otimizada para cada ambiente.\n  if (typeof Buffer !== 'undefined' && typeof Buffer.from === 'function') {\n    // **Ambiente Node.js:**\n    // Converte o Uint8Array para um Buffer e então para Base64. É o método mais rápido.\n    return Buffer.from(compressedBuffer).toString('base64');\n  } else {\n    // **Ambiente do Navegador:**\n    // Converte o Uint8Array para uma \"binary string\" e usa a função nativa `btoa`.\n    let binary = '';\n    const len = compressedBuffer.byteLength;\n    for (let i = 0; i < len; i++) {\n      binary += String.fromCharCode(compressedBuffer[i]);\n    }\n    return btoa(binary);\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = stringZLibCompress;","const { unzlibSync, strFromU8 } = require(\"fflate\");\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @file Utilitário cross-platform para descompressão de strings com Zlib.\n * @author Seu Nome <seu.email@example.com>\n * @version 1.0.0\n */\n\n/**\n * @typedef {object} ZlibDecompressionOptions - Opções para a função de descompressão Zlib.\n * @property {'base64' | 'buffer'} [inputType='base64'] - O formato da entrada de dados comprimidos.\n */\n\n/**\n * @summary Descomprime dados (Base64 ou buffer) usando Zlib de volta para a string original.\n *\n * @description\n * Esta função síncrona é a contraparte da `stringZLibCompress`. Ela recebe dados comprimidos\n * no formato Zlib, seja como uma string Base64 ou um `Uint8Array`, e os descomprime\n * para a string de texto original em formato UTF-8.\n *\n * @param {string | Uint8Array} compressedData - Os dados comprimidos a serem descomprimidos.\n * @param {ZlibDecompressionOptions} [options={}] - Opções para customizar o tipo de entrada.\n *\n * @returns {string} A string original descomprimida. Retorna uma string vazia se a\n * entrada for inválida ou se a descompressão falhar (ex: dados corrompidos).\n *\n * @example\n * const textoOriginal = 'Este texto será comprimido e depois descomprimido com Zlib.';\n *\n * // 1. Comprime para Base64\n * const comprimidoB64 = stringZLibCompress(textoOriginal);\n *\n * // 2. Descomprime de volta para o original\n * const descomprimido = stringZLibDecompress(comprimidoB64);\n *\n * console.log(descomprimido === textoOriginal); // true\n */\nfunction stringZLibDecompress(compressedData, options = {}) {\n  // 1. Define as opções padrão e as mescla com as fornecidas pelo usuário.\n  const finalOptions = {\n    inputType: 'base64',\n    ...options\n  };\n\n  // 2. Valida a entrada principal.\n  if (!compressedData) {\n    return \"\";\n  }\n\n  try {\n    let inputBuffer;\n\n    // 3. Normaliza a entrada para um formato de buffer binário (`Uint8Array`).\n    if (finalOptions.inputType === 'base64') {\n      if (typeof compressedData !== 'string') {\n        return \"\";\n      }\n      \n      // A decodificação de Base64 para binário é otimizada para cada ambiente.\n      if (typeof Buffer !== 'undefined' && typeof Buffer.from === 'function') {\n        // **Ambiente Node.js:**\n        inputBuffer = Buffer.from(compressedData, 'base64');\n      } else {\n        // **Ambiente do Navegador:**\n        const binaryString = atob(compressedData);\n        const len = binaryString.length;\n        const bytes = new Uint8Array(len);\n        for (let i = 0; i < len; i++) {\n          bytes[i] = binaryString.charCodeAt(i);\n        }\n        inputBuffer = bytes;\n      }\n    } else {\n      // Se o tipo for 'buffer', assume que a entrada já está em um formato binário.\n      inputBuffer = compressedData;\n    }\n\n    if (!inputBuffer || inputBuffer.byteLength === 0) {\n      return \"\";\n    }\n\n    // 4. Descomprime o buffer. Pode falhar se os dados estiverem corrompidos.\n    const decompressedBuffer = unzlibSync(inputBuffer);\n\n    // 5. Converte o buffer descomprimido de volta para uma string UTF-8.\n    return strFromU8(decompressedBuffer);\n  } catch (error) {\n    // Retorna uma string vazia se a descompressão falhar.\n    return \"\";\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = stringZLibDecompress;","/**\n * @file Utilitário para criar uma função \"throttled\" (limitada por frequência).\n * @author Seu Nome <seu.email@example.com>\n * @version 1.0.0\n */\n\n/**\n * @summary Cria uma versão \"throttled\" de uma função, que limita sua frequência de execução.\n *\n * @description\n * Throttle é uma técnica que garante que uma função seja executada no máximo uma vez\n * a cada `wait` milissegundos. Ao contrário do `debounce` que espera um período de inatividade,\n * o `throttle` permite execuções contínuas, mas espaçadas no tempo.\n *\n * É ideal para controlar eventos que disparam com muita frequência e onde uma resposta periódica\n * é desejada, como em eventos de scroll, redimensionamento de janela ou movimento do mouse.\n * Esta implementação executa a função na primeira chamada (\"leading edge\") e ignora as\n * chamadas subsequentes durante o período de espera (cooldown).\n *\n * @param {Function} callback - A função que terá sua execução limitada.\n * @param {number} wait - O intervalo mínimo em milissegundos entre as execuções.\n *\n * @returns {(...args: any[]) => void} Uma nova função \"throttled\" que pode ser chamada no lugar da original.\n *\n * @throws {TypeError} Lança um erro se o `callback` não for uma função ou se `wait` não for um número.\n *\n * @example\n * // Exemplo: um evento de scroll que atualiza a UI, mas no máximo a cada 250ms.\n * let scrollCount = 0;\n * const onScroll = () => {\n * scrollCount++;\n * console.log(`Atualizando UI... Chamada nº ${scrollCount}`);\n * };\n *\n * const throttledScroll = throttle(onScroll, 250);\n *\n * // No navegador, você adicionaria o listener:\n * // window.addEventListener('scroll', throttledScroll);\n *\n * // Simulando chamadas rápidas:\n * throttledScroll(); // Executa: \"Atualizando UI... Chamada nº 1\"\n * throttledScroll(); // Ignorada (dentro do cooldown)\n * throttledScroll(); // Ignorada (dentro do cooldown)\n *\n * setTimeout(() => {\n * throttledScroll(); // Executa: \"Atualizando UI... Chamada nº 2\"\n * }, 300); // 300ms > 250ms, então o cooldown já acabou.\n */\nfunction throttle(callback, wait) {\n  // 1. Validação dos parâmetros na criação da função.\n  if (typeof callback !== 'function') {\n    throw new TypeError('O callback fornecido para o throttle deve ser uma função.');\n  }\n  if (typeof wait !== 'number' || wait < 0) {\n    throw new TypeError('O tempo de espera (wait) do throttle deve ser um número não negativo.');\n  }\n\n  // 2. Closure para manter o estado de \"cooldown\" entre as chamadas.\n  let inCooldown = false;\n\n  // Usa uma função regular para preservar o contexto `this` de quem a chama.\n  return function(...args) {\n    // Se a função já foi chamada dentro do período de `wait`, ignora esta nova chamada.\n    if (inCooldown) {\n      return;\n    }\n\n    // 3. Executa o callback imediatamente na primeira chamada válida.\n    // O `this` e os `args` são da chamada atual que está sendo executada.\n    callback.apply(this, args);\n\n    // 4. Inicia o período de \"cooldown\".\n    inCooldown = true;\n\n    // 5. Define um temporizador para terminar o \"cooldown\" após o tempo de espera,\n    // permitindo que a função seja executada novamente.\n    setTimeout(() => {\n      inCooldown = false;\n    }, wait);\n  };\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = throttle","/**\n * @description Gera uma string de timestamp altamente customizável e formatada com base em um padrão fornecido.\n * A função é otimizada para calcular apenas os componentes de data/hora necessários para o formato solicitado.\n *\n * @param {string} [format='D-MT-Y_H:MN:S:MS'] A string de formato que define a estrutura da saída.\n * Os seguintes tokens serão substituídos pelos seus respectivos valores:\n * - `Y`: Ano com 4 dígitos (ex: 2025)\n * - `MT`: Mês com 2 dígitos (01-12)\n * - `D`: Dia com 2 dígitos (01-31)\n * - `H`: Hora com 2 dígitos, formato 24h (00-23)\n * - `MN`: Minuto com 2 dígitos (00-59)\n * - `S`: Segundo com 2 dígitos (00-59)\n * - `MS`: Milissegundo com 3 dígitos (000-999)\n *\n * Qualquer outro caractere na string de formato (ex: '-', ':', '_', '/') será mantido como um separador literal.\n *\n * @returns {string} Uma string representando o timestamp formatado de acordo com o padrão.\n *\n * @example\n * // Chamada sem parâmetros, usa o formato padrão.\n * // Retorna algo como: \"22-08-2025_19:37:33:456\"\n * getFormattedTimestamp();\n *\n * @example\n * // Formato de hora customizado com underscores, como solicitado.\n * // Retorna algo como: \"19_37_33_456\"\n * getFormattedTimestamp('H_MN_S_MS');\n *\n * @example\n * // Formato de hora simples, como solicitado.\n * // Retorna algo como: \"19:37:33\"\n * getFormattedTimestamp('H:MN:S');\n *\n * @example\n * // Formato de data para logs (padrão ISO 8601).\n * // Retorna algo como: \"2025-08-22\"\n * getFormattedTimestamp('Y-MT-D');\n */\nfunction timestamp(format = 'D-MT-Y_H:MN:S:MS') {\n  const now = new Date();\n\n  // Mapeamento dos tokens para suas funções de obtenção e formatação.\n  // A avaliação é \"lazy\" (preguiçosa): a função só é executada quando o token correspondente\n  // é encontrado na string de formato, melhorando a performance.\n  const tokens = {\n    // Ano com 4 dígitos\n    Y: () => now.getFullYear(),\n    // Mês com 2 dígitos (getMonth() é 0-indexado)\n    MT: () => String(now.getMonth() + 1).padStart(2, '0'),\n    // Dia com 2 dígitos\n    D: () => String(now.getDate()).padStart(2, '0'),\n    // Hora com 2 dígitos (formato 24h)\n    H: () => String(now.getHours()).padStart(2, '0'),\n    // Minuto com 2 dígitos\n    MN: () => String(now.getMinutes()).padStart(2, '0'),\n    // Segundo com 2 dígitos\n    S: () => String(now.getSeconds()).padStart(2, '0'),\n    // Milissegundo com 3 dígitos\n    MS: () => String(now.getMilliseconds()).padStart(3, '0'),\n  };\n\n  // Usa uma expressão regular para encontrar e substituir todos os tokens de uma só vez.\n  // A flag 'g' (global) garante que todas as ocorrências de tokens sejam substituídas,\n  // não apenas a primeira.\n  // Para cada token encontrado, a função correspondente no objeto 'tokens' é chamada.\n  return format.replace(/Y|MT|D|H|MN|S|MS/g, (token) => tokens[token]());\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = timestamp;\n","/**\n * @file Utilitário cross-platform para converter strings UTF-8 para Uint8Array.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.1.0\n */\n\n/**\n * @summary Converte uma string (UTF-8) para um `Uint8Array` ou uma string de bytes.\n *\n * @description\n * Esta função converte uma string para sua representação binária como um `Uint8Array` em\n * formato UTF-8. Opcionalmente, se um caractere de junção (`joinChar`) for fornecido,\n * a função retornará uma string com os valores dos bytes unidos por esse caractere.\n * A conversão para bytes é cross-platform e lida corretamente com caracteres multi-byte.\n *\n * @param {string} [text=\"\"] - A string a ser convertida.\n * @param {string} [joinChar] - Opcional. Se fornecido, a função retorna uma string dos valores\n * dos bytes em vez de um `Uint8Array`.\n *\n * @returns {Uint8Array | string} Um `Uint8Array` com os bytes da string, ou uma `string`\n * formatada se `joinChar` for especificado.\n *\n * @example\n * // Retornando um Uint8Array\n * const bytes = uint8ArrayFromString('Hi');\n * console.log(bytes); // Uint8Array(2) [ 72, 105 ]\n *\n * // Retornando uma string formatada\n * const byteString = uint8ArrayFromString('Hi', '-');\n * console.log(byteString); // \"72-105\"\n */\nfunction uint8ArrayFromString(text = \"\", joinChar) {\n  // 1. Validação de tipo.\n  if (typeof text !== 'string') {\n    // Retorna um tipo consistente com o caminho de sucesso (string vazia ou array vazio).\n    return joinChar !== undefined ? '' : new Uint8Array();\n  }\n\n  let uint8Array;\n\n  // **Ambiente Node.js:**\n  if (typeof window === 'undefined') {\n    // `Buffer.from` cria um Buffer (que é um Uint8Array) a partir da string UTF-8.\n    uint8Array = Buffer.from(text, 'utf-8');\n  } else {\n    // **Ambiente do Navegador:**\n    // `TextEncoder` é a API padrão para converter strings em bytes UTF-8.\n    uint8Array = new TextEncoder().encode(text);\n  }\n\n  // 3. Decide o formato de saída com base na presença de `joinChar`.\n  if (joinChar !== undefined) {\n    // `Uint8Array` não possui o método `.join`, então é necessário converter\n    // para um array padrão antes de fazer a junção.\n    return Array.from(uint8Array).join(joinChar);\n  }\n\n  // Retorna o Uint8Array se nenhum `joinChar` for especificado.\n  return uint8Array;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = uint8ArrayFromString;","/**\n * @file Utilitário para converter um buffer (ou sua representação em string) para uma string de texto.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.1.0\n */\n\n/**\n * @summary Converte um `Uint8Array` ou uma string de bytes para uma string de texto (UTF-8).\n *\n * @description\n * Esta função tem um comportamento duplo:\n * 1. **Modo Padrão (sem `splitChar`):** Recebe um objeto buffer-like (`Uint8Array`, `Buffer`, `ArrayBuffer`)\n * e o decodifica para uma string UTF-8.\n * 2. **Modo de Análise (com `splitChar`):** Recebe uma **string** de números (representando bytes),\n * separados pelo `splitChar`. Ela irá analisar essa string, montar um `Uint8Array` e então decodificá-lo.\n *\n * @param {Uint8Array | ArrayBuffer | Buffer | string} uint8Array - O buffer a ser convertido,\n * ou a string de bytes a ser analisada.\n * @param {string} [splitChar] - Opcional. Ativa o modo de análise, usando este caractere como separador.\n *\n * @returns {string} A string decodificada.\n *\n * @example\n * // Modo Padrão (com um buffer real)\n * const bytes = new Uint8Array([72, 101, 108, 108, 111]); // Bytes para \"Hello\"\n * uint8ArrayToString(bytes); // Retorna \"Hello\"\n *\n * // Modo de Análise (com uma string de bytes)\n * const byteString = \"72,101,108,108,111\";\n * uint8ArrayToString(byteString, ','); // Retorna \"Hello\"\n */\nfunction uint8ArrayToString(uint8Array, splitChar) {\n  // 1. Validação de entrada básica.\n  if (uint8Array == null) {\n    return \"\";\n  }\n\n  let bufferSource = uint8Array;\n\n  // 2. Verifica se está no \"Modo de Análise\".\n  if (splitChar !== undefined && typeof uint8Array === 'string') {\n    // Converte a string de números (ex: \"72, 101, 108\") em um array de números.\n    const bytes = uint8Array.split(splitChar).map(s => parseInt(s.trim(), 10));\n    // Cria o buffer a partir dos números analisados.\n    bufferSource = new Uint8Array(bytes);\n  }\n\n  // 3. Decodifica o buffer para uma string UTF-8 (lógica cross-platform).\n  // `bufferSource` agora é garantidamente um objeto buffer-like.\n  try {\n    // Ambiente Node.js:\n    if (typeof window === 'undefined') {\n      const nodeBuffer = Buffer.isBuffer(bufferSource) ? bufferSource : Buffer.from(bufferSource);\n      return nodeBuffer.toString('utf-8');\n    }\n\n    // Ambiente do Navegador:\n    return new TextDecoder().decode(bufferSource);\n  } catch (error) {\n    // Retorna uma string vazia se o buffer de entrada for inválido para as APIs.\n    return \"\";\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nmodule.exports = uint8ArrayToString;","module.exports = {\n  assign: require(\"./assign.js\"),\n  base64From: require(\"./base64From.js\"),\n  base64FromBase64URLSafe: require(\"./base64FromBase64URLSafe.js\"),\n  base64FromBuffer: require(\"./base64FromBuffer.js\"),\n  base64To: require(\"./base64To.js\"),\n  base64ToBuffer: require(\"./base64ToBuffer.js\"),\n  base64URLEncode: require(\"./base64URLEncode.js\"),\n  bufferCompare: require(\"./bufferCompare.js\"),\n  bufferConcatenate: require(\"./bufferConcatenate.js\"),\n  bufferFromString: require(\"./bufferFromString.js\"),\n  bufferToString: require(\"./bufferToString.js\"),\n  calculateSecondsInTime: require(\"./calculateSecondsInTime.js\"),\n  currencyBRToFloat: require(\"./currencyBRToFloat.js\"),\n  dateToFormat: require(\"./dateToFormat.js\"),\n  dateFirstHourOfDay: require(\"./dateFirstHourOfDay.js\"),\n  dateLastHourOfDay: require(\"./dateLastHourOfDay.js\"),\n  debouncer: require(\"./debouncer.js\"),\n  deleteKeys: require(\"./deleteKeys.js\"),\n  generateSimpleId: require(\"./generateSimpleId.js\"),\n  generateRandomString: require(\"./generateRandomString.js\"),\n  getExecutionTime: require(\"./getExecutionTime.js\"),\n  JSONFrom: require(\"./JSONFrom.js\"),\n  JSONTo: require(\"./JSONTo.js\"),\n  messageEncryptToChunks: require(\"./messageEncryptToChunks.js\"),\n  messageDecryptFromChunks: require(\"./messageDecryptFromChunks.js\"),\n  normalize: require(\"./normalize.js\"),\n  pickKeys: require(\"./pickKeys.js\"),\n  pushLogMessage: require(\"./pushLogMessage.js\"),\n  regexDigitsOnly: require(\"./regexDigitsOnly.js\"),\n  regexReplaceTrim: require(\"./regexReplaceTrim.js\"),\n  regexLettersOnly: require(\"./regexLettersOnly.js\"),\n  removeDuplicatedStrings: require(\"./removeDuplicatedStrings.js\"),\n  sleep: require(\"./sleep.js\"),\n  split: require(\"./split\"),\n  stringCompress: require(\"./stringCompress.js\"),\n  stringDecompress: require(\"./stringDecompress.js\"),\n  stringToDate: require(\"./stringToDate.js\"),\n  stringToDateToFormat: require(\"./stringToDateToFormat.js\"),\n  stringToFormat: require(\"./stringToFormat.js\"),\n  stringZLibCompress: require(\"./stringZLibCompress.js\"),\n  stringZLibDecompress: require(\"./stringZLibDecompress.js\"),\n  throttle: require(\"./throttle.js\"),\n  timestamp: require(\"./timestamp.js\"),\n  toString: require(\"./toString.js\"),\n  uint8ArrayFromString: require(\"./uint8ArrayFromString\"),\n  uint8ArrayToString: require(\"./uint8ArrayToString\"),\n};\n","/**\n * @fileoverview Funções para validação de inscrição estadual (CAD/ICMS) do estado do Paraná (PR).\n * Código compatível com Node.js e navegadores.\n */\n\n/**\n * Calcula um dígito verificador com base em uma sequência de dígitos e um array de pesos.\n * Esta é uma função auxiliar interna para evitar a repetição da lógica de cálculo.\n *\n * @param {string} digits - A sequência de dígitos a ser usada no cálculo.\n * @param {number[]} weights - O array de pesos para multiplicar cada dígito.\n * @returns {number} O dígito verificador calculado.\n * @private\n */\nfunction _calculateVerifierDigit(digits, weights) {\n  // Multiplica cada dígito pelo seu peso correspondente e soma os resultados.\n  // O uso de 'reduce' é uma forma funcional e concisa de realizar a soma ponderada.\n  const sum = digits\n    .split('')\n    .reduce((acc, digit, index) => acc + (Number(digit) * weights[index]), 0);\n\n  const remainder = sum % 11;\n\n  // Conforme a regra de cálculo, se o resto for 0 ou 1, o dígito é 0.\n  // Caso contrário, é 11 menos o resto.\n  return (remainder <= 1) ? 0 : 11 - remainder;\n}\n\n/**\n * Valida uma inscrição estadual (CAD/ICMS) do estado do Paraná (PR).\n * A função lida com entradas formatadas (com pontos, traços) e não formatadas,\n * desde que contenham a quantidade correta de dígitos.\n *\n * @summary Valida o CAD/ICMS do estado do Paraná.\n * @param {string | number} cadicms O valor do CAD/ICMS a ser validado.\n * @returns {boolean} Retorna `true` se o CAD/ICMS for válido, e `false` caso contrário.\n * @example\n * // Exemplo com números e strings formatadas/não formatadas\n * validateCADICMSPR(\"90312851-11\"); // true\n * validateCADICMSPR(\"9031285111\");  // true\n * validateCADICMSPR(9031285111);   // true\n * validateCADICMSPR(\"1234567890\");  // false\n */\nfunction validateCADICMSPR(cadicms) {\n  // Garante que a entrada seja uma string e remove todos os caracteres não numéricos.\n  // O construtor String() lida de forma segura com null, undefined e outros tipos.\n  const digitsOnly = String(cadicms).replace(/[^\\d]/g, '');\n\n  // Define o tamanho esperado para a inscrição estadual.\n  const CADICMS_LENGTH = 10;\n\n  // A inscrição estadual deve ter no máximo 10 dígitos e não pode estar vazia.\n  // A validação original permite números menores que 10 e os preenche com zeros,\n  // essa lógica é mantida.\n  if (digitsOnly === '' || digitsOnly.length > CADICMS_LENGTH) {\n    return false;\n  }\n\n  // Se a string for menor que 10, preenche com zeros à esquerda até atingir o tamanho correto.\n  const paddedCadicms = digitsOnly.padStart(CADICMS_LENGTH, '0');\n\n  // --- Cálculo do Primeiro Dígito Verificador ---\n\n  // Pesos para o cálculo do primeiro dígito (baseado nos 8 primeiros dígitos da inscrição).\n  const WEIGHTS_DV1 = [3, 2, 7, 6, 5, 4, 3, 2];\n  const firstEightDigits = paddedCadicms.substring(0, 8);\n  const expectedFirstVerifier = _calculateVerifierDigit(firstEightDigits, WEIGHTS_DV1);\n\n  // Compara o dígito calculado com o nono dígito da inscrição.\n  // A conversão para Number() garante uma comparação estrita de tipos.\n  const firstVerifier = Number(paddedCadicms[8]);\n  if (expectedFirstVerifier !== firstVerifier) {\n    return false;\n  }\n\n  // --- Cálculo do Segundo Dígito Verificador ---\n\n  // Pesos para o cálculo do segundo dígito (baseado nos 9 primeiros dígitos da inscrição).\n  const WEIGHTS_DV2 = [4, 3, 2, 7, 6, 5, 4, 3, 2];\n  const firstNineDigits = paddedCadicms.substring(0, 9);\n  const expectedSecondVerifier = _calculateVerifierDigit(firstNineDigits, WEIGHTS_DV2);\n\n  // Compara o dígito calculado com o décimo (último) dígito da inscrição.\n  const secondVerifier = Number(paddedCadicms[9]);\n  \n  // O retorno final é o resultado da comparação do segundo dígito.\n  return expectedSecondVerifier === secondVerifier;\n}\n\n// ------------------------------------------------------------------------------------------------\n\n// Mantém a exportação no padrão CommonJS para compatibilidade com Node.js.\n// Em um ambiente de navegador, esta linha será ignorada.\nmodule.exports = validateCADICMSPR;\n\n// ------------------------------------------------------------------------------------------------","/**\n * @fileoverview Fornece uma função para validar CEP (Código de Endereçamento Postal).\n */\n\n/**\n * Valida um CEP (Código de Endereçamento Postal).\n *\n * @summary Valida um CEP.\n * @description A função verifica se a entrada consiste em exatamente 8 dígitos numéricos,\n * ignorando caracteres de máscara.\n *\n * @param {string | number} cep O CEP a ser validado.\n * @returns {boolean} Retorna `true` se o CEP for válido, e `false` caso contrário.\n * @example\n * validateCEP(\"80000-123\"); // true\n * validateCEP(\"1234567\");   // false\n */\nfunction validateCEP(cep = \"\") {\n  const digitsOnly = String(cep).replace(/[^\\d]/g, \"\");\n  return digitsOnly.length === 8;\n}\n\n// ------------------------------------------------------------------------------------------------\nmodule.exports = validateCEP;\n// ------------------------------------------------------------------------------------------------\n","/**\n * @fileoverview Fornece uma função para validar números de CNPJ (Cadastro Nacional da Pessoa Jurídica).\n * O código é compatível com ambientes Node.js e navegadores.\n */\n\n/**\n * Array de pesos utilizado no algoritmo de cálculo dos dígitos verificadores do CNPJ.\n * @private\n * @type {number[]}\n */\nconst DEFAULT_WEIGHTS = [6, 5, 4, 3, 2, 9, 8, 7, 6, 5, 4, 3, 2];\n\n/**\n * Calcula o valor numérico de um caractere para o algoritmo de soma ponderada.\n * A conversão é baseada no valor ASCII do caractere, o que resulta em um\n * mapeamento específico para letras (ex: 'A' => 17, 'B' => 18).\n *\n * @private\n * @param {string} char - O caractere a ser convertido.\n * @returns {number} O valor numérico correspondente para o cálculo.\n */\nfunction _getCharValue(char) {\n  // A subtração do charCode de '0' é o método que define a conversão.\n  return char.charCodeAt(0) - '0'.charCodeAt(0);\n}\n\n/**\n * Calcula os dois dígitos verificadores para uma base de 12 caracteres de um CNPJ.\n *\n * @private\n * @param {string} baseCnpj - Os 12 primeiros caracteres do CNPJ.\n * @param {number[]} weights - O array de pesos a ser usado no cálculo.\n * @returns {string} Uma string contendo os dois dígitos verificadores calculados.\n */\nfunction _calculateVerifierDigits(baseCnpj, weights) {\n  /**\n   * Calcula um único dígito verificador a partir do resultado de uma soma ponderada.\n   * @param {number} sum - A soma ponderada.\n   * @returns {number} O dígito verificador (0 a 9).\n   */\n  const getDigit = (sum) => {\n    const remainder = sum % 11;\n    return remainder < 2 ? 0 : 11 - remainder;\n  };\n\n  let sum1 = 0;\n  let sum2 = 0;\n\n  for (let i = 0; i < baseCnpj.length; i++) {\n    // Converte o caractere para seu valor numérico específico do algoritmo.\n    const value = _getCharValue(baseCnpj[i]);\n    sum1 += value * weights[i + 1];\n    sum2 += value * weights[i];\n  }\n\n  const dv1 = getDigit(sum1);\n  sum2 += dv1 * weights[baseCnpj.length]; // Adiciona o primeiro dígito ao cálculo do segundo.\n  const dv2 = getDigit(sum2);\n\n  return `${dv1}${dv2}`;\n}\n\n/**\n * Valida um número de CNPJ (Cadastro Nacional da Pessoa Jurídica).\n *\n * @summary Valida um CNPJ, com suporte a formatos alfanuméricos.\n * @description A função suporta o formato numérico padrão e o futuro formato alfanumérico.\n * A entrada pode conter ou não os caracteres de máscara comuns ('.', '/', '-').\n *\n * @param {string | number} cnpj O CNPJ a ser validado.\n * @param {object} [options={}] Opções de configuração para a validação.\n * @param {string} [options.addPaddingChar=\"0\"] Caractere a ser usado para preencher a entrada até 14 caracteres.\n * @param {number[]} [options.weights=DEFAULT_WEIGHTS] Array de pesos para o cálculo dos dígitos verificadores.\n * @param {boolean} [options.ignoreToUpperCase=true] Se `false`, a entrada é convertida para maiúsculas. Se `true`, a validação diferencia maiúsculas de minúsculas.\n * @param {boolean} [options.ignorePadding=false] Se `true`, a função não adiciona preenchimento, validando a entrada como está.\n * @returns {boolean} Retorna `true` se o CNPJ for válido, e `false` caso contrário.\n */\nfunction validateCNPJ(cnpj = \"\", options = {}) {\n  // 1. Normalização e Configuração\n  let processedCnpj = String(cnpj).replace(/[./-]/g, \"\");\n\n  const finalOptions = {\n    addPaddingChar: \"0\",\n    weights: DEFAULT_WEIGHTS,\n    ignorePadding: false,\n    ignoreToUpperCase: true,\n    ...options,\n  };\n\n  // A conversão para maiúsculas é um comportamento opcional controlado via `options`.\n  if (finalOptions.ignoreToUpperCase === false) {\n    processedCnpj = processedCnpj.toUpperCase();\n  }\n\n  if (!finalOptions.ignorePadding) {\n    processedCnpj = processedCnpj.padStart(14, finalOptions.addPaddingChar);\n  }\n\n  // 2. Regras de Validação de Formato e Casos Inválidos\n\n  // O CNPJ deve consistir em 12 caracteres alfanuméricos (base) e 2 dígitos (verificadores).\n  const regexCNPJ = /^([A-Z\\d]){12}(\\d){2}$/;\n  if (!regexCNPJ.test(processedCnpj)) {\n    return false;\n  }\n  \n  // Para CNPJs puramente numéricos, sequências de dígitos repetidos são inválidas (ex: '111...').\n  if (/^\\d+$/.test(processedCnpj) && /^(\\d)\\1{13}$/.test(processedCnpj)) {\n    return false;\n  }\n\n  // 3. Cálculo e Verificação Final\n  const baseDigits = processedCnpj.substring(0, 12);\n  const verifierDigits = processedCnpj.substring(12);\n\n  const calculatedVerifierDigits = _calculateVerifierDigits(baseDigits, finalOptions.weights);\n\n  return verifierDigits === calculatedVerifierDigits;\n}\n\n// ------------------------------------------------------------------------------------------------\n\n// Exporta a função para uso em ambientes Node.js (CommonJS).\nmodule.exports = validateCNPJ;\n\n// ------------------------------------------------------------------------------------------------","/**\n * @fileoverview Fornece uma função para validar números de CPF (Cadastro de Pessoas Físicas).\n * O código é compatível com ambientes Node.js e navegadores.\n */\n\n/**\n * Calcula um dígito verificador de CPF a partir de uma base de dígitos.\n * O algoritmo é o mesmo para o primeiro e o segundo dígito, variando apenas o tamanho da base.\n *\n * @private\n * @param {string} baseDigits - A sequência de dígitos para o cálculo (9 para o 1º dígito, 10 para o 2º).\n * @returns {number} O dígito verificador calculado.\n */\nfunction _calculateVerifierDigit(baseDigits) {\n  // O peso inicial é o tamanho da base + 1 (10 para o 1º dígito, 11 para o 2º).\n  const initialWeight = baseDigits.length + 1;\n\n  // Calcula a soma ponderada dos dígitos.\n  const sum = baseDigits\n    .split('')\n    .reduce((acc, digit, index) => acc + (Number(digit) * (initialWeight - index)), 0);\n\n  const remainder = sum % 11;\n\n  // Se o resto da divisão for menor que 2, o dígito é 0; caso contrário, é 11 menos o resto.\n  return remainder < 2 ? 0 : 11 - remainder;\n}\n\n/**\n * Valida um número de CPF (Cadastro de Pessoas Físicas).\n *\n * @summary Valida um CPF, numérico ou com máscara.\n * @description A função remove caracteres de máscara, verifica casos inválidos conhecidos\n * e calcula os dois dígitos verificadores para confirmar a validade do CPF.\n *\n * @param {string | number} cpf O número de CPF a ser validado.\n * @returns {boolean} Retorna `true` se o CPF for válido, e `false` caso contrário.\n * @example\n * validateCPF(\"123.456.789-00\"); // Exemplo válido\n * validateCPF(\"111.111.111-11\"); // Retorna false\n */\nfunction validateCPF(cpf = \"\") {\n  // 1. Normalização da Entrada\n  const digitsOnly = String(cpf).replace(/[^\\d]/g, '');\n\n  const CPF_LENGTH = 11;\n\n  // Rejeita a entrada se, após a limpeza, estiver vazia ou com mais de 11 dígitos.\n  if (digitsOnly === '' || digitsOnly.length > CPF_LENGTH) {\n    return false;\n  }\n\n  // Garante que a string tenha 11 dígitos, preenchendo com zeros à esquerda se necessário.\n  const paddedCpf = digitsOnly.padStart(CPF_LENGTH, '0');\n\n  // 2. Verificação de Casos Inválidos\n  // CPFs com todos os dígitos iguais são inválidos. A regex /^(\\d)\\1{10}$/ checa essa condição.\n  if (/^(\\d)\\1{10}$/.test(paddedCpf)) {\n    return false;\n  }\n\n  // 3. Cálculo e Validação dos Dígitos\n  const baseDv1 = paddedCpf.substring(0, 9);\n  const expectedDv1 = _calculateVerifierDigit(baseDv1);\n\n  // Compara o primeiro dígito verificador calculado com o fornecido.\n  if (expectedDv1 !== Number(paddedCpf[9])) {\n    return false;\n  }\n\n  const baseDv2 = paddedCpf.substring(0, 10);\n  const expectedDv2 = _calculateVerifierDigit(baseDv2);\n\n  // Compara o segundo dígito e retorna o resultado final da validação.\n  return expectedDv2 === Number(paddedCpf[10]);\n}\n\n// ------------------------------------------------------------------------------------------------\n\n// Exporta a função para uso em ambientes Node.js (CommonJS).\nmodule.exports = validateCPF;\n\n// ------------------------------------------------------------------------------------------------","/**\n * @fileoverview Fornece uma função para validar endereços de e-mail.\n * O código é compatível com ambientes Node.js e navegadores.\n */\n\n/**\n * Expressão regular para validar a maioria dos formatos de e-mail padrão.\n * Definida como uma constante fora da função para evitar a recompilação a cada\n * chamada, o que melhora a performance.\n * @private\n * @type {RegExp}\n */\nconst EMAIL_REGEX =\n  /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n\n/**\n * Valida um endereço de e-mail com base em um formato padrão.\n *\n * @summary Valida um endereço de e-mail.\n * @description A função verifica se a string fornecida corresponde a um formato de e-mail\n * comum, cobrindo a maioria dos casos de uso padrão (ex: `usuario@dominio.com`).\n *\n * @param {string | any} email O valor a ser verificado. A função o converterá para string.\n * @returns {boolean} Retorna `true` se o e-mail tiver um formato válido, e `false` caso contrário.\n * @example\n * validateEmail(\"contato@exemplo.com\"); // true\n * validateEmail(\"email-invalido\");       // false\n */\nfunction validateEmail(email = \"\") {\n  // Converte a entrada para string para garantir que o método .test() funcione.\n  const emailAsString = String(email);\n\n  // Testa a string contra a expressão regular pré-compilada.\n  return EMAIL_REGEX.test(emailAsString);\n}\n\n// ------------------------------------------------------------------------------------------------\n\n// Exporta a função para uso em ambientes Node.js (CommonJS).\nmodule.exports = validateEmail;\n\n// ------------------------------------------------------------------------------------------------\n","/**\n * @fileoverview Fornece uma função para validar Chaves PIX.\n * @author Seu Nome <seu.email@example.com>\n * @version 2.5.0\n */\n\nconst validateCNPJ = require(\"./validateCNPJ\");\nconst validateCPF = require(\"./validateCPF\");\nconst validateEmail = require(\"./validateEmail\");\n\n/**\n * Regex para validar um UUID v4 (formato da Chave Aleatória PIX).\n * @private\n */\nconst UUID_V4_REGEX =\n  /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n\n/**\n * Regex para validar um número de telefone brasileiro no formato PIX (+55DDXXXXXXXXX).\n * @private\n */\n// Versão Oficial: Aceita 10 (fixo) ou 11 (celular) dígitos após o +55.\nconst PIX_PHONE_REGEX = /^\\+55\\d{10,11}$/;\n\n/**\n * @summary Valida uma Chave PIX de qualquer tipo, incluindo CNPJ alfanumérico.\n * @description\n * A função verifica se a chave fornecida corresponde a um dos cinco formatos\n * válidos de Chave PIX, delegando a validação de CPF, CNPJ e E-mail para as\n * funções correspondentes.\n *\n * @param {string} [chave=\"\"] - A Chave PIX a ser validada.\n * @returns {boolean} Retorna `true` se a chave for válida, e `false` caso contrário.\n *\n * @example\n * validateChavePix(\"meu.email@valido.com\"); // true\n * validateChavePix(\"11122233344\");         // true (se for um CPF válido)\n * validateChavePix(\"+5511987654321\");      // true (celular)\n * validateChavePix(\"+554133334444\");       // true (fixo)\n */\nfunction validateChavePix(chave = \"\") {\n  // Converte a entrada para string e remove espaços das pontas.\n  const keyAsString = String(chave || \"\").trim();\n\n  // Uma chave PIX não pode ser vazia.\n  if (keyAsString === \"\") {\n    return false;\n  }\n\n  // A ordem de verificação é importante para performance e para evitar ambiguidades.\n  if (UUID_V4_REGEX.test(keyAsString)) return true;\n  if (PIX_PHONE_REGEX.test(keyAsString)) return true;\n  if (keyAsString.includes(\"@\")) return validateEmail(keyAsString);\n  \n  // Para os formatos restantes (CPF/CNPJ), delega a validação.\n  if (validateCPF(keyAsString)) {\n    return true;\n  }\n  \n  if (validateCNPJ(keyAsString)) {\n    return true;\n  }\n\n  // Se não se encaixou em nenhum formato, é inválida.\n  return false;\n}\n\n// ------------------------------------------------------------------------------------------------\nmodule.exports = validateChavePix;","/**\n * @fileoverview Fornece uma função para validar números de CNH.\n */\n\n/**\n * Pesos para o cálculo do primeiro e segundo dígito verificador da CNH.\n * @private\n */\nconst CNH_WEIGHTS_DV1 = [9, 8, 7, 6, 5, 4, 3, 2, 1];\nconst CNH_WEIGHTS_DV2 = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\n/**\n * Valida um número de CNH (Carteira Nacional de Habilitação).\n *\n * @summary Valida um número de CNH.\n * @description A função verifica o formato, a regra de dígitos repetidos e calcula os\n * dois dígitos verificadores para confirmar a validade do número.\n *\n * @param {string | number} cnh O número da CNH a ser validado.\n * @returns {boolean} Retorna `true` se a CNH for válida, e `false` caso contrário.\n */\nfunction validateCNH(cnh = \"\") {\n  const digitsOnly = String(cnh).replace(/[^\\d]/g, \"\");\n\n  if (digitsOnly.length !== 11 || /^(\\d)\\1{10}$/.test(digitsOnly)) {\n    return false;\n  }\n\n  const base = digitsOnly.substring(0, 9);\n  const verifierDigits = digitsOnly.substring(9);\n\n  // --- Cálculo do primeiro dígito ---\n  const sum1 = base\n    .split(\"\")\n    .reduce(\n      (acc, digit, index) => acc + Number(digit) * CNH_WEIGHTS_DV1[index],\n      0\n    );\n\n  const remainder1 = sum1 % 11;\n  const calculatedDv1 = remainder1 >= 10 ? 0 : remainder1;\n\n  if (calculatedDv1 !== Number(verifierDigits[0])) {\n    return false;\n  }\n\n  // --- Cálculo do segundo dígito ---\n  const sum2 = base\n    .split(\"\")\n    .reduce(\n      (acc, digit, index) => acc + Number(digit) * CNH_WEIGHTS_DV2[index],\n      0\n    );\n\n  const remainder2 = sum2 % 11;\n  const calculatedDv2 = remainder2 >= 10 ? 0 : remainder2;\n\n  return calculatedDv2 === Number(verifierDigits[1]);\n}\n\n// ------------------------------------------------------------------------------------------------\nmodule.exports = validateCNH;\n// ------------------------------------------------------------------------------------------------\n","/**\n * @fileoverview Fornece uma função para validar números de PIS/PASEP/NIT.\n */\n\n/**\n * Array de pesos utilizado no algoritmo de cálculo do dígito verificador.\n * @private\n * @type {number[]}\n */\nconst PIS_WEIGHTS = [3, 2, 9, 8, 7, 6, 5, 4, 3, 2];\n\n/**\n * Valida um número de PIS/PASEP/NIT.\n *\n * @summary Valida um número de PIS/PASEP/NIT.\n * @description A função verifica o formato, a regra de dígitos repetidos e o dígito\n * verificador para confirmar a validade do número.\n *\n * @param {string | number} pis O número a ser validado.\n * @returns {boolean} Retorna `true` se o número for válido, e `false` caso contrário.\n * @example\n * validatePISPASEPNIT(\"120.12345.67-8\"); // true\n * validatePISPASEPNIT(\"11111111111\");    // false\n */\nfunction validatePISPASEPNIT(pis = \"\") {\n  const digitsOnly = String(pis).replace(/[^\\d]/g, \"\");\n\n  if (digitsOnly.length !== 11 || /^(\\d)\\1{10}$/.test(digitsOnly)) {\n    return false;\n  }\n\n  const base = digitsOnly.substring(0, 10);\n  const verifierDigit = Number(digitsOnly[10]);\n\n  const sum = base\n    .split(\"\")\n    .reduce((acc, digit, index) => acc + Number(digit) * PIS_WEIGHTS[index], 0);\n\n  const remainder = sum % 11;\n  const calculatedDigit = remainder < 2 ? 0 : 11 - remainder;\n\n  return verifierDigit === calculatedDigit;\n}\n\n// ------------------------------------------------------------------------------------------------\nmodule.exports = validatePISPASEPNIT;\n// ------------------------------------------------------------------------------------------------\n","/**\n * @fileoverview Fornece uma função para validar códigos de RENAVAM.\n */\n\n/**\n * Array de pesos utilizado no cálculo do dígito verificador do RENAVAM.\n * @private\n * @type {number[]}\n */\nconst RENAVAM_WEIGHTS = [2, 3, 4, 5, 6, 7, 8, 9, 2, 3];\n\n/**\n * Valida um código de RENAVAM (Registro Nacional de Veículos Automotores).\n *\n * @summary Valida um código de RENAVAM.\n * @description A função valida o formato de 11 dígitos (preenchendo com zeros se\n * necessário) e calcula o dígito verificador para confirmar sua validade.\n *\n * @param {string | number} renavam O código a ser validado.\n * @returns {boolean} Retorna `true` se o RENAVAM for válido, e `false` caso contrário.\n */\nfunction validateRENAVAM(renavam = \"\") {\n  const digitsOnly = String(renavam).replace(/[^\\d]/g, \"\").padStart(11, \"0\");\n\n  if (digitsOnly.length !== 11 || /^(\\d)\\1{10}$/.test(digitsOnly)) {\n    return false;\n  }\n\n  const base = digitsOnly.substring(0, 10);\n  const verifierDigit = Number(digitsOnly[10]);\n\n  const reversedBase = base.split(\"\").reverse();\n\n  const sum = reversedBase.reduce(\n    (acc, digit, index) => acc + Number(digit) * RENAVAM_WEIGHTS[index],\n    0\n  );\n\n  const remainder = sum % 11;\n  const calculatedDigit = remainder <= 1 ? 0 : 11 - remainder;\n\n  return verifierDigit === calculatedDigit;\n}\n\n// ------------------------------------------------------------------------------------------------\nmodule.exports = validateRENAVAM;\n// ------------------------------------------------------------------------------------------------\n","/**\n * @fileoverview Fornece uma função para validar números de Título de Eleitor.\n */\n\n/**\n * Pesos para o cálculo do primeiro dígito verificador.\n * @private\n */\nconst TITULO_WEIGHTS_DV1 = [2, 3, 4, 5, 6, 7, 8, 9];\n\n/**\n * Valida um número de Título de Eleitor.\n *\n * @summary Valida um número de Título de Eleitor.\n * @description A função valida o formato de 12 dígitos e calcula ambos os dígitos\n * verificadores, considerando as regras especiais baseadas no estado de emissão.\n *\n * @param {string | number} titulo O número do título a ser validado.\n * @returns {boolean} Retorna `true` se o título for válido, e `false` caso contrário.\n */\nfunction validateTituloEleitor(titulo = \"\") {\n  // Verifica se o parâmetro é nulo ou indefinido\n  if (titulo == null) {\n    return false;\n  }\n\n  const digitsOnly = String(titulo).replace(/[^\\d]/g, \"\").padStart(12, \"0\");\n\n  if (digitsOnly.length !== 12) {\n    return false;\n  }\n\n  const base = digitsOnly.substring(0, 8);\n  const stateCode = Number(digitsOnly.substring(8, 10));\n  const verifierDigits = digitsOnly.substring(10);\n\n  // O código de estado deve ser válido (entre 1 e 28)\n  if (stateCode < 1 || stateCode > 28) {\n    return false;\n  }\n\n  // --- Cálculo do primeiro dígito verificador ---\n  const sum1 = base\n    .split(\"\")\n    .reduce(\n      (acc, digit, index) => acc + Number(digit) * TITULO_WEIGHTS_DV1[index],\n      0\n    );\n\n  let remainder1 = sum1 % 11;\n  let calculatedDv1;\n\n  // Regras para o primeiro DV baseadas na documentação oficial:\n  // - Se resto for 0: para SP (01) e MG (02) é 1, para outros estados é 0\n  // - Se resto for maior que 9: é 0\n  // - Nos outros casos: é o próprio resto\n  if (remainder1 === 0) {\n    calculatedDv1 = (stateCode === 1 || stateCode === 2) ? 1 : 0;\n  } else if (remainder1 > 9) {\n    calculatedDv1 = 0;\n  } else {\n    calculatedDv1 = remainder1;\n  }\n\n  if (calculatedDv1 !== Number(verifierDigits[0])) {\n    return false;\n  }\n\n  // --- Cálculo do segundo dígito verificador ---\n  const digit1 = Number(digitsOnly.substring(8, 9)); // Primeiro dígito do código do estado\n  const digit2 = Number(digitsOnly.substring(9, 10)); // Segundo dígito do código do estado\n  \n  const sum2 = (digit1 * 7) + (digit2 * 8) + (calculatedDv1 * 9);\n\n  let remainder2 = sum2 % 11;\n  let calculatedDv2;\n  \n  // Mesma lógica do primeiro dígito verificador.\n  if (remainder2 === 0) {\n    calculatedDv2 = (stateCode === 1 || stateCode === 2) ? 1 : 0;\n  } else if (remainder2 > 9) {\n    calculatedDv2 = 0;\n  } else {\n    calculatedDv2 = remainder2;\n  }\n\n  return calculatedDv2 === Number(verifierDigits[1]);\n}\n\n// ------------------------------------------------------------------------------------------------\nmodule.exports = validateTituloEleitor;\n// ------------------------------------------------------------------------------------------------","/**\n * @fileoverview Fornece uma função para validar números de RG (Registro Geral) brasileiro.\n */\n\n/**\n * Pesos para o cálculo do dígito verificador do RG.\n * Os fatores multiplicadores crescem da esquerda para a direita, iniciando em 2.\n * @private\n */\nconst RG_WEIGHTS = [2, 3, 4, 5, 6, 7, 8, 9];\n\n/**\n * Valida um número de RG (Registro Geral) brasileiro.\n *\n * @summary Valida um número de RG brasileiro usando o algoritmo de módulo 11.\n * @description A função valida o formato de 8 dígitos seguido por um dígito verificador,\n * que pode ser um número (0-9) ou a letra 'X' quando o cálculo resulta em 10.\n * Remove automaticamente pontuação e formatação do input.\n *\n * @param {string | number} rg O número do RG a ser validado (com ou sem formatação).\n * @returns {boolean} Retorna `true` se o RG for válido, e `false` caso contrário.\n *\n * @example\n * validateRG('24.678.131-4'); // true\n * validateRG('37.606.335-X'); // true\n * validateRG('45.727.503-0'); // true\n * validateRG('123456789'); // false\n * validateRG('24678131X'); // false (dígito verificador incorreto)\n */\nfunction validateRG(rg = \"\") {\n  // Verifica se o parâmetro é nulo ou indefinido\n  if (rg == null) {\n    return false;\n  }\n\n  // Remove toda formatação, mantendo apenas números e a letra X\n  const cleanRG = String(rg)\n    .toUpperCase()\n    .replace(/[^\\dX]/g, \"\");\n\n  // RG deve ter exatamente 9 caracteres (8 dígitos + 1 verificador)\n  if (cleanRG.length !== 9) {\n    return false;\n  }\n\n  // Extrai os 8 primeiros dígitos (base) e o dígito verificador\n  const base = cleanRG.substring(0, 8);\n  const verifierDigit = cleanRG.substring(8);\n\n  // Verifica se a base contém apenas dígitos\n  if (!/^\\d{8}$/.test(base)) {\n    return false;\n  }\n\n  // Verifica se o dígito verificador é válido (0-9 ou X)\n  if (!/^[\\dX]$/.test(verifierDigit)) {\n    return false;\n  }\n\n  // Verifica se todos os dígitos da base são iguais (RG inválido por convenção)\n  if (/^(\\d)\\1{7}$/.test(base)) {\n    return false;\n  }\n\n  // --- Cálculo do dígito verificador usando módulo 11 ---\n  \n  // Multiplica cada dígito pelo seu peso correspondente\n  const sum = base\n    .split(\"\")\n    .reduce((acc, digit, index) => {\n      return acc + (Number(digit) * RG_WEIGHTS[index]);\n    }, 0);\n\n  // Calcula o resto da divisão por 11\n  const remainder = sum % 11;\n  \n  // Calcula o complemento (11 - resto)\n  const complement = 11 - remainder;\n  \n  // Determina o dígito verificador calculado\n  let calculatedDigit;\n  \n  if (complement === 10) {\n    // Quando o complemento é 10, o dígito verificador é 'X'\n    calculatedDigit = 'X';\n  } else if (complement === 11) {\n    // Quando o complemento é 11, o dígito verificador é '0'\n    calculatedDigit = '0';\n  } else {\n    // Para outros casos, o dígito verificador é o próprio complemento\n    calculatedDigit = String(complement);\n  }\n\n  // Compara o dígito calculado com o fornecido\n  return calculatedDigit === verifierDigit;\n}\n\n// ------------------------------------------------------------------------------------------------\nmodule.exports = validateRG;\n// ------------------------------------------------------------------------------------------------","module.exports = {\n  validateCADICMSPR: require(\"./validateCADICMSPR.js\"),\n  validateCEP: require(\"./validateCEP.js\"),\n  validateChavePix: require(\"./validateChavePix.js\"),\n  validateCNH: require(\"./validateCNH.js\"),\n  validateCNPJ: require(\"./validateCNPJ.js\"),\n  validateCPF: require(\"./validateCPF.js\"),\n  validateEmail: require(\"./validateEmail.js\"),\n  validatePISPASEPNIT: require(\"./validatePISPASEPNIT.js\"),\n  validateRenavam: require(\"./validateRenavam.js\"),\n  validateTituloEleitor: require(\"./validateTituloEleitor.js\"),\n  validateRG: require(\"./validateRG.js\"),\n};\n","module.exports = {\n  setConditionBetweenDates: require(\"./setConditionsBetweenDates.js\"),\n  setConditionBetweenValues: require(\"./setConditionsBetweenValues.js\"),\n  setConditionStringLike: require(\"./setConditionStringLike.js\"),\n};\n","module.exports = {\n  auth: {\n    webAuthn: require(\"./auth/webauthn/index.js\"),\n  },\n  constants: require(\"./constants.js\"),\n  crypto: require(\"./crypto/index.js\"),\n  custom: {\n    db: {\n      sequelize: {\n        setConditionBetweenDates: require(\"./custom/db/sequelize/setConditionsBetweenDates.js\"),\n        setConditionBetweenValues: require(\"./custom/db/sequelize/setConditionsBetweenValues.js\"),\n        setConditionStringLike: require(\"./custom/db/sequelize/setConditionStringLike.js\"),\n      },\n    },\n    waitPlugin: require(\"./custom/waitPlugin\"),\n    bulkProcessor: require(\"./custom/bulkProcessor.js\"),\n  },\n  helpers: require(\"./helpers/index.js\"),\n  utils: require(\"./utils/index.js\"),\n  validators: require(\"./validators/index.js\"),\n  ...require(\"./custom/db/sequelize\"),\n  ...require(\"./helpers\"),\n  ...require(\"./utils\"),\n  ...require(\"./validators\"),\n  ...require(\"./auth/webauthn\"),\n  ...require(\"./crypto\"),\n  waitPlugin: require(\"./custom/waitPlugin\"),\n  bulkProcessor: require(\"./custom/bulkProcessor\"),\n};\n"],"mappings":"uTAAA,IAAAA,EAAAC,EAAA,CAAAC,GAAAC,KAAA,CA4BA,SAASC,GAAkBC,EAASC,EAAS,CAG3C,GAAID,GAAW,MAAQC,GAAW,KAChC,OAAO,KAGT,GAAI,CAGF,IAAMC,EAAQ,IAAI,WAAWF,CAAO,EAC9BG,EAAQ,IAAI,WAAWF,CAAO,EAG9BG,EAAa,IAAI,WAAWF,EAAM,OAASC,EAAM,MAAM,EAG7D,OAAAC,EAAW,IAAIF,EAAO,CAAC,EACvBE,EAAW,IAAID,EAAOD,EAAM,MAAM,EAG3BE,EAAW,MACpB,MAAgB,CAGd,OAAO,IACT,CACF,CAIAN,GAAO,QAAUC,KC3DjB,IAAAM,EAAAC,EAAA,CAAAC,GAAAC,KAAA,KAAMC,GAAoB,IAiB1B,SAASC,GAA0BC,EAAe,CAChD,IAAMC,EAAWC,GAAwBF,CAAa,EAEtD,GAAIC,EAAS,SAAW,EACtB,MAAM,IAAI,MAAM,oCAAoC,EAGtD,GAAI,CAAC,EAAGE,CAAC,EAAIF,EAGb,SAAIG,GAAwB,CAAC,EAG7BD,EAAIC,GAAwBD,CAAC,EAGtBL,GAAkB,EAAGK,CAAC,CAC/B,CAeA,SAASC,GAAwBC,EAAW,CAC1C,IAAMC,EAASD,EAAU,WACrBE,EAAaF,EAGjB,GAAIA,EAAU,CAAC,IAAM,GAAKC,EAAS,KAAO,EACxCC,EAAaF,EAAU,MAAM,CAAC,UAGvBC,EAAS,KAAO,GAAI,CAC3B,IAAME,EAAU,IAAI,WAAW,CAAC,CAAC,CAAC,EAClCD,EAAa,IAAI,WAAWT,GAAkBU,EAASH,CAAS,CAAC,CACnE,CAGA,GAAIE,EAAW,WAAa,KAAO,EACjC,MAAM,IAAI,MAAM,kCAAkC,EAGpD,OAAOA,CACT,CAkBA,SAASL,GAAwBO,EAAO,CAEtC,GAAIA,EAAM,CAAC,IAAM,GACf,MAAM,IAAI,MAAM,gCAAgC,EAIlD,IAAMC,EAAiBD,EAAM,CAAC,EACxBR,EAAW,CAAC,EAGdU,EAAW,EACTC,EAAcD,EAAWD,EAG/B,KAAOC,EAAWC,GAAa,CAI7B,GAHYH,EAAME,CAAQ,IAGd,EACV,MAAM,IAAI,MAAM,kDAAkD,EAIpE,IAAME,EAAgBJ,EAAME,EAAW,CAAC,EAGlCG,EAAeL,EAAM,MAAME,EAAW,EAAGA,EAAW,EAAIE,CAAa,EAC3EZ,EAAS,KAAKa,CAAY,EAG1BH,GAAY,EAAIE,CAClB,CAEA,OAAOZ,CACT,CAIAJ,GAAO,QAAUE,KC9HjB,IAAAgB,EAAAC,EAAA,CAAAC,GAAAC,KAAA,CA6BA,SAASC,GAASC,EAAO,GAAIC,EAAY,CAEvC,GAAID,GAAQ,KACV,MAAO,GAGT,GAAI,CACF,IAAIE,EAGJ,GAAI,OAAO,OAAW,IAAa,CAGjC,IAAMC,EAAQ,OAAO,SAASH,CAAI,EAAIA,EAAO,OAAOA,CAAI,EAGxDE,EAAe,OAAO,KAAKC,EAAOF,CAAU,EAAE,SAAS,QAAQ,CACjE,KAAO,CAKL,IAAMG,EAAe,SAAS,mBAAmB,OAAOJ,CAAI,CAAC,CAAC,EAC9DE,EAAe,OAAO,KAAKE,CAAY,CACzC,CAIA,OAAOF,EAAa,QAAQ,MAAO,EAAE,CACvC,MAAgB,CAEd,MAAO,EACT,CACF,CAIAJ,GAAO,QAAUC,KClEjB,IAAAM,EAAAC,EAAA,CAAAC,GAAAC,KAAA,KAAMC,GAAW,IA+BjB,SAASC,GAAiBC,EAAQ,CAEhC,GAAI,EAAEA,aAAkB,aACtB,MAAO,GAKT,GAAI,OAAO,OAAW,IAGpB,OAAOF,GAAS,OAAO,KAAKE,CAAM,CAAC,EAIrC,IAAMC,EAAQ,IAAI,WAAWD,CAAM,EAC7BE,EAAa,KACbC,EAAS,CAAC,EAGhB,QAAS,EAAI,EAAG,EAAIF,EAAM,OAAQ,GAAKC,EAAY,CAEjD,IAAME,EAAQH,EAAM,SAAS,EAAG,EAAIC,CAAU,EAI9CC,EAAO,KAAK,OAAO,aAAa,MAAM,KAAMC,CAAK,CAAC,CACpD,CAGA,OAAON,GAASK,EAAO,KAAK,EAAE,CAAC,CACjC,CAIAN,GAAO,QAAUE,KClEjB,IAAAM,GAAAC,EAAA,CAAAC,GAAAC,KAAA,KAAMC,EAAmB,IAuBzB,SAASC,GAA0BC,EAAW,CAC5C,IAAMC,EAAKD,EAAU,GACfE,EAAQJ,EAAiBE,EAAU,KAAK,EACxCG,EAAOH,EAAU,KAGjBI,EAAW,CACf,sBAAuB,IAAI,YAAY,EAAE,OAAOJ,EAAU,SAAS,cAAc,EACjF,eAAgBF,EAAiBE,EAAU,SAAS,cAAc,EAClE,kBAAmBF,EAAiBE,EAAU,SAAS,iBAAiB,EACxE,UAAWF,EAAiBE,EAAU,SAAS,SAAS,EACxD,WAAYA,EAAU,SAAS,WAC3BF,EAAiBE,EAAU,SAAS,UAAU,EAC9C,EACN,EAGMK,EAAWC,GAA8BN,EAAU,SAAS,iBAAiB,EAEnF,MAAO,CACL,GAAAC,EACA,MAAAC,EACA,KAAAC,EACA,SAAAE,EACA,SAAAD,CACF,CACF,CAkBA,SAASE,GAA8BD,EAAU,CAE/C,GAAI,CAACA,GAAYA,EAAS,WAAa,GACrC,MAAM,IAAI,MACR,0BAA0BA,GAAU,YAAc,SAAS,oCAC7D,EAGF,IAAME,EAAW,IAAI,SAASF,EAAUA,EAAS,WAAYA,EAAS,MAAM,EACxEG,EAAU,EAGRC,EAAWJ,EAAS,MAAMG,EAASA,EAAU,EAAE,EACrDA,GAAW,GAGX,IAAME,EAAWL,EAAS,MAAMG,EAASA,EAAU,CAAC,EAC9CG,EAAW,IAAI,WAAWD,CAAQ,EAAE,CAAC,EAC3CF,GAAW,EAEX,IAAMI,EAAQ,CACZ,GAAI,CAAC,EAAED,EAAW,GAClB,GAAI,CAAC,EAAEA,EAAW,GAClB,GAAI,CAAC,EAAEA,EAAW,GAClB,GAAI,CAAC,EAAEA,EAAW,IAClB,GAAI,CAAC,EAAEA,EAAW,IAClB,GAAI,CAAC,EAAEA,EAAW,KAClB,SAAAA,CACF,EAGME,EAAaR,EAAS,MAAMG,EAASA,EAAU,CAAC,EAChDM,EAAUP,EAAS,UAAUC,EAAS,EAAK,EACjDA,GAAW,EAGX,IAAMO,EAAoBC,GAA4BJ,EAAOP,EAAUG,CAAO,EAC9EA,EAAUO,EAAkB,WAG5B,IAAME,EAAiBC,GAAmBN,EAAOP,EAAUG,CAAO,EAElE,MAAO,CACL,SAAUV,EAAiBW,CAAQ,EACnC,SAAUX,EAAiBY,CAAQ,EACnC,MAAAE,EACA,QAAAE,EACA,WAAYhB,EAAiBe,CAAU,EACvC,OAAQE,EAAkB,OAC1B,aAAcjB,EAAiBiB,EAAkB,YAAY,EAC7D,oBAAqBjB,EAAiBiB,EAAkB,mBAAmB,EAC3E,eAAAE,CACF,CACF,CAkBA,SAASD,GAA4BJ,EAAOP,EAAUG,EAAS,CAE7D,GAAI,CAACI,EAAM,GACT,MAAO,CACL,OAAQ,OACR,aAAc,OACd,oBAAqB,OACrB,WAAYJ,CACd,EAGF,IAAMD,EAAW,IAAI,SAASF,EAAUA,EAAS,WAAYA,EAAS,MAAM,EAGtEc,EAASd,EAAS,MAAMG,EAASA,EAAU,EAAE,EACnDA,GAAW,GAGX,IAAMY,EAAqBb,EAAS,UAAUC,EAAS,EAAK,EAC5DA,GAAW,EAGX,IAAMa,EAAehB,EAAS,MAAMG,EAASA,EAAUY,CAAkB,EACzEZ,GAAWY,EAKX,IAAME,EAAsBjB,EAAS,MAAMG,EAASA,EAAU,EAAE,EAChE,OAAAA,GAAW,GAEJ,CACL,OAAAW,EACA,aAAAE,EACA,oBAAAC,EACA,WAAYd,CACd,CACF,CAgBA,SAASU,GAAmBN,EAAOP,EAAUG,EAAS,CAEpD,GAAKI,EAAM,GAKX,OAAOP,EAAS,MAAMG,CAAO,CAC/B,CAIAX,GAAO,QAAUE,KC3MjB,IAAAwB,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAMA,IAAMC,GAAO,EAAQ,QAAQ,EACvBC,EAAmB,IAczB,SAASC,GAAuBC,EAAyB,CAEvD,IAAMC,EAAoBJ,GAAK,OAAO,IAAI,WAAWG,CAAuB,CAAC,EACvE,CAAE,SAAAE,CAAS,EAAID,EAafE,EAToB,EACA,GAEL,EAEK,EAKpBC,EAAgB,GAChBC,EAA6B,EAE7BC,EAA8BH,EAAkCC,EAChEG,EAAuBD,EAA8BD,EAIrDG,EAAaN,EAAS,MAC1BI,EACAC,CACF,EAEME,EADW,IAAI,SAASD,EAAW,MAAM,EACX,UAAU,CAAC,EAGzCE,EAAeR,EAAS,MAC5BK,EACAA,EAAuBE,CACzB,EACME,EAAiBT,EAAS,MAC9BK,EAAuBE,CACzB,EAGA,MAAO,CACL,aAAcX,EAAiBY,EAAa,MAAM,EAClD,gBAAiBZ,EAAiBa,EAAe,MAAM,CACzD,CACF,CAaA,SAASC,GAAwBC,EAAY,CAC3C,IAAMC,EAAWD,EAAW,SAGtBE,EAAiBhB,GAAuBe,EAAS,iBAAiB,EAGlEE,EAAwB,IAAI,YAAY,EAAE,OAC9CF,EAAS,cACX,EAIA,MAAO,CAEL,MAAOhB,EAAiBe,EAAW,KAAK,EACxC,GAAIA,EAAW,GACf,KAAMA,EAAW,KACjB,wBAAyBA,EAAW,wBACpC,uBAAwBA,EAAW,0BAA0B,EAG7D,SAAUE,EAGV,SAAU,CACR,kBAAmBjB,EAAiBgB,EAAS,iBAAiB,EAC9D,kBAAmBhB,EAAiBgB,EAAS,qBAAqB,CAAC,EACnE,eAAgBhB,EAAiBgB,EAAS,cAAc,EACxD,sBAAAE,EACA,WAAYF,EAAS,cAAc,GAAK,CAAC,EACzC,UAAWhB,EAAiBgB,EAAS,aAAa,CAAC,EACnD,mBAAoBA,EAAS,sBAAsB,CACrD,CACF,CACF,CAIAlB,GAAO,QAAUgB,KCvHjB,IAAAK,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAgBA,SAASC,GAA8BC,EAAO,CAE5C,GAAI,CAACA,EAAM,UACT,MAAM,IAAI,MAAM,uBAAuB,EAKzC,GACE,CAACA,EAAM,kBACP,CAAC,MAAM,QAAQA,EAAM,gBAAgB,GACrCA,EAAM,iBAAiB,SAAW,EAElC,MAAM,IAAI,MAAM,8BAA8B,EAIhD,QAAWC,KAAQD,EAAM,iBAAkB,CACzC,GAAI,CAACC,EAAK,GACR,MAAM,IAAI,MACR,4FACF,EAEF,GAAI,CAACA,EAAK,KACR,MAAM,IAAI,MAAM,qCAAqC,CAEzD,CACF,CAeA,eAAeC,GAAmCF,EAAOG,EAAU,CAGjE,GAAI,OAAO,WAAW,aAAa,KAAQ,WACzC,MAAO,yBAKTJ,GAA8BC,CAAK,EAKnC,IAAMI,EAAY,MAAM,UAAU,YAAY,IAAI,CAChD,UAAWJ,CACb,CAAC,EAID,OAAI,OAAOG,GAAa,WACfA,EAASC,CAAS,EAKpBA,CACT,CAIAN,GAAO,QAAUI,KCzFjB,IAAAG,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAeA,SAASC,GAAwBC,EAAO,CAEtC,GAAI,CAACA,EAAM,UACT,MAAM,IAAI,MAAM,uBAAuB,EAIzC,GAAI,CAACA,EAAM,GACT,MAAM,IAAI,MAAM,gCAAgC,EAElD,GAAI,CAACA,EAAM,GAAG,KACZ,MAAM,IAAI,MAAM,qCAAqC,EAIvD,GAAI,CAACA,EAAM,KACT,MAAM,IAAI,MAAM,kBAAkB,EAEpC,GAAI,CAACA,EAAM,KAAK,GACd,MAAM,IAAI,MAAM,qBAAqB,EAEvC,GAAI,CAACA,EAAM,KAAK,YACd,MAAM,IAAI,MAAM,+BAA+B,EAEjD,GAAI,CAACA,EAAM,KAAK,KACd,MAAM,IAAI,MAAM,uBAAuB,EAKzC,GACE,CAACA,EAAM,kBACP,CAAC,MAAM,QAAQA,EAAM,gBAAgB,GACrCA,EAAM,iBAAiB,SAAW,EAElC,MAAM,IAAI,MAAM,8BAA8B,EAIhD,QAAWC,KAASD,EAAM,iBAAkB,CAC1C,GAAI,CAACC,EAAM,eAAe,KAAK,EAC7B,MAAM,IAAI,MAAM,kCAAkC,EAEpD,GAAI,CAACA,EAAM,eAAe,MAAM,EAC9B,MAAM,IAAI,MAAM,mCAAmC,CAEvD,CACF,CAcA,eAAeC,GAAkCF,EAAQ,CAAC,EAAGG,EAAU,CAIrE,GAAI,OAAO,WAAW,aAAa,QAAW,WAC5C,MAAO,yBAMTJ,GAAwBC,CAAK,EAM7B,IAAMI,EAAa,MAAM,UAAU,YAAY,OAAO,CACpD,UAAWJ,CACb,CAAC,EAKD,OAAI,OAAOG,GAAa,WACfA,EAASC,CAAU,EAKrBA,CACT,CAOAN,GAAO,QAAUI,KClHjB,IAAAG,EAAAC,EAAA,CAAAC,GAAAC,KAAA,CA2BA,SAASC,GAAeC,EAAe,GAAI,CAEzC,GAAI,OAAOA,GAAiB,UAAYA,EAAa,SAAW,EAE9D,OAAO,IAAI,YAAY,CAAC,EAG1B,GAAI,CAEF,GAAI,OAAO,OAAW,IAAa,CAEjC,IAAMC,EAAa,OAAO,KAAKD,EAAc,QAAQ,EAKrD,OAAOC,EAAW,OAAO,MACvBA,EAAW,WACXA,EAAW,WAAaA,EAAW,UACrC,CACF,CAIA,IAAMC,EAAe,OAAO,KAAKF,CAAY,EACvCG,EAAMD,EAAa,OAGnBE,EAAQ,IAAI,WAAWD,CAAG,EAGhC,QAAS,EAAI,EAAG,EAAIA,EAAK,IACvBC,EAAM,CAAC,EAAIF,EAAa,WAAW,CAAC,EAItC,OAAOE,EAAM,MAEf,MAAgB,CAEd,OAAO,IAAI,YAAY,CAAC,CAC1B,CACF,CAIAN,GAAO,QAAUC,KCzEjB,IAAAM,EAAAC,EAAA,CAAAC,GAAAC,KAAA,CA2BA,SAASC,GAAcC,EAASC,EAAS,CAQvC,GANI,EAAED,aAAmB,cAAgB,EAAEC,aAAmB,cAM1DD,EAAQ,aAAeC,EAAQ,WACjC,MAAO,GAIT,GAAI,OAAO,OAAW,IAAa,CAGjC,IAAMC,EAAO,OAAO,KAAKF,CAAO,EAC1BG,EAAO,OAAO,KAAKF,CAAO,EAChC,OAAOC,EAAK,OAAOC,CAAI,CACzB,CAIA,IAAMC,EAAW,IAAI,YAAYJ,CAAO,EAClCK,EAAW,IAAI,YAAYJ,CAAO,EAGxC,QAASK,EAAI,EAAGA,EAAIF,EAAS,OAAQE,IACnC,GAAIF,EAASE,CAAC,IAAMD,EAASC,CAAC,EAC5B,MAAO,GAKX,IAAMC,EAAkBH,EAAS,OAAS,EAGpCI,EAAU,IAAI,WAAWR,CAAO,EAChCS,EAAU,IAAI,WAAWR,CAAO,EACtC,QAASK,EAAIC,EAAiBD,EAAIE,EAAQ,OAAQF,IAChD,GAAIE,EAAQF,CAAC,IAAMG,EAAQH,CAAC,EAC1B,MAAO,GAKX,MAAO,EACT,CAIAR,GAAO,QAAUC,KC9EjB,IAAAW,EAAAC,EAAA,CAAAC,GAAAC,KAAA,CAiCA,SAASC,GAAiBC,EAAWC,EAAW,QAAS,CAEvD,OAAI,OAAOD,GAAc,SAChB,KAIL,OAAO,OAAW,IAGb,OAAO,KAAKA,EAAWC,CAAQ,EAMjC,IAAI,YAAY,EAAE,OAAOD,CAAS,CAC3C,CAIAF,GAAO,QAAUC,KCtDjB,IAAAG,EAAAC,EAAA,CAAAC,GAAAC,KAAA,CA0CA,SAASC,IAAY,CAEnB,GAAI,OAAO,OAAW,IAAa,CAEjC,GAAI,CAAC,OAAO,OACV,MAAM,IAAI,MACR,+DACF,EAIF,OAAO,OAAO,MAChB,CAIA,MAAO,GAAQ,QAAQ,CACzB,CAKAD,GAAO,QAAUC,KChEjB,IAAAC,EAAAC,EAAA,CAAAC,GAAAC,KAAA,CAQA,IAAMC,GAAiB,IACjBC,GAAgB,IAChBC,GAAmB,IACnBC,GAAY,IAalB,eAAeC,GAAaC,EAAcC,EAAYC,EAAY,UAAW,CAG3E,GAAI,CAACF,GAAgB,OAAOA,GAAiB,SAC3C,MAAM,IAAI,MAAM,0BAA0B,EAG5C,GADAA,EAAeA,EAAa,KAAK,EAC7B,CAACA,EACH,MAAM,IAAI,MAAM,0BAA0B,EAG5C,GAAI,CAACC,GAAc,OAAOA,GAAe,SACvC,MAAM,IAAI,MAAM,wBAAwB,EAI1C,GADAA,EAAaA,EAAW,KAAK,EACzB,CAACA,EACH,MAAM,IAAI,MAAM,wBAAwB,EAK1C,IAAME,EAASL,GAAU,EAGnBM,EAAqBP,GAAiBG,CAAY,EAKlDK,EAAuB,MAAMF,EAAO,OAAO,OAC/CD,EACAE,CACF,EAOME,EAHmBX,GAAeM,CAAU,EAGV,MAAM,EAAG,EAAE,EAOnD,GAAI,CAFoBL,GAAcS,EAAsBC,CAAc,EAIxE,MAAM,IAAI,MACR,2DACF,EAIF,MAAO,EACT,CAOAZ,GAAO,QAAUK,KCvFjB,IAAAQ,EAAAC,EAAA,CAAAC,GAAAC,KAAA,KAAMC,GAAY,IA8GlB,eAAeC,GAAgBC,EAAWC,EAAKC,EAAWC,EAAM,CAO9D,OAAO,MALQL,GAAU,EAKL,OAAO,OAAOE,EAAWC,EAAKC,EAAWC,CAAI,CACnE,CAKAN,GAAO,QAAUE,KC3HjB,IAAAK,EAAAC,EAAA,CAAAC,GAAAC,KAAA,KAAMC,GAAY,IA4FlB,eAAeC,GAAgBC,EAAQC,EAASC,EAAWC,EAAaC,EAAW,CAMjF,OAAO,MAJQN,GAAU,EAIL,OAAO,UACzBE,EACAC,EACAC,EACAC,EACAC,CACF,CACF,CAKAP,GAAO,QAAUE,KC9GjB,IAAAM,EAAAC,EAAA,CAAAC,GAAAC,KAAA,CA2BA,SAASC,GAASC,EAAO,CAMvB,OAAO,OAAO,SAASA,CAAK,CAC9B,CAGAF,GAAO,QAAUC,KCrCjB,IAAAE,EAAAC,EAAA,CAAAC,GAAAC,KAAA,CA+BA,SAASC,GAAWC,EAAO,GAAI,CAE7B,GAAI,OAAOA,GAAS,UAAYA,EAAK,SAAW,EAC9C,MAAO,GAGT,GAAI,CAEF,GAAI,OAAO,OAAW,IAIpB,OAAO,OAAO,KAAKA,EAAM,QAAQ,EAAE,SAAS,OAAO,EAKrD,IAAMC,EAAe,OAAO,KAAKD,CAAI,EAG/BE,EAAQ,IAAI,WAAWD,EAAa,MAAM,EAChD,QAASE,EAAI,EAAGA,EAAIF,EAAa,OAAQE,IACvCD,EAAMC,CAAC,EAAIF,EAAa,WAAWE,CAAC,EAItC,OAAO,IAAI,OAAO,YAAY,EAAE,OAAOD,CAAK,CAC9C,MAAgB,CAId,MAAO,EACT,CACF,CAIAJ,GAAO,QAAUC,KCpEjB,IAAAK,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAMA,IAAMC,GAAkB,IAClBC,GAAkB,IAClBC,GAAe,IACfC,GAAW,IACXC,EAAiB,IACjBC,GAAa,IACbC,GAAoB,IACpBC,GAA4B,IAOlC,SAASC,GAA4BC,EAAoB,CACvD,OAAQA,EAAoB,CAC1B,IAAK,GACH,MAAO,CAAE,KAAM,QAAS,WAAY,OAAQ,EAC9C,IAAK,KACH,MAAO,CAAE,KAAM,oBAAqB,KAAM,CAAE,KAAM,SAAU,CAAE,EAChE,IAAK,GACH,MAAM,IAAI,MAAM,oDAAoD,EACtE,QACE,MAAM,IAAI,MAAM,0BAA0BA,CAAkB,EAAE,CAClE,CACF,CAMA,SAASC,GAAiCD,EAAoB,CAC5D,OAAQA,EAAoB,CAC1B,IAAK,GACH,MAAO,CAAE,KAAM,QAAS,KAAM,CAAE,KAAM,SAAU,CAAE,EACpD,IAAK,KACH,MAAO,CAAE,KAAM,oBAAqB,KAAM,CAAE,KAAM,SAAU,CAAE,EAChE,IAAK,GACH,MAAM,IAAI,MACR,qEACF,EACF,QACE,MAAM,IAAI,MAAM,0BAA0BA,CAAkB,EAAE,CAClE,CACF,CAOA,eAAeE,GAAqBC,EAAW,CAC7C,IAAMC,EAA0BT,EAC9BQ,EAAU,SAAS,iBACrB,EACME,EAAuBV,EAAeQ,EAAU,SAAS,cAAc,EACvEG,EAAqB,MAAM,OAAO,OAAO,OAC7C,UACAD,CACF,EAEA,OAAOR,GAAkBO,EAAyBE,CAAkB,CACtE,CAeA,eAAeC,GACbC,EACAL,EACAM,EAAgB,CAAC,EACjBC,EAAgB,CAAC,EACjBC,EAAiB,CAAC,EAClBC,EAAsB,GACtB,CAEA,GAAI,CAACJ,EACH,MAAM,IAAI,MAAM,oBAAoB,EAEtC,GAAI,CAACA,EAAW,GACd,MAAM,IAAI,MAAM,uBAAuB,EAEzC,GAAI,CAACA,EAAW,MACd,MAAM,IAAI,MAAM,0BAA0B,EAE5C,GAAIA,EAAW,OAAS,aACtB,MAAM,IAAI,MAAM,sCAAsC,EAGxD,GAAI,CAACL,EACH,MAAM,IAAI,MAAM,mBAAmB,EAErC,GAAI,CAACA,EAAU,GACb,MAAM,IAAI,MAAM,sBAAsB,EAExC,GAAI,CAACA,EAAU,MACb,MAAM,IAAI,MAAM,yBAAyB,EAE3C,GAAIA,EAAU,OAAS,aACrB,MAAM,IAAI,MAAM,qCAAqC,EAIvD,GAAIK,EAAW,KAAOL,EAAU,GAC9B,MAAM,IAAI,MAAM,2CAA2C,EAE7D,GAAIK,EAAW,QAAUL,EAAU,MACjC,MAAM,IAAI,MAAM,iDAAiD,EAInE,GAAM,CAAE,kBAAAU,CAAkB,EAAIJ,EACxB,CAAE,iBAAAK,CAAiB,EAAIJ,EAC7B,GAAI,CAAChB,GAASmB,CAAiB,GAAKA,EAAoB,EACtD,MAAM,IAAI,MAAM,yCAAyC,EAE3D,GAAI,CAACnB,GAASoB,CAAgB,GAAKA,EAAmB,EACpD,MAAM,IAAI,MAAM,wCAAwC,EAM1D,GAAIA,IAAqB,GACnBA,GAAoBD,EACtB,MAAM,IAAI,MACR,qDAAqDC,CAAgB,kEAAkED,CAAiB,IAC1J,EAKJ,IAAME,EAAiB,KAAK,MAAMZ,EAAU,SAAS,qBAAqB,EACpEa,EAAqBpB,GAAWmB,GAAgB,WAAa,EAAE,EACrE,GAAIN,EAAc,YAAcO,EAC9B,MAAM,IAAI,MAAM,wDAAwD,EAE1E,GAAIP,EAAc,SAAWM,GAAgB,OAC3C,MAAM,IAAI,MACR,oCAAoCN,EAAc,MAAM,YACtDM,GAAgB,QAAU,MAC5B,EACF,EAEF,GAAIN,EAAc,OAASM,GAAgB,KACzC,MAAM,IAAI,MACR,kCAAkCN,EAAc,IAAI,YAClDM,GAAgB,MAAQ,MAC1B,EACF,EAIF,GAAI,CAACZ,EAAU,SAAS,MAAM,GAC5B,MAAM,IAAI,MAAM,wDAAwD,EAE1E,GAAI,CAACA,EAAU,SAAS,MAAM,GAC5B,MAAM,IAAI,MAAM,yDAAyD,EAI3E,MAAMV,GAAagB,EAAc,KAAMN,EAAU,SAAS,QAAQ,EAGlE,IAAMc,EAAalB,GACjBS,EAAW,SAAS,kBACtB,EACMU,EAAajB,GACjBO,EAAW,SAAS,kBACtB,EAEMW,EAAY,MAAM3B,GACtBmB,GAAgB,WAAW,QAAU,OACrChB,EAAea,EAAW,SAAS,SAAS,EAC5CS,EACAN,GAAgB,WAAW,aAAe,GAC1C,CAAC,QAAQ,CACX,EAEIS,EAAY,IAAI,WAAWzB,EAAeQ,EAAU,SAAS,SAAS,CAAC,EAEvES,GAAuBJ,EAAW,SAAS,qBAAuB,KACpEY,EAAYtB,GAA0BsB,CAAS,GAGjD,IAAMC,EAAe,MAAMnB,GAAqBC,CAAS,EAEzD,OAAOZ,GAAgB2B,EAAYC,EAAWC,EAAWC,CAAY,CACvE,CAIA/B,GAAO,QAAUiB,KChNjB,IAAAe,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAMA,IAAMC,GAAiB,IACjBC,GAAO,EAAQ,QAAQ,EAoB7B,SAASC,GAAqBC,EAAYC,EAAgB,CAAC,EAAG,CAG5D,GAAI,CAACD,EACH,MAAM,IAAI,MAAM,oBAAoB,EAEtC,GAAI,CAACA,EAAW,GACd,MAAM,IAAI,MAAM,uBAAuB,EAEzC,GAAI,CAACA,EAAW,MACd,MAAM,IAAI,MAAM,0BAA0B,EAE5C,GAAI,CAACA,EAAW,MAAQA,EAAW,OAAS,aAC1C,MAAM,IAAI,MACR,8DACF,EAKF,IAAME,EAAiB,KAAK,MAAMF,EAAW,SAAS,qBAAqB,EAE3E,GAAIC,EAAc,YAAcC,GAAgB,UAC9C,MAAM,IAAI,MACR,iDACEA,GAAgB,WAAa,MAC/B,GACF,EAGF,GAAID,EAAc,SAAWC,GAAgB,OAC3C,MAAM,IAAI,MACR,oCAAoCD,EAAc,MAAM,YACtDC,GAAgB,QAAU,MAC5B,EACF,EAGF,GAAID,EAAc,OAASC,GAAgB,KACzC,MAAM,IAAI,MACR,kCAAkCD,EAAc,IAAI,YAClDC,GAAgB,MAAQ,MAC1B,EACF,EAKF,IAAMC,EAA0BN,GAC9BG,EAAW,SAAS,iBACtB,EAEMI,EAAoBN,GAAK,OAAO,IAAI,WAAWK,CAAuB,CAAC,EAE7E,GAAI,CAACC,EAAkB,IACrB,MAAM,IAAI,MAAM,mCAAmC,EAKrD,GAAIA,EAAkB,MAAQ,QAC5B,GAAIA,EAAkB,SAAWA,EAAkB,QAAQ,KAAO,EAChE,MAAM,IAAI,MAAM,uDAAuD,MAIzE,OAAM,IAAI,MAAM,mCAAmCA,EAAkB,GAAG,EAAE,EAI5E,MAAO,EACT,CAIAR,GAAO,QAAUG,KCtGjB,IAAAM,EAAAC,EAAA,CAAAC,GAAAC,KAAA,CAAAA,GAAO,QAAU,CACf,0BAA2B,IAC3B,0BAA2B,KAC3B,wBAAyB,KACzB,mCAAoC,KACpC,kCAAmC,KACnC,aAAc,IACd,uBAAwB,KACxB,qBAAsB,IACxB,ICTA,IAAAC,EAAAC,EAAA,CAAAC,GAAAC,KAAA,CAKAA,GAAO,QAAU,CAYf,mBAAoB,+BAMpB,gBAAiB,4BASjB,iBAAkB,aAMlB,kBAAmB,aAMnB,sBAAuB,sBAMvB,uBAAwB,sBAMxB,uBAAwB,UAMxB,wBAAyB,UASzB,kBAAmB,aAMnB,mBAAoB,aAMpB,uBAAwB,sBAMxB,wBAAyB,sBAMzB,wBAAyB,UAMzB,yBAA0B,UAU1B,wBAAyB,cAOzB,mBAAoB,qBAOpB,wBAAyB,aAMzB,kBAAmB,iBAMnB,yBAA0B,gBAM1B,kBAAmB,YAMnB,oBAAqB,mBAUrB,wBAAyB,0BAKzB,YACE,uJAKF,cACE,yEAOF,eAAgB,uBAUhB,iBAAkB,CAChB,GAAI,OACJ,GAAI,UACJ,GAAI,WACJ,GAAI,WACJ,GAAI,QACJ,GAAI,WACJ,GAAI,mBACJ,GAAI,oBACJ,GAAI,WACJ,GAAI,cACJ,GAAI,cACJ,GAAI,qBACJ,GAAI,eACJ,GAAI,UACJ,GAAI,aACJ,GAAI,YACJ,GAAI,aACJ,GAAI,WACJ,GAAI,iBACJ,GAAI,sBACJ,GAAI,oBACJ,GAAI,cACJ,GAAI,UACJ,GAAI,iBACJ,GAAI,eACJ,GAAI,UACJ,GAAI,WACN,EAOA,sBAAuB,CACrB,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,IACF,CACF,IC5PA,IAAAC,EAAAC,EAAA,CAAAC,GAAAC,KAAA,CAkCA,SAASC,GAAeC,EAAQC,EAAW,QAAS,CAElD,GAAID,GAAU,KACZ,MAAO,GAIT,GAAI,OAAO,OAAW,IAIpB,OAFmB,OAAO,SAASA,CAAM,EAAIA,EAAS,OAAO,KAAKA,CAAM,GAEtD,SAASC,CAAQ,EAIrC,GAAI,CAGF,OAAO,IAAI,YAAY,EAAE,OAAOD,CAAM,CACxC,MAAgB,CAEd,MAAO,EACT,CACF,CAIAF,GAAO,QAAUC,KC7DjB,IAAAG,GAAAC,EAAA,CAAAC,GAAAC,KAAA,KAAMC,GAAY,IACZC,GAAiB,IACjBC,GAAiB,IACjBC,GAAkB,IAoCxB,eAAeC,GAAQC,EAAYC,EAAkBC,EAAQ,CAAC,EAAG,CAE/D,GAAI,CAACD,EACH,MAAO,GAIT,GAAM,CACJ,OAAAE,EAAS,QACT,UAAAC,EAAY,CAAE,KAAM,WAAY,KAAM,CAAE,KAAM,SAAU,CAAE,EAC1D,YAAAC,EAAc,GACd,UAAAC,EAAY,CAAC,SAAS,EACtB,QAAAC,EAAU,UACZ,EAAIL,EAGEM,EAASb,GAAU,EAInBc,EAAoBT,EAAW,QACnC,4DACA,EACF,EACMU,EAAmBb,GAAeY,CAAiB,EAGnDE,EAAc,MAAMb,GACxBK,EACAO,EACAN,EACAC,EACAC,CACF,EAGMM,EAAgBf,GAAeI,CAAgB,EAG/CY,EAAkB,MAAML,EAAO,OAAO,QAC1C,CAAE,KAAMD,CAAQ,EAChBI,EACAC,CACF,EAGA,OAAOhB,GAAeiB,CAAe,CACvC,CAIAnB,GAAO,QAAUK,KC1FjB,IAAAe,GAAAC,EAAA,CAAAC,GAAAC,KAAA,KAAMC,GAAY,IACZC,GAAmB,IACnBC,GAAmB,IACnBC,GAAkB,IAClBC,GAAiB,IAmHvB,eAAeC,GAAQC,EAAWC,EAASC,EAAQ,CAAC,EAAG,CAErD,GAAI,CAACD,EAAS,MAAO,GAGrB,IAAME,EAAST,GAAU,EAInBU,EAAmBJ,EAAU,QACjC,0DACA,EACF,EACMK,EAAkBP,GAAeM,CAAgB,EAIjDE,EAAc,MAAMT,GACxBK,EAAM,QAAU,OAChBG,EACAH,EAAM,WAAa,CACjB,KAAM,WACN,KAAM,CAAE,KAAM,SAAU,CAC1B,EACAA,EAAM,cAAgB,OAAYA,EAAM,YAAc,GACtDA,EAAM,WAAa,CAAC,SAAS,CAC/B,EAGMK,EAAgBZ,GAAiBM,CAAO,EAIxCO,EAAkB,MAAML,EAAO,OAAO,QAC1C,CAAE,KAAMD,EAAM,SAAW,UAAW,EACpCI,EACAC,CACF,EAGA,OAAOX,GAAiBY,CAAe,CACzC,CAKAf,GAAO,QAAUM,KCrKjB,IAAAU,GAAAC,EAAA,CAAAC,GAAAC,KAAA,KAAMC,GAAY,IAmClB,eAAeC,GAAOC,EAAWC,EAAM,CAErC,IAAMC,EAAa,OAAOD,GAAS,SAC/B,IAAI,YAAY,EAAE,OAAOA,CAAI,EAC7BA,EAGEE,EAASL,GAAU,EAGzB,GAAI,OAAO,OAAW,IAAa,CACjC,IAAMM,EAAa,MAAMD,EAAO,OAAO,OAAOH,EAAWE,CAAU,EACnE,OAAO,IAAI,WAAWE,CAAU,CAClC,CAIA,IAAMC,EAAgBL,EAAU,YAAY,EAAE,QAAQ,IAAK,EAAE,EACvDM,EAAOH,EAAO,WAAWE,CAAa,EAAE,OAAOH,CAAU,EAAE,OAAO,EAGxE,OAAO,IAAI,WAAWI,CAAI,CAC5B,CAIAT,GAAO,QAAUE,KC7DjB,IAAAQ,EAAAC,EAAA,CAAAC,GAAAC,KAAA,CAAAA,GAAO,QAAU,CACf,UAAW,IACX,QAAS,KACT,QAAS,KACT,OAAQ,KACR,gBAAiB,IACjB,gBAAiB,GACnB,ICPA,IAAAC,EAAAC,EAAA,CAAAC,GAAAC,KAAA,CA6BA,SAASC,GAAaC,EAAQC,EAAc,CAG1C,OAAOD,aAAkBC,CAC3B,CAGAH,GAAO,QAAUC,KCpCjB,IAAAG,EAAAC,EAAA,CAAAC,GAAAC,KAAA,IAAM,CAAE,gBAAAC,EAAgB,EAAI,IACtB,CAAE,MAAAC,EAAM,EAAI,EAAQ,gBAAgB,EACpCC,GAAe,IAwBrB,SAASC,GACPC,EACAC,EAAeL,GACfM,EAAc,IAAI,KAClB,CACA,IAAIC,EAGJ,GAAI,OAAOH,GAAe,SAAU,CAClC,IAAMI,EAAaP,GAAMG,EAAYC,EAAc,IAAI,IAAM,EAGzDH,GAAaM,EAAY,IAAI,GAAK,CAAC,MAAMA,EAAW,QAAQ,CAAC,EAC/DD,EAAgBC,EAGhBD,EAAgBD,CAEpB,MAEEC,EAAgBD,EASlB,GALIC,GAAiB,MAKjB,CAACL,GAAaK,EAAe,IAAI,GAAK,MAAMA,EAAc,QAAQ,CAAC,EAEnE,MAAO,GAKX,IAAME,EAAuBF,EAAc,kBAAkB,EAAI,GAAK,IACtE,OAAO,IAAI,KAAKA,EAAc,QAAQ,EAAIE,CAAoB,CAChE,CAIAV,GAAO,QAAUI,KCpEjB,IAAAO,EAAAC,EAAA,CAAAC,GAAAC,KAAA,KAAMC,GAAe,IA+BrB,SAASC,GAAmBC,EAAM,CAGhC,GAAI,CAACF,GAAaE,EAAM,IAAI,GAAK,MAAMA,EAAK,QAAQ,CAAC,EAEnD,MAAO,GAIT,IAAMC,EAAU,IAAI,KAAKD,EAAK,QAAQ,CAAC,EAIvC,OAAAC,EAAQ,SAAS,EAAG,EAAG,EAAG,CAAC,EAEpBA,CACT,CAIAJ,GAAO,QAAUE,KCnDjB,IAAAG,EAAAC,EAAA,CAAAC,GAAAC,KAAA,KAAMC,GAAe,IAmCrB,SAASC,GAAkBC,EAAM,CAG/B,GAAI,CAACF,GAAaE,EAAM,IAAI,GAAK,MAAMA,EAAK,QAAQ,CAAC,EACnD,MAAO,GAIT,IAAMC,EAAU,IAAI,KAAKD,EAAK,QAAQ,CAAC,EAIvC,OAAAC,EAAQ,SAAS,GAAI,GAAI,GAAI,GAAG,EAEzBA,CACT,CAIAJ,GAAO,QAAUE,KCtDjB,IAAAG,EAAAC,EAAA,CAAAC,GAAAC,KAAA,CAMA,GAAM,CAAE,iBAAAC,EAAiB,EAAI,IACvBC,GAAe,IACfC,GAAqB,IACrBC,GAAoB,IAyC1B,SAASC,GACPC,EACAC,EAAaN,GACbO,EAAM,aACNC,EAAY,mBACZC,EAAW,kBACXC,EAAW,GACX,CAGA,GAAI,CAACL,GAAW,CAACA,EAAOI,CAAQ,GAAK,CAACJ,EAAOG,CAAS,EACpD,OAAO,KAGT,IAAMG,EAAa,CAAC,EAGpB,GAAIN,EAAOI,CAAQ,EAAG,CAEpB,IAAMG,EAAWX,GAAaI,EAAOI,CAAQ,EAAGH,CAAU,EAGpDO,EAAYH,EAAWR,GAAmBU,CAAQ,EAAIA,EAE5DD,EAAW,KAAK,CAAE,KAAME,CAAU,CAAC,EAGnC,OAAOR,EAAOI,CAAQ,CACxB,CAGA,GAAIJ,EAAOG,CAAS,EAAG,CACrB,IAAMM,EAAYb,GAAaI,EAAOG,CAAS,EAAGF,CAAU,EAGtDO,EAAYH,EAAWP,GAAkBW,CAAS,EAAIA,EAE5DH,EAAW,KAAK,CAAE,KAAME,CAAU,CAAC,EAGnC,OAAOR,EAAOG,CAAS,CACzB,CAGA,OAAAH,EAAOE,CAAG,EAAI,CACZ,KAAMI,CACR,EAGON,CACT,CAGAN,GAAO,QAAUK,KCvGjB,IAAAW,EAAAC,EAAA,CAAAC,GAAAC,KAAA,CAmCA,SAASC,GACPC,EACAC,EAAM,QACNC,EAAY,cACZC,EAAW,aACX,CAIA,GAAI,CAACH,GAAW,CAACA,EAAOG,CAAQ,GAAK,CAACH,EAAOE,CAAS,EACpD,OAGF,IAAME,EAAa,CAAC,EAGpB,OAAIJ,EAAOG,CAAQ,GACjBC,EAAW,KAAK,CAAE,KAAMJ,EAAOG,CAAQ,CAAE,CAAC,EAIxCH,EAAOE,CAAS,GAClBE,EAAW,KAAK,CAAE,KAAMJ,EAAOE,CAAS,CAAE,CAAC,EAI7CF,EAAOC,CAAG,EAAI,CACZ,KAAMG,CACR,EAGOJ,CACT,CAGAF,GAAO,QAAUC,KCtEjB,IAAAM,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CA+BA,SAASC,GAAuBC,EAAQC,EAAKC,EAAc,GAAM,CAG/D,GAAI,CAACF,GAAU,CAACC,GAAO,CAACD,EAAOC,CAAG,EAChC,OAIF,IAAME,EAAWD,EAAc,SAAW,QAGpCE,EAAQJ,EAAOC,CAAG,EAIxBD,EAAOC,CAAG,EAAI,CACZ,CAACE,CAAQ,EAAG,IAAIC,CAAK,GACvB,CACF,CAGAN,GAAO,QAAUC,KCpDjB,IAAAM,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAWA,IAAMC,GAAN,KAAiB,CAMf,aAAc,CAMZ,KAAK,UAAY,IAAI,GACvB,CAQA,IAAI,UAAW,CACb,OAAO,OAAO,YAAY,KAAK,SAAS,CAC1C,CAaA,WAAWC,EAAMC,EAAe,GAAMC,EAAa,CACjD,GAAI,CACF,IAAMC,EAAW,KAAK,UAAU,IAAIH,CAAI,EACxC,GAAI,CAACG,EACH,MAAO,GAGLF,EACFE,EAAS,QAAQD,CAAW,EAE5BC,EAAS,OAAOD,CAAW,CAE/B,OAASE,EAAO,CACd,OAAOA,CACT,QAAE,CAEA,KAAK,UAAU,OAAOJ,CAAI,CAC5B,CACF,CAWA,UAAUA,EAAM,CACd,GAAI,KAAK,UAAU,IAAIA,CAAI,EACzB,OAGF,IAAIK,EAASC,EACPC,EAAU,IAAI,QAAQ,CAACC,EAAKC,IAAQ,CACxCJ,EAAUG,EACVF,EAASG,CACX,CAAC,EAED,YAAK,UAAU,IAAIT,EAAM,CAAE,QAAAO,EAAS,QAAAF,EAAS,OAAAC,CAAO,CAAC,EAE9CC,CACT,CAUA,UAAUN,EAAcC,EAAa,CAGnC,IAAMQ,EAAc,MAAM,KAAK,KAAK,UAAU,KAAK,CAAC,EAEpD,QAAWC,KAAOD,EAChB,KAAK,WAAWC,EAAKV,EAAcC,CAAW,CAElD,CAGF,EAQMU,GAAK,IAAIb,GAIfD,GAAO,QAAUc,KC3HjB,IAAAC,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CA6BA,SAASC,GAAeC,EAAYC,EAAc,CAChD,IAAMC,EAAM,OAAOF,CAAU,EAC7B,OAAO,OAAO,SAASE,CAAG,GAAK,CAAC,MAAMA,CAAG,EAAIA,EAAMD,CACrD,CAGAH,GAAO,QAAUC,KCnCjB,IAAAI,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAMA,IAAMC,EAAiB,KA0CjBC,GAAN,KAAoB,CAElBC,GAAU,CAAC,EAEXC,GAEAC,GAEAC,GAEAC,GAAiB,EAEjBC,GAAY,GAEZC,GAEAC,GAEAC,GAEAC,GAEAC,GAEAC,GAEAC,GAYA,YAAYC,EAAO,CAAC,EAAGC,EAAO,CAAC,EAAGC,EAAO,CAAC,EAAG,CAC3C,IAAIC,EAKJ,GAAI,OAAO,KAAKF,CAAI,EAAE,OAAS,GAAK,OAAO,KAAKC,CAAI,EAAE,OAAS,EAAG,CAChE,IAAME,GAAUJ,EACVK,EAAoBJ,EACpBK,EAAeJ,EACrBC,EAAU,CACR,GAAGG,EACH,QAASA,EAAa,SAAWF,GACjC,MAAOE,EAAa,OAASD,EAAkB,cAC/C,QAASC,EAAa,SAAWD,EAAkB,gBACnD,MAAOC,EAAa,OAASD,EAAkB,aACjD,CACF,MACEF,EAAUH,EAIZ,GAAM,CACJ,MAAOO,EAAY,IACnB,cAAAC,EACA,qBAAAC,EAAuB,EACvB,eAAAC,EAAiB,IACjB,QAAAC,EAAU,EACV,aAAAC,EAAe,IACf,OAAAC,EAAS,CACP,KAAM,IAAM,CAAC,EACb,MAAO,IAAM,CAAC,EACd,KAAM,IAAM,CAAC,EACb,MAAO,IAAM,CAAC,CAChB,EACA,QAAAT,EAAU,CAAC,EACX,eAAAU,EAAiB,KACjB,QAAAC,EACA,MAAAC,EACA,MAAAC,EACA,eAAAC,EACA,eAAAC,CACF,EAAIhB,EAKJ,KAAKf,GAAS,KAAK,IAAIH,EAAesB,EAAW,CAAC,EAAG,CAAC,EAEtD,KAAKlB,GAAiB,KAAK,IACzB,KAAKD,GAAS,EACdH,EAAeuB,EAAe,CAAC,CACjC,EAEA,KAAKlB,GAAwB,KAAK,IAChC,EACAL,EAAewB,EAAsB,CAAC,CACxC,EAEA,KAAKb,GAAW,KAAK,IAAI,EAAGX,EAAe0B,EAAS,CAAC,CAAC,EAEtD,KAAKd,GAAgB,KAAK,IAAI,IAAKZ,EAAe2B,EAAc,GAAI,CAAC,EAErE,KAAKd,GAAkB,KAAK,IAAI,IAAKb,EAAeyB,EAAgB,GAAK,CAAC,EAG1E,KAAKjB,GAAUoB,EACf,KAAKnB,GAAWU,EAChB,KAAKT,GAAkBmB,EACvB,KAAKf,GAAa,CAAE,QAAAgB,EAAS,MAAAC,EAAO,MAAAC,EAAO,eAAAC,EAAgB,eAAAC,CAAe,EAG1E,KAAK1B,GAAQ,KAAK,8BAA+B,CAC/C,MAAO,KAAKL,GACZ,cAAe,KAAKC,GACpB,qBAAsB,KAAKC,GAC3B,QAAS,KAAKM,GACd,aAAc,KAAKC,GACnB,eAAgB,KAAKC,EACvB,CAAC,CACH,CAeA,MAAM,IAAIsB,EAAM,CAEd,GAAI,KAAK5B,GAAW,CAClB,KAAKC,GAAQ,KACX,oFACA,CAAE,KAAA2B,CAAK,CACT,EACA,MACF,CAIA,GAAI,KAAKjC,GAAQ,QAAU,KAAKE,GAkB9B,IAfI,KAAKU,GAAW,gBAClB,QAAQ,QACN,KAAKA,GAAW,eAAe,CAC7B,WAAY,KAAKZ,GAAQ,OACzB,cAAe,KAAKE,GACpB,KAAA+B,CACF,CAAC,CACH,EAAE,MAAOC,GAAU,CACjB,KAAK5B,GAAQ,MAAM,mCAAoC,CACrD,aAAc4B,EAAM,OACtB,CAAC,CACH,CAAC,EAII,KAAKlC,GAAQ,QAAU,KAAKE,IAGjC,MAAM,IAAI,QAASiC,GAAY,WAAWA,EAAS,EAAE,CAAC,EAQ1D,GAHA,KAAKnC,GAAQ,KAAKiC,CAAI,EAGlB,KAAKrB,GAAW,MAClB,GAAI,CAEF,QAAQ,QACN,KAAKA,GAAW,MAAM,CACpB,OAAQ,KAAKZ,GACb,QAAS,KAAKO,GACd,KAAA0B,EACA,eAAgB,KAAKzB,GACrB,OAAQ,KAAKF,EACf,CAAC,CACH,EAAE,MAAO4B,GAAU,CACjB,KAAK5B,GAAQ,MAAM,yCAAuC,CACxD,aAAc4B,EAAM,OACtB,CAAC,CACH,CAAC,CACH,OAASE,EAAW,CAElB,KAAK9B,GAAQ,MAAM,sCAAoC,CACrD,aAAc8B,EAAU,OAC1B,CAAC,CACH,CAIE,KAAKpC,GAAQ,QAAU,KAAKC,IAC9B,KAAK,MAAM,CAEf,CAYA,OAAQ,CAGN,KACE,KAAKD,GAAQ,OAAS,GACtB,KAAKI,GAAiB,KAAKD,IAC3B,CACA,IAAMkC,EAAQ,KAAKrC,GAAQ,OAAO,EAAG,KAAKC,EAAM,EAGhD,KAAKqC,GAAcD,CAAK,CAC1B,CACF,CAiBA,KAAMC,GAAcD,EAAO,CAEzB,KAAKjC,KACL,KAAKE,GAAQ,KACX,uCAAuC+B,EAAM,MAAM,mBACjD,KAAKjC,EACP,EACF,EAEA,IAAImC,EAAY,KAGhB,QAASC,EAAU,EAAGA,GAAW,KAAK/B,GAAU+B,IAC9C,GAAI,CAEF,GAAI,CAAC,KAAK5B,GAAW,QAAS,CAC5B,KAAKN,GAAQ,KACX,6CAA6C+B,EAAM,MAAM,oBAC3D,EACAE,EAAY,KACZ,KACF,CAEIC,EAAU,GACZ,KAAKlC,GAAQ,KACX,aAAakC,CAAO,IAAI,KAAK/B,EAAQ,eACvC,EAIF,IAAIgC,EACEC,EAAiB,IAAI,QAAQ,CAACC,EAAGC,IAAW,CAChDH,EAAY,WACV,IACEG,EACE,IAAI,MAAM,yBAAyB,KAAKjC,EAAe,IAAI,CAC7D,EACF,KAAKA,EACP,CACF,CAAC,EAED,GAAI,CACF,MAAM,QAAQ,KAAK,CACjB,KAAKC,GAAW,QAAQ,CACtB,MAAAyB,EACA,QAAS,KAAK9B,GACd,eAAgB,KAAKC,GACrB,OAAQ,KAAKF,EACf,CAAC,EACDoC,CACF,CAAC,CACH,QAAE,CAGA,aAAaD,CAAS,CACxB,CAGA,KAAKnC,GAAQ,KACX,WAAW+B,EAAM,MAAM,gCACzB,EACAE,EAAY,KACZ,KACF,OAASL,EAAO,CAEdK,EAAYL,EAERM,GAAW,KAAK/B,GAElB,KAAKH,GAAQ,MACX,gDAA6CkC,CAAO,iBACpD,CACE,aAAcN,EAAM,QACpB,UAAWG,EAAM,MACnB,CACF,GAGA,KAAK/B,GAAQ,KACX,sBAAsBkC,CAAO,+CAC3B,KAAK9B,EACP,QACA,CACE,aAAcwB,EAAM,OACtB,CACF,EACA,MAAM,IAAI,QAASC,GACjB,WAAWA,EAAS,KAAKzB,EAAa,CACxC,EAEJ,CAOF,GAAI6B,GAAa,KAAK3B,GAAW,eAC/B,GAAI,CACF,MAAM,KAAKA,GAAW,eAAe,CACnC,MAAAyB,EACA,MAAOE,EACP,QAAS,KAAKhC,GACd,eAAgB,KAAKC,GACrB,OAAQ,KAAKF,EACf,CAAC,EACD,KAAKA,GAAQ,KACX,0DACF,CACF,OAASuC,EAAsB,CAE7B,KAAKvC,GAAQ,MAAM,yDAAoD,CACrE,aAAcuC,EAAqB,OACrC,CAAC,CACH,CAMF,KAAKzC,KACL,KAAKE,GAAQ,KACX,6CAA6C,KAAKF,EAAc,EAClE,EAGA,KAAK,MAAM,CACb,CAaA,MAAM,IAAI0C,EAAiB,IAAO,CAEhC,GAAI,KAAKzC,GACP,OAGF,KAAKA,GAAY,GACjB,IAAM0C,EAAe,KAAK,IAAI,EAQ9B,GANA,KAAKzC,GAAQ,KAAK,+BAAgC,CAChD,cAAe,KAAKN,GAAQ,OAC5B,cAAe,KAAKI,EACtB,CAAC,EAGG,KAAKQ,GAAW,MAClB,GAAI,CACF,MAAM,KAAKA,GAAW,MAAM,CAE5B,CAAC,CACH,OAASsB,EAAO,CACd,KAAK5B,GAAQ,MAAM,0BAA2B,CAC5C,aAAc4B,EAAM,OACtB,CAAC,CACH,CAQF,IAJA,KAAK,MAAM,GAKR,KAAKlC,GAAQ,OAAS,GAAK,KAAKI,GAAiB,IAClD,KAAK,IAAI,EAAI2C,EAAeD,GAE5B,MAAM,IAAI,QAASX,GAAY,WAAWA,EAAS,EAAE,CAAC,GAIpD,KAAKnC,GAAQ,OAAS,GAAK,KAAKI,GAAiB,IACnD,KAAKE,GAAQ,KACX,wFACA,CACE,eAAgB,KAAKN,GAAQ,OAC7B,cAAe,KAAKI,EACtB,CACF,EAGF,KAAKE,GAAQ,KAAK,yBAAyB,CAC7C,CACF,EAMAT,GAAO,QAAUE,KCzejB,IAAAiD,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAsBA,SAASC,GAAeC,EAAOC,EAAOC,EAAU,CAAC,EAAG,CAElD,IAAMC,EAAe,CACnB,YAAa,GACb,aAAc,GACd,eAAgB,GAChB,GAAGD,CACL,EAEA,GAAI,EAAEF,aAAiB,OAAS,EAAEC,aAAiB,MAAO,CACxD,GAAIE,EAAa,aACf,OAAO,KAGT,IAAMC,EAAcJ,aAAiB,KAAkB,QAAV,QAC7C,MAAM,IAAI,UACR,4BAA4BI,CAAS,gCACvC,CACF,CAKA,GAAI,CACF,IAAIC,EACAC,EAGJ,OAAKH,EAAa,aAYhBE,EAAQL,EAAM,QAAQ,EACtBM,EAAQL,EAAM,QAAQ,IAZtBI,EAAQ,IAAI,KACVL,EAAM,YAAY,EAClBA,EAAM,SAAS,EACfA,EAAM,QAAQ,CAChB,EAAE,QAAQ,EACVM,EAAQ,IAAI,KACVL,EAAM,YAAY,EAClBA,EAAM,SAAS,EACfA,EAAM,QAAQ,CAChB,EAAE,QAAQ,GASLI,EAAQC,GAAUD,IAAUC,GAASH,EAAa,cAC3D,OAASI,EAAO,CACd,GAAIJ,EAAa,aACf,OAAO,KAGT,MAAMI,CACR,CACF,CAGAT,GAAO,QAAUC,KChFjB,IAAAS,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAsBA,SAASC,GAAgBC,EAAOC,EAAOC,EAAU,CAAC,EAAG,CAEnD,IAAMC,EAAe,CACnB,YAAa,GACb,aAAc,GACd,eAAgB,GAChB,GAAGD,CACL,EAGA,GAAI,EAAEF,aAAiB,MAAO,CAC5B,GAAIG,EAAa,aACf,OAAO,KAET,MAAM,IAAI,MACR,+DACF,CACF,CAGA,GAAI,EAAEF,aAAiB,MAAO,CAC5B,GAAIE,EAAa,aACf,OAAO,KAET,MAAM,IAAI,MACR,+DACF,CACF,CAGA,GAAI,CACF,IAAIC,EACAC,EAGJ,OAAKF,EAAa,aAYhBC,EAAQJ,EAAM,QAAQ,EACtBK,EAAQJ,EAAM,QAAQ,IAZtBG,EAAQ,IAAI,KACVJ,EAAM,YAAY,EAClBA,EAAM,SAAS,EACfA,EAAM,QAAQ,CAChB,EAAE,QAAQ,EACVK,EAAQ,IAAI,KACVJ,EAAM,YAAY,EAClBA,EAAM,SAAS,EACfA,EAAM,QAAQ,CAChB,EAAE,QAAQ,GASLG,EAAQC,GAAUD,IAAUC,GAASF,EAAa,cAC3D,OAASG,EAAO,CACd,GAAIH,EAAa,aACf,OAAO,KAGT,MAAMG,CACR,CACF,CAGAR,GAAO,QAAUC,KCvFjB,IAAAQ,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CA6BA,SAASC,GAAaC,EAAYD,EAAc,CAG9C,OAAOC,GAAcD,CACvB,CAGAD,GAAO,QAAUC,KCpCjB,IAAAE,EAAAC,EAAA,CAAAC,GAAAC,KAAA,CA6BA,SAASC,GAASC,EAAQ,CAGxB,OAAOA,IAAW,MAAQ,OAAOA,GAAW,QAC9C,CAGAF,GAAO,QAAUC,KCpCjB,IAAAE,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAAAA,GAAO,QAAU,CACf,eAAgB,KAChB,gBAAiB,KACjB,eAAgB,KAChB,aAAc,KACd,aAAc,IACd,SAAU,IACV,SAAU,GACZ,ICRA,IAAAC,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAiBA,SAASC,EAAUC,EAAQC,EAAM,IAAI,QAAW,CAE9C,GAAID,IAAW,MAAQ,OAAOA,GAAW,SACvC,OAAOA,EAKT,GAAIC,EAAI,IAAID,CAAM,EAChB,OAAOC,EAAI,IAAID,CAAM,EAIvB,GAAI,MAAM,QAAQA,CAAM,EAAG,CACzB,IAAME,EAAQ,CAAC,EAGfD,EAAI,IAAID,EAAQE,CAAK,EACrB,QAAS,EAAI,EAAG,EAAIF,EAAO,OAAQ,IACjCE,EAAM,CAAC,EAAIH,EAAUC,EAAO,CAAC,EAAGC,CAAG,EAErC,OAAOC,CACT,CAGA,IAAMA,EAAQ,CAAC,EAGfD,EAAI,IAAID,EAAQE,CAAK,EACrB,QAAWC,KAAOH,EAEZ,OAAO,UAAU,eAAe,KAAKA,EAAQG,CAAG,IAClDD,EAAMC,CAAG,EAAIJ,EAAUC,EAAOG,CAAG,EAAGF,CAAG,GAI3C,OAAOC,CACT,CAwCA,SAASE,GAAOC,EAAS,CAAC,EAAGL,EAAS,CAAC,EAAGM,EAAc,GAAM,CAG5D,GAAID,IAAW,MAAQ,OAAOA,GAAW,SAAU,CACjD,GAAIC,EACF,MAAM,IAAI,UAAU,uDAAuD,EAE7E,OAAO,IACT,CAEA,GAAIN,IAAW,MAAQ,OAAOA,GAAW,SAAU,CACjD,GAAIM,EACF,MAAM,IAAI,UAAU,uDAAuD,EAE7E,OAAO,IACT,CAEA,GAAI,CAGF,IAAMC,EAAeR,EAAUM,CAAM,EAC/BG,EAAeT,EAAUC,CAAM,EAKrC,OAAO,OAAO,OAAOO,EAAcC,CAAY,CACjD,OAASC,EAAO,CACd,GAAIH,EAEF,MAAMG,EAGR,OAAO,IACT,CACF,CAKAX,GAAO,QAAUM,KCtIjB,IAAAM,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAiCA,SAASC,GAAwBC,EAAgB,GAAI,CAEnD,GAAI,OAAOA,GAAkB,UAAYA,EAAc,SAAW,EAChE,MAAO,GAKT,IAAMC,EAASD,EAAc,QAAQ,KAAM,GAAG,EAAE,QAAQ,KAAM,GAAG,EAK3DE,GAAmB,EAAKD,EAAO,OAAS,GAAM,EACpD,OAAOA,EAAO,OAAOA,EAAO,OAASC,EAAiB,GAAG,CAC3D,CAIAJ,GAAO,QAAUC,KCpDjB,IAAAI,EAAAC,EAAA,CAAAC,GAAAC,KAAA,CA8BA,SAASC,GAASC,EAAU,GAAIC,EAAe,GAAM,CAEnD,GAAID,GAAW,KACb,MAAO,GAKT,IAAME,EAAgB,OAAOF,CAAO,EAIpC,GACEC,GACAC,IAAkB,mBAClB,OAAOF,GAAY,SAEnB,GAAI,CAEF,OAAO,KAAK,UAAUA,CAAO,CAC/B,MAAgB,CAEd,OAAOE,CACT,CAKF,OAAOA,CACT,CAIAJ,GAAO,QAAUC,KC/DjB,IAAAI,GAAAC,EAAA,CAAAC,GAAAC,KAAA,KAAMC,GAAW,IACXC,GAAW,IAkCjB,SAASC,GAAgBC,EAAO,GAAIC,EAAa,OAAQ,CAOvD,OAJuBH,GAASD,GAASG,CAAI,EAAGC,CAAU,EAIpC,QAAQ,MAAO,GAAG,EAAE,QAAQ,MAAO,GAAG,CAC9D,CAIAL,GAAO,QAAUG,KC/CjB,IAAAG,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAgCA,SAASC,GAAuBC,EAASC,EAAM,GAAM,CAGnD,GAAI,OAAOD,GAAY,UAAY,CAAC,SAASA,CAAO,EAClD,OAAO,KAIT,IAAME,EAAuBF,EAAU,IAIvC,OAAIC,EACK,KAAK,IAAI,EAAIC,EAGf,KAAK,IAAI,EAAIA,CACtB,CAIAJ,GAAO,QAAUC,KCrDjB,IAAAI,GAAAC,EAAA,CAAAC,GAAAC,KAAA,KAAMC,GAAW,IACXC,GAAW,IA6BjB,SAASC,GAAkBC,EAAY,CAGrC,GAAIA,GAAc,KAChB,MAAO,GAIT,GAAIF,GAASE,CAAU,EACrB,OAAOA,EAIT,IAAMC,EAAgBJ,GAASG,CAAU,EAEtC,QAAQ,aAAc,EAAE,EAExB,QAAQ,IAAK,GAAG,EAWnB,GALI,UAAU,KAAKC,CAAa,GAK5BA,IAAkB,IAAMA,IAAkB,IAC5C,MAAO,GAIT,IAAMC,EAAS,WAAWD,CAAa,EAGvC,OAAIH,GAASI,CAAM,EACVA,EAIF,EACT,CAIAN,GAAO,QAAUG,KC5EjB,IAAAI,GAAAC,EAAA,CAAAC,GAAAC,KAAA,IAAM,CAAE,iBAAAC,EAAiB,EAAI,IACvB,CAAE,OAAAC,EAAO,EAAI,EAAQ,iBAAiB,EACtCC,GAAe,IA+BrB,SAASC,GAAaC,EAAMC,EAAeL,GAAkB,CAG3D,MAAI,CAACE,GAAaE,EAAM,IAAI,GAAK,MAAMA,EAAK,QAAQ,CAAC,EAE5C,GAKFH,GAAOG,EAAMC,CAAY,CAClC,CAIAN,GAAO,QAAUI,KChDjB,IAAAG,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAyCA,SAASC,GAAUC,EAAUC,EAAU,IAAM,CAE3C,GAAI,OAAOD,GAAa,WACtB,MAAM,IAAI,UAAU,kEAA4D,EAElF,GAAI,OAAOC,GAAY,SACrB,MAAM,IAAI,UAAU,+CAA4C,EAIlE,IAAIC,EAIJ,OAAO,YAAYC,EAAM,CAEvB,IAAMC,EAAU,KAIhB,aAAaF,CAAK,EAGlBA,EAAQ,WAAW,IAAM,CAEvBF,EAAS,MAAMI,EAASD,CAAI,CAC9B,EAAGF,CAAO,CACZ,CACF,CAIAH,GAAO,QAAUC,KCzEjB,IAAAM,GAAAC,EAAA,CAAAC,GAAAC,KAAA,KAAMC,GAAW,IAuCjB,SAASC,GAAWC,EAAS,CAAC,EAAGC,EAAO,CAAC,EAAG,CAE1C,GAAI,CAACH,GAASE,CAAM,EAClB,OAAOA,EAET,GAAI,CAAC,MAAM,QAAQC,CAAI,EAErB,MAAO,CAAE,GAAGD,CAAO,EAIrB,IAAME,EAAY,CAAE,GAAGF,CAAO,EAG9B,QAAWG,KAAOF,EAChB,OAAOC,EAAUC,CAAG,EAItB,OAAOD,CACT,CAIAL,GAAO,QAAUE,KC/DjB,IAAAK,GAAAC,EAAA,CAAAC,GAAAC,KAAA,KAAMC,GAAW,IAqCjB,SAASC,GAAiBC,EAAIC,EAAY,IAAK,CAG7C,IAAMC,EAAc,IAAI,WAAW,CAAC,EACpC,WAAW,OAAO,gBAAgBA,CAAW,EAG7C,IAAMC,EAAY,MAAM,KAAKD,CAAW,EACrC,IAAIE,GAAQA,EAAK,SAAS,EAAE,EAAE,SAAS,EAAG,GAAG,CAAC,EAC9C,KAAK,EAAE,EAGJC,EAAQ,CAAC,EACTC,EAAWR,GAASE,CAAE,EAG5B,OAAIM,GACFD,EAAM,KAAKC,CAAQ,EAIrBD,EAAM,KAAK,KAAK,IAAI,CAAC,EACrBA,EAAM,KAAKF,CAAS,EAGbE,EAAM,KAAKJ,CAAS,CAC7B,CAIAJ,GAAO,QAAUE,KCnEjB,IAAAQ,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAOA,IAAMC,EAAY,CAChB,UAAW,6BACX,UAAW,6BACX,SAAU,uFACV,OAAQ,aACR,QAAS,qBACX,EAwBA,SAASC,GAAqBC,EAAO,GAAIC,EAAU,CAAC,EAAG,CAWrD,IAAMC,EAAe,CAAE,GARA,CACrB,sBAAuB,GACvB,sBAAuB,GACvB,qBAAsB,GACtB,cAAe,GACf,eAAgB,GAChB,eAAgB,EAClB,EAC0C,GAAGD,CAAQ,EAGjDE,EAAaD,EAAa,eAQ9B,GAPKA,EAAa,wBAAuBC,GAAcL,EAAU,WAC5DI,EAAa,wBAAuBC,GAAcL,EAAU,WAC5DI,EAAa,uBAAsBC,GAAcL,EAAU,UAC3DI,EAAa,gBAAeC,GAAcL,EAAU,QACpDI,EAAa,iBAAgBC,GAAcL,EAAU,SAGtDK,EAAW,SAAW,GAAKH,GAAQ,EACrC,MAAO,GAIT,IAAMI,EAAe,IAAI,YAAYJ,CAAI,EAGzC,WAAW,OAAO,gBAAgBI,CAAY,EAE9C,IAAIC,EAAS,CAAC,EACd,QAASC,EAAI,EAAGA,EAAIN,EAAMM,IAAK,CAE7B,IAAMC,EAAcH,EAAaE,CAAC,EAAIH,EAAW,OACjDE,EAAO,KAAKF,EAAWI,CAAW,CAAC,CACrC,CAEA,OAAOF,EAAO,KAAK,EAAE,CACvB,CAIAR,GAAO,QAAUE,KCjFjB,IAAAS,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAmCA,SAASC,GAAiBC,EAAM,CAE9B,GAAI,OAAO,QAAY,KAAe,OAAO,QAAQ,QAAW,WAAY,CAE1E,GAAIA,IAAS,OACX,OAAO,QAAQ,OAAO,OAAO,EAI/B,GAAI,OAAOA,GAAS,SAChB,MAAO,QAIX,IAAMC,EAAY,QAAQ,OAAO,OAAO,EAAID,EAG5C,OADmB,OAAOC,CAAS,EAAI,KACrB,QAAQ,CAAC,CAC7B,CAGA,OAAI,OAAO,YAAgB,KAAe,OAAO,YAAY,KAAQ,WAE/DD,IAAS,OACJ,YAAY,IAAI,EAIrB,OAAOA,GAAS,UAAY,CAAC,SAASA,CAAI,EACrC,SAIU,YAAY,IAAI,EAAIA,GACrB,QAAQ,CAAC,EAKrB,KAAK,IAAI,EAAG,QAAQ,CAAC,CAC/B,CAIAF,GAAO,QAAUC,KC/EjB,IAAAG,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CA2CA,SAASC,GAASC,EAAMC,EAAc,GAAM,CAE1C,GAAI,OAAOD,GAAS,SAAU,CAC5B,GAAIC,EACF,MAAM,IAAI,UAAU,8CAA8C,EAEpE,OAAO,IACT,CAEA,GAAI,CAEF,OAAO,KAAK,MAAMD,CAAI,CACxB,OAASE,EAAO,CAEd,GAAID,EAEF,MAAMC,EAIR,OAAO,IACT,CACF,CAIAJ,GAAO,QAAUC,KCrEjB,IAAAI,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CA6CA,SAASC,GAAOC,EAAS,CAAC,EAAGC,EAAc,GAAM,CAC/C,GAAI,CAEF,OAAO,KAAK,UAAUD,CAAM,CAC9B,OAASE,EAAO,CAEd,GAAID,EAEF,MAAMC,EAIR,OAAO,IACT,CACF,CAIAJ,GAAO,QAAUC,KC/DjB,IAAAI,GAAAC,EAAA,CAAAC,GAAAC,KAAA,IAAM,CAAE,QAAAC,EAAQ,EAAI,IACdC,GAAW,IAoBjB,eAAeC,GAAuBC,EAAWC,EAASC,EAAQ,CAAC,EAAG,CAGpE,IAAMC,EAAYL,GAASG,CAAO,EAE5BG,EAAYF,EAAM,WAAa,IAC/BG,EAAS,CAAC,EAGhB,QAASC,EAAI,EAAGA,EAAIH,EAAU,OAAQG,GAAKF,EACzCC,EAAO,KAAKF,EAAU,UAAUG,EAAGA,EAAIF,CAAS,CAAC,EAInD,IAAMG,EAAqBF,EAAO,IAAIG,GACpCX,GAAQG,EAAWQ,EAAON,CAAK,CACjC,EAGA,OAAO,QAAQ,IAAIK,CAAkB,CACvC,CAIAX,GAAO,QAAUG,KC7CjB,IAAAU,GAAAC,EAAA,CAAAC,GAAAC,KAAA,IAAM,CAAE,QAAAC,EAAQ,EAAI,IACdC,GAAa,IAkBnB,eAAeC,GAAyBC,EAAYC,EAAeC,EAAQ,CAAC,EAAG,CAE7E,IAAMC,EAAqBF,EAAc,IAAIG,GAC3CP,GAAQG,EAAYI,EAAOF,CAAK,CAClC,EAMMG,GAHkB,MAAM,QAAQ,IAAIF,CAAkB,GAGxB,KAAK,EAAE,EAG3C,OAAOL,GAAWO,CAAW,CAC/B,CAIAT,GAAO,QAAUG,KCrCjB,IAAAO,GAAAC,EAAA,CAAAC,GAAAC,KAAA,KAAMC,GAAW,IAmCjB,SAASC,GAAUC,EAAO,GAAI,CAE5B,OAAIF,GAASE,CAAI,GAAK,OAAOA,GAAS,SAK7B,OAAOA,CAAI,EACf,UAAU,KAAK,EACf,QAAQ,mBAAoB,EAAE,EAI5BA,CACT,CAIAH,GAAO,QAAUE,KCrDjB,IAAAE,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAqCA,SAASC,GAASC,EAAcC,EAAY,CAE1C,OACED,IAAiB,MACjB,OAAOA,GAAiB,UACxB,MAAM,QAAQA,CAAY,EAEnB,CAAC,EAEL,MAAM,QAAQC,CAAU,EAKtBA,EAAW,OAAO,CAACC,EAAQC,KAG5B,OAAO,UAAU,eAAe,KAAKH,EAAcG,CAAG,IACxDD,EAAOC,CAAG,EAAIH,EAAaG,CAAG,GAEzBD,GACN,CAAC,CAAC,EAXI,CAAC,CAYZ,CAGAJ,GAAO,QAAUC,KC9DjB,IAAAK,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CA2CA,SAASC,GAAeC,EAAQC,EAASC,EAAW,CAG7C,MAAM,QAAQF,CAAM,IACvBA,EAAS,CAAC,GAIZ,IAAMG,EAAW,CACf,KAAM,IAAI,KAAK,EAAE,YAAY,EAC7B,QAAAF,CACF,EAGA,OAAIC,IAAc,SAChBC,EAAS,UAAYD,GAIvBF,EAAO,KAAKG,CAAQ,EAGbH,CACT,CAIAF,GAAO,QAAUC,KCtEjB,IAAAK,GAAAC,EAAA,CAAAC,GAAAC,KAAA,KAAMC,GAAW,IAkCjB,SAASC,GAAgBC,EAAO,GAAI,CAOlC,OALoBF,GAASE,CAAI,EAKd,QAAQ,UAAW,EAAE,CAC1C,CAIAH,GAAO,QAAUE,KC9CjB,IAAAE,GAAAC,EAAA,CAAAC,GAAAC,KAAA,KAAMC,GAAW,IAuCjB,SAASC,GACPC,EAAO,GACPC,EAAQ,sBACRC,EAAc,GACdC,EAAO,GACP,CAEA,IAAMC,EAAcN,GAASE,CAAI,EAC3BK,EAAeP,GAASG,CAAK,EAC7BK,EAAmBR,GAASI,CAAW,EAIvCK,EAAc,IAAI,OAAO,KAAKF,CAAY,IAAK,GAAG,EAGpDG,EAASJ,EAAY,QAAQG,EAAaD,CAAgB,EAG9D,OAAIH,IACFK,EAASA,EAAO,KAAK,GAGhBA,CACT,CAIAX,GAAO,QAAUE,KCnEjB,IAAAU,GAAAC,EAAA,CAAAC,GAAAC,KAAA,KAAMC,GAAW,IAgCjB,SAASC,GAAiBC,EAAO,GAAI,CAOnC,OALoBF,GAASE,CAAI,EAKd,QAAQ,gBAAiB,EAAE,CAChD,CAIAH,GAAO,QAAUE,KC5CjB,IAAAE,GAAAC,EAAA,CAAAC,GAAAC,KAAA,KAAMC,GAAW,IACXC,GAAW,IAsCjB,SAASC,GACPC,EACAC,EAAc,IACdC,EAAkB,GAClB,CAEA,GAAIJ,GAASE,CAAI,EACf,MAAO,GAIT,IAAMG,EAAYN,GAASI,CAAW,EAChCG,EAAQP,GAASG,CAAI,EACxB,KAAK,EACL,MAAMG,CAAS,EACf,OAAOE,GAAKA,CAAC,EAGhB,GAAKH,EAGE,CAEL,IAAMI,EAAc,CAAC,EAErBF,EAAM,QAAQ,CAACG,EAAMC,IAAU,CAC7BF,EAAYC,EAAK,YAAY,CAAC,EAAIC,CACpC,CAAC,EAGD,IAAMC,EAAgB,IAAI,IAAI,OAAO,OAAOH,CAAW,CAAC,EAIxD,OAAOF,EACJ,OAAO,CAACM,EAAOF,IAAUC,EAAc,IAAID,CAAK,CAAC,EACjD,KAAKL,CAAS,CACnB,KAjBE,OAAO,CAAC,GAAG,IAAI,IAAIC,CAAK,CAAC,EAAE,KAAKD,CAAS,CAkB7C,CAIAP,GAAO,QAAUG,KCjFjB,IAAAY,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAuCA,SAASC,GAAMC,EAAcC,EAAc,GAAMC,EAAa,GAAO,CAEnE,GAAI,OAAOF,GAAiB,UAAYA,EAAe,EAAG,CACxD,IAAMG,EAAQ,IAAI,UAAU,yEAAmE,EAC/F,OAAO,QAAQ,OAAOA,CAAK,CAC7B,CAGA,OAAO,IAAI,QAAQ,CAACC,EAASC,IAAW,CACtC,WAAW,IAELH,EAIOG,EADLJ,IAAgB,GACJ,IAAI,MAAM,aAAa,EAGzBA,CAH0B,EAOnCG,EAAQH,CAAW,EACzBD,CAAY,CACjB,CAAC,CACH,CAIAF,GAAO,QAAUC,KCpEjB,IAAAO,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAiCA,SAASC,GAAMC,EAAMC,EAAO,IAAK,CAG/B,MAAI,CAACD,GAAQ,OAAOA,GAAS,SACpB,CAAC,EAIHA,EAAK,MAAMC,CAAI,CACxB,CAIAH,GAAO,QAAUC,KC9CjB,IAAAG,GAAAC,EAAA,CAAAC,GAAAC,KAAA,IAAM,CAAE,aAAAC,GAAc,QAAAC,EAAQ,EAAI,EAAQ,QAAQ,EAyClD,SAASC,GAAeC,EAAMC,EAAU,CAAC,EAAG,CAG1C,IAAMC,EAAe,CACnB,WAAY,SACZ,MAAO,EACP,IAAK,EACL,GAAGD,CACL,EAGA,GAAI,OAAOD,GAAS,UAAYA,EAAK,SAAW,EAE9C,OAAOE,EAAa,aAAe,SAAW,IAAI,WAAe,GAKnE,IAAMC,EAAcL,GAAQE,CAAI,EAG1BI,EAAmBP,GAAaM,EAAa,CACjD,MAAOD,EAAa,MACpB,IAAKA,EAAa,GACpB,CAAC,EAGD,GAAIA,EAAa,aAAe,SAC9B,OAAOE,EAKT,GAAI,OAAO,OAAW,KAAe,OAAO,OAAO,MAAS,WAG1D,OAAO,OAAO,KAAKA,CAAgB,EAAE,SAAS,QAAQ,EACjD,CAGL,IAAIC,EAAS,GACPC,EAAMF,EAAiB,WAC7B,QAASG,EAAI,EAAGA,EAAID,EAAKC,IACvBF,GAAU,OAAO,aAAaD,EAAiBG,CAAC,CAAC,EAEnD,OAAO,KAAKF,CAAM,CACpB,CACF,CAIAT,GAAO,QAAUG,KC5FjB,IAAAS,GAAAC,EAAA,CAAAC,GAAAC,KAAA,IAAM,CAAE,eAAAC,GAAgB,UAAAC,EAAU,EAAI,EAAQ,QAAQ,EAwCtD,SAASC,GAAiBC,EAAgBC,EAAU,CAAC,EAAG,CAEtD,IAAMC,EAAe,CACnB,UAAW,SACX,GAAGD,CACL,EAGA,GAAI,CAACD,EACH,MAAO,GAGT,GAAI,CACF,IAAIG,EAGJ,GAAID,EAAa,YAAc,SAAU,CAEvC,GAAI,OAAOF,GAAmB,SAC5B,MAAO,GAIT,GAAI,OAAO,OAAW,KAAe,OAAO,OAAO,MAAS,WAG1DG,EAAc,OAAO,KAAKH,EAAgB,QAAQ,MAC7C,CAGL,IAAMI,EAAe,KAAKJ,CAAc,EAClCK,EAAMD,EAAa,OACnBE,EAAQ,IAAI,WAAWD,CAAG,EAChC,QAASE,EAAI,EAAGA,EAAIF,EAAKE,IACvBD,EAAMC,CAAC,EAAIH,EAAa,WAAWG,CAAC,EAEtCJ,EAAcG,CAChB,CACF,MAEEH,EAAcH,EAIhB,GAAI,CAACG,GAAeA,EAAY,aAAe,EAC7C,MAAO,GAIT,IAAMK,EAAqBX,GAAeM,CAAW,EAGrD,OAAOL,GAAUU,CAAkB,CACrC,MAAgB,CAEd,MAAO,EACT,CACF,CAIAZ,GAAO,QAAUG,KCrGjB,IAAAU,GAAAC,EAAA,CAAAC,GAAAC,KAAA,IAAM,CAAE,gBAAAC,GAAiB,sBAAAC,EAAsB,EAAI,IAC7CC,GAAe,IACfC,GAAe,KA0BrB,SAASC,GACPC,EACAC,EAAaN,GACbO,EAAWN,GACX,CACA,GAAI,CAGF,IAAMO,EAAaN,GAAaG,EAAYC,EAAY,EAAK,EAE7D,GAAIE,EAAY,CAKd,IAAMC,EAAuBD,EAAW,kBAAkB,EAAI,GAAK,IAC7DE,EAAY,IAAI,KAAKF,EAAW,QAAQ,EAAIC,CAAoB,EAGtE,OAAON,GAAaO,EAAWH,CAAQ,CACzC,CACF,MAAY,CAAC,CAEb,MAAO,EACT,CAIAR,GAAO,QAAUK,KCxDjB,IAAAO,GAAAC,EAAA,CAAAC,GAAAC,KAAA,KAAMC,GAAW,IACXC,GAAkB,KAClB,CAAE,mBAAAC,EAAmB,EAAI,IAsC/B,SAASC,GACPC,EACAC,EAAUH,GACVI,EAAU,CAAC,EACX,CAEA,IAAMC,EAAe,CACnB,WAAY,GACZ,YAAa,IACb,GAAGD,CACL,EAEIE,EAAgBR,GAASI,CAAI,EAG7BG,EAAa,aACfC,EAAgBP,GAAgBO,CAAa,GAI/C,IAAMC,GAAgBJ,EAAQ,MAAM,IAAI,GAAK,CAAC,GAAG,OACjD,GAAII,IAAiB,EACjB,OAAOJ,EAIXG,EAAgBA,EAAc,MAAM,EAAGC,CAAY,EAAE,SAASA,EAAcF,EAAa,WAAW,EAKpG,IAAIG,EAAY,EAChB,OAAOL,EAAQ,QAAQ,KAAM,IAAMG,EAAcE,GAAW,CAAC,CAC/D,CAIAX,GAAO,QAAUI,KC7EjB,IAAAQ,GAAAC,EAAA,CAAAC,GAAAC,KAAA,IAAM,CAAE,SAAAC,GAAU,QAAAC,EAAQ,EAAI,EAAQ,QAAQ,EAwC9C,SAASC,GAAmBC,EAAMC,EAAU,CAAC,EAAG,CAE9C,IAAMC,EAAe,CACnB,WAAY,SACZ,MAAO,EACP,IAAK,EACL,GAAGD,CACL,EAGA,GAAI,OAAOD,GAAS,UAAYA,EAAK,SAAW,EAE9C,OAAOE,EAAa,aAAe,SAAW,IAAI,WAAe,GAInE,IAAMC,EAAcL,GAAQE,CAAI,EAG1BI,EAAmBP,GAASM,EAAa,CAC7C,MAAOD,EAAa,MACpB,IAAKA,EAAa,GACpB,CAAC,EAGD,GAAIA,EAAa,aAAe,SAC9B,OAAOE,EAIT,GAAI,OAAO,OAAW,KAAe,OAAO,OAAO,MAAS,WAG1D,OAAO,OAAO,KAAKA,CAAgB,EAAE,SAAS,QAAQ,EACjD,CAGL,IAAIC,EAAS,GACPC,EAAMF,EAAiB,WAC7B,QAASG,EAAI,EAAGA,EAAID,EAAKC,IACvBF,GAAU,OAAO,aAAaD,EAAiBG,CAAC,CAAC,EAEnD,OAAO,KAAKF,CAAM,CACpB,CACF,CAIAT,GAAO,QAAUG,KCxFjB,IAAAS,GAAAC,EAAA,CAAAC,GAAAC,KAAA,IAAM,CAAE,WAAAC,GAAY,UAAAC,EAAU,EAAI,EAAQ,QAAQ,EAwClD,SAASC,GAAqBC,EAAgBC,EAAU,CAAC,EAAG,CAE1D,IAAMC,EAAe,CACnB,UAAW,SACX,GAAGD,CACL,EAGA,GAAI,CAACD,EACH,MAAO,GAGT,GAAI,CACF,IAAIG,EAGJ,GAAID,EAAa,YAAc,SAAU,CACvC,GAAI,OAAOF,GAAmB,SAC5B,MAAO,GAIT,GAAI,OAAO,OAAW,KAAe,OAAO,OAAO,MAAS,WAE1DG,EAAc,OAAO,KAAKH,EAAgB,QAAQ,MAC7C,CAEL,IAAMI,EAAe,KAAKJ,CAAc,EAClCK,EAAMD,EAAa,OACnBE,EAAQ,IAAI,WAAWD,CAAG,EAChC,QAASE,EAAI,EAAGA,EAAIF,EAAKE,IACvBD,EAAMC,CAAC,EAAIH,EAAa,WAAWG,CAAC,EAEtCJ,EAAcG,CAChB,CACF,MAEEH,EAAcH,EAGhB,GAAI,CAACG,GAAeA,EAAY,aAAe,EAC7C,MAAO,GAIT,IAAMK,EAAqBX,GAAWM,CAAW,EAGjD,OAAOL,GAAUU,CAAkB,CACrC,MAAgB,CAEd,MAAO,EACT,CACF,CAIAZ,GAAO,QAAUG,KCjGjB,IAAAU,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAgDA,SAASC,GAASC,EAAUC,EAAM,CAEhC,GAAI,OAAOD,GAAa,WACtB,MAAM,IAAI,UAAU,iEAA2D,EAEjF,GAAI,OAAOC,GAAS,UAAYA,EAAO,EACrC,MAAM,IAAI,UAAU,6EAAuE,EAI7F,IAAIC,EAAa,GAGjB,OAAO,YAAYC,EAAM,CAEnBD,IAMJF,EAAS,MAAM,KAAMG,CAAI,EAGzBD,EAAa,GAIb,WAAW,IAAM,CACfA,EAAa,EACf,EAAGD,CAAI,EACT,CACF,CAIAH,GAAO,QAAUC,KCpFjB,IAAAK,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAsCA,SAASC,GAAUC,EAAS,mBAAoB,CAC9C,IAAMC,EAAM,IAAI,KAKVC,EAAS,CAEb,EAAG,IAAMD,EAAI,YAAY,EAEzB,GAAI,IAAM,OAAOA,EAAI,SAAS,EAAI,CAAC,EAAE,SAAS,EAAG,GAAG,EAEpD,EAAG,IAAM,OAAOA,EAAI,QAAQ,CAAC,EAAE,SAAS,EAAG,GAAG,EAE9C,EAAG,IAAM,OAAOA,EAAI,SAAS,CAAC,EAAE,SAAS,EAAG,GAAG,EAE/C,GAAI,IAAM,OAAOA,EAAI,WAAW,CAAC,EAAE,SAAS,EAAG,GAAG,EAElD,EAAG,IAAM,OAAOA,EAAI,WAAW,CAAC,EAAE,SAAS,EAAG,GAAG,EAEjD,GAAI,IAAM,OAAOA,EAAI,gBAAgB,CAAC,EAAE,SAAS,EAAG,GAAG,CACzD,EAMA,OAAOD,EAAO,QAAQ,oBAAsBG,GAAUD,EAAOC,CAAK,EAAE,CAAC,CACvE,CAIAL,GAAO,QAAUC,KCtEjB,IAAAK,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CA+BA,SAASC,GAAqBC,EAAO,GAAIC,EAAU,CAEjD,GAAI,OAAOD,GAAS,SAElB,OAAOC,IAAa,OAAY,GAAK,IAAI,WAG3C,IAAIC,EAaJ,OAVI,OAAO,OAAW,IAEpBA,EAAa,OAAO,KAAKF,EAAM,OAAO,EAItCE,EAAa,IAAI,YAAY,EAAE,OAAOF,CAAI,EAIxCC,IAAa,OAGR,MAAM,KAAKC,CAAU,EAAE,KAAKD,CAAQ,EAItCC,CACT,CAIAJ,GAAO,QAAUC,KC/DjB,IAAAI,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CA+BA,SAASC,GAAmBC,EAAYC,EAAW,CAEjD,GAAID,GAAc,KAChB,MAAO,GAGT,IAAIE,EAAeF,EAGnB,GAAIC,IAAc,QAAa,OAAOD,GAAe,SAAU,CAE7D,IAAMG,EAAQH,EAAW,MAAMC,CAAS,EAAE,IAAIG,GAAK,SAASA,EAAE,KAAK,EAAG,EAAE,CAAC,EAEzEF,EAAe,IAAI,WAAWC,CAAK,CACrC,CAIA,GAAI,CAEF,OAAI,OAAO,OAAW,KACD,OAAO,SAASD,CAAY,EAAIA,EAAe,OAAO,KAAKA,CAAY,GACxE,SAAS,OAAO,EAI7B,IAAI,YAAY,EAAE,OAAOA,CAAY,CAC9C,MAAgB,CAEd,MAAO,EACT,CACF,CAIAJ,GAAO,QAAUC,KClEjB,IAAAM,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAAAA,GAAO,QAAU,CACf,OAAQ,KACR,WAAY,IACZ,wBAAyB,KACzB,iBAAkB,IAClB,SAAU,IACV,eAAgB,IAChB,gBAAiB,KACjB,cAAe,IACf,kBAAmB,IACnB,iBAAkB,IAClB,eAAgB,IAChB,uBAAwB,KACxB,kBAAmB,KACnB,aAAc,KACd,mBAAoB,IACpB,kBAAmB,IACnB,UAAW,KACX,WAAY,KACZ,iBAAkB,KAClB,qBAAsB,KACtB,iBAAkB,KAClB,SAAU,KACV,OAAQ,KACR,uBAAwB,KACxB,yBAA0B,KAC1B,UAAW,KACX,SAAU,KACV,eAAgB,KAChB,gBAAiB,KACjB,iBAAkB,KAClB,iBAAkB,KAClB,wBAAyB,KACzB,MAAO,KACP,MAAO,KACP,eAAgB,KAChB,iBAAkB,KAClB,aAAc,IACd,qBAAsB,KACtB,eAAgB,KAChB,mBAAoB,KACpB,qBAAsB,KACtB,SAAU,KACV,UAAW,KACX,SAAU,IACV,qBAAsB,KACtB,mBAAoB,IACtB,IC/CA,IAAAC,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAcA,SAASC,GAAwBC,EAAQC,EAAS,CAOhD,IAAMC,EAJMF,EACT,MAAM,EAAE,EACR,OAAO,CAACG,EAAKC,EAAOC,IAAUF,EAAO,OAAOC,CAAK,EAAIH,EAAQI,CAAK,EAAI,CAAC,EAElD,GAIxB,OAAQH,GAAa,EAAK,EAAI,GAAKA,CACrC,CAiBA,SAASI,GAAkBC,EAAS,CAGlC,IAAMC,EAAa,OAAOD,CAAO,EAAE,QAAQ,SAAU,EAAE,EAGjDE,EAAiB,GAKvB,GAAID,IAAe,IAAMA,EAAW,OAASC,EAC3C,MAAO,GAIT,IAAMC,EAAgBF,EAAW,SAASC,EAAgB,GAAG,EAKvDE,EAAc,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EACrCC,EAAmBF,EAAc,UAAU,EAAG,CAAC,EAC/CG,EAAwBd,GAAwBa,EAAkBD,CAAW,EAI7EG,EAAgB,OAAOJ,EAAc,CAAC,CAAC,EAC7C,GAAIG,IAA0BC,EAC5B,MAAO,GAMT,IAAMC,EAAc,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EACxCC,EAAkBN,EAAc,UAAU,EAAG,CAAC,EAC9CO,EAAyBlB,GAAwBiB,EAAiBD,CAAW,EAG7EG,EAAiB,OAAOR,EAAc,CAAC,CAAC,EAG9C,OAAOO,IAA2BC,CACpC,CAMApB,GAAO,QAAUQ,KC7FjB,IAAAa,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAiBA,SAASC,GAAYC,EAAM,GAAI,CAE7B,OADmB,OAAOA,CAAG,EAAE,QAAQ,SAAU,EAAE,EACjC,SAAW,CAC/B,CAGAF,GAAO,QAAUC,KCvBjB,IAAAE,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAUA,IAAMC,GAAkB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EAW9D,SAASC,GAAcC,EAAM,CAE3B,OAAOA,EAAK,WAAW,CAAC,EAAI,EAC9B,CAUA,SAASC,GAAyBC,EAAUC,EAAS,CAMnD,IAAMC,EAAYC,GAAQ,CACxB,IAAMC,EAAYD,EAAM,GACxB,OAAOC,EAAY,EAAI,EAAI,GAAKA,CAClC,EAEIC,EAAO,EACPC,EAAO,EAEX,QAASC,EAAI,EAAGA,EAAIP,EAAS,OAAQO,IAAK,CAExC,IAAMC,EAAQX,GAAcG,EAASO,CAAC,CAAC,EACvCF,GAAQG,EAAQP,EAAQM,EAAI,CAAC,EAC7BD,GAAQE,EAAQP,EAAQM,CAAC,CAC3B,CAEA,IAAME,EAAMP,EAASG,CAAI,EACzBC,GAAQG,EAAMR,EAAQD,EAAS,MAAM,EACrC,IAAMU,EAAMR,EAASI,CAAI,EAEzB,MAAO,GAAGG,CAAG,GAAGC,CAAG,EACrB,CAiBA,SAASC,GAAaC,EAAO,GAAIC,EAAU,CAAC,EAAG,CAE7C,IAAIC,EAAgB,OAAOF,CAAI,EAAE,QAAQ,SAAU,EAAE,EAE/CG,EAAe,CACnB,eAAgB,IAChB,QAASnB,GACT,cAAe,GACf,kBAAmB,GACnB,GAAGiB,CACL,EAoBA,GAjBIE,EAAa,oBAAsB,KACrCD,EAAgBA,EAAc,YAAY,GAGvCC,EAAa,gBAChBD,EAAgBA,EAAc,SAAS,GAAIC,EAAa,cAAc,GAOpE,CADc,yBACH,KAAKD,CAAa,GAK7B,QAAQ,KAAKA,CAAa,GAAK,eAAe,KAAKA,CAAa,EAClE,MAAO,GAIT,IAAME,EAAaF,EAAc,UAAU,EAAG,EAAE,EAC1CG,EAAiBH,EAAc,UAAU,EAAE,EAE3CI,EAA2BnB,GAAyBiB,EAAYD,EAAa,OAAO,EAE1F,OAAOE,IAAmBC,CAC5B,CAKAvB,GAAO,QAAUgB,KC3HjB,IAAAQ,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAaA,SAASC,GAAwBC,EAAY,CAE3C,IAAMC,EAAgBD,EAAW,OAAS,EAOpCE,EAJMF,EACT,MAAM,EAAE,EACR,OAAO,CAACG,EAAKC,EAAOC,IAAUF,EAAO,OAAOC,CAAK,GAAKH,EAAgBI,GAAS,CAAC,EAE3D,GAGxB,OAAOH,EAAY,EAAI,EAAI,GAAKA,CAClC,CAeA,SAASI,GAAYC,EAAM,GAAI,CAE7B,IAAMC,EAAa,OAAOD,CAAG,EAAE,QAAQ,SAAU,EAAE,EAE7CE,EAAa,GAGnB,GAAID,IAAe,IAAMA,EAAW,OAASC,EAC3C,MAAO,GAIT,IAAMC,EAAYF,EAAW,SAASC,EAAY,GAAG,EAIrD,GAAI,eAAe,KAAKC,CAAS,EAC/B,MAAO,GAIT,IAAMC,EAAUD,EAAU,UAAU,EAAG,CAAC,EAIxC,GAHoBX,GAAwBY,CAAO,IAG/B,OAAOD,EAAU,CAAC,CAAC,EACrC,MAAO,GAGT,IAAME,EAAUF,EAAU,UAAU,EAAG,EAAE,EAIzC,OAHoBX,GAAwBa,CAAO,IAG5B,OAAOF,EAAU,EAAE,CAAC,CAC7C,CAKAZ,GAAO,QAAUQ,KChFjB,IAAAO,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAYA,IAAMC,GACJ,uJAeF,SAASC,GAAcC,EAAQ,GAAI,CAEjC,IAAMC,EAAgB,OAAOD,CAAK,EAGlC,OAAOF,GAAY,KAAKG,CAAa,CACvC,CAKAJ,GAAO,QAAUE,KCvCjB,IAAAG,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAMA,IAAMC,GAAe,KACfC,GAAc,KACdC,GAAgB,KAMhBC,GACJ,yEAOIC,GAAkB,kBAkBxB,SAASC,GAAiBC,EAAQ,GAAI,CAEpC,IAAMC,EAAc,OAAOD,GAAS,EAAE,EAAE,KAAK,EAG7C,OAAIC,IAAgB,GACX,GAILJ,GAAc,KAAKI,CAAW,GAC9BH,GAAgB,KAAKG,CAAW,EAAU,GAC1CA,EAAY,SAAS,GAAG,EAAUL,GAAcK,CAAW,EAG3D,GAAAN,GAAYM,CAAW,GAIvBP,GAAaO,CAAW,EAM9B,CAGAR,GAAO,QAAUM,KCpEjB,IAAAG,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAQA,IAAMC,GAAkB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EAC5CC,GAAkB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EAYlD,SAASC,GAAYC,EAAM,GAAI,CAC7B,IAAMC,EAAa,OAAOD,CAAG,EAAE,QAAQ,SAAU,EAAE,EAEnD,GAAIC,EAAW,SAAW,IAAM,eAAe,KAAKA,CAAU,EAC5D,MAAO,GAGT,IAAMC,EAAOD,EAAW,UAAU,EAAG,CAAC,EAChCE,EAAiBF,EAAW,UAAU,CAAC,EAUvCG,EAPOF,EACV,MAAM,EAAE,EACR,OACC,CAACG,EAAKC,EAAOC,IAAUF,EAAM,OAAOC,CAAK,EAAIT,GAAgBU,CAAK,EAClE,CACF,EAEwB,GAG1B,IAFsBH,GAAc,GAAK,EAAIA,KAEvB,OAAOD,EAAe,CAAC,CAAC,EAC5C,MAAO,GAWT,IAAMK,EAPON,EACV,MAAM,EAAE,EACR,OACC,CAACG,EAAKC,EAAOC,IAAUF,EAAM,OAAOC,CAAK,EAAIR,GAAgBS,CAAK,EAClE,CACF,EAEwB,GAG1B,OAFsBC,GAAc,GAAK,EAAIA,KAEpB,OAAOL,EAAe,CAAC,CAAC,CACnD,CAGAP,GAAO,QAAUG,KC7DjB,IAAAU,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CASA,IAAMC,GAAc,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EAejD,SAASC,GAAoBC,EAAM,GAAI,CACrC,IAAMC,EAAa,OAAOD,CAAG,EAAE,QAAQ,SAAU,EAAE,EAEnD,GAAIC,EAAW,SAAW,IAAM,eAAe,KAAKA,CAAU,EAC5D,MAAO,GAGT,IAAMC,EAAOD,EAAW,UAAU,EAAG,EAAE,EACjCE,EAAgB,OAAOF,EAAW,EAAE,CAAC,EAMrCG,EAJMF,EACT,MAAM,EAAE,EACR,OAAO,CAACG,EAAKC,EAAOC,IAAUF,EAAM,OAAOC,CAAK,EAAIR,GAAYS,CAAK,EAAG,CAAC,EAEpD,GAClBC,EAAkBJ,EAAY,EAAI,EAAI,GAAKA,EAEjD,OAAOD,IAAkBK,CAC3B,CAGAX,GAAO,QAAUE,KC7CjB,IAAAU,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CASA,IAAMC,GAAkB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EAYrD,SAASC,GAAgBC,EAAU,GAAI,CACrC,IAAMC,EAAa,OAAOD,CAAO,EAAE,QAAQ,SAAU,EAAE,EAAE,SAAS,GAAI,GAAG,EAEzE,GAAIC,EAAW,SAAW,IAAM,eAAe,KAAKA,CAAU,EAC5D,MAAO,GAGT,IAAMC,EAAOD,EAAW,UAAU,EAAG,EAAE,EACjCE,EAAgB,OAAOF,EAAW,EAAE,CAAC,EASrCG,EAPeF,EAAK,MAAM,EAAE,EAAE,QAAQ,EAEnB,OACvB,CAACG,EAAKC,EAAOC,IAAUF,EAAM,OAAOC,CAAK,EAAIR,GAAgBS,CAAK,EAClE,CACF,EAEwB,GAClBC,EAAkBJ,GAAa,EAAI,EAAI,GAAKA,EAElD,OAAOD,IAAkBK,CAC3B,CAGAX,GAAO,QAAUE,KC7CjB,IAAAU,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAQA,IAAMC,GAAqB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EAYlD,SAASC,GAAsBC,EAAS,GAAI,CAE1C,GAAIA,GAAU,KACZ,MAAO,GAGT,IAAMC,EAAa,OAAOD,CAAM,EAAE,QAAQ,SAAU,EAAE,EAAE,SAAS,GAAI,GAAG,EAExE,GAAIC,EAAW,SAAW,GACxB,MAAO,GAGT,IAAMC,EAAOD,EAAW,UAAU,EAAG,CAAC,EAChCE,EAAY,OAAOF,EAAW,UAAU,EAAG,EAAE,CAAC,EAC9CG,EAAiBH,EAAW,UAAU,EAAE,EAG9C,GAAIE,EAAY,GAAKA,EAAY,GAC/B,MAAO,GAWT,IAAIE,EAPSH,EACV,MAAM,EAAE,EACR,OACC,CAACI,EAAKC,EAAOC,IAAUF,EAAM,OAAOC,CAAK,EAAIT,GAAmBU,CAAK,EACrE,CACF,EAEsB,GACpBC,EAcJ,GARIJ,IAAe,EACjBI,EAAiBN,IAAc,GAAKA,IAAc,EAAK,EAAI,EAClDE,EAAa,EACtBI,EAAgB,EAEhBA,EAAgBJ,EAGdI,IAAkB,OAAOL,EAAe,CAAC,CAAC,EAC5C,MAAO,GAIT,IAAMM,EAAS,OAAOT,EAAW,UAAU,EAAG,CAAC,CAAC,EAC1CU,EAAS,OAAOV,EAAW,UAAU,EAAG,EAAE,CAAC,EAI7CW,GAFUF,EAAS,EAAMC,EAAS,EAAMF,EAAgB,GAEpC,GACpBI,EAGJ,OAAID,IAAe,EACjBC,EAAiBV,IAAc,GAAKA,IAAc,EAAK,EAAI,EAClDS,EAAa,EACtBC,EAAgB,EAEhBA,EAAgBD,EAGXC,IAAkB,OAAOT,EAAe,CAAC,CAAC,CACnD,CAGAP,GAAO,QAAUE,KC1FjB,IAAAe,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CASA,IAAMC,GAAa,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EAoB1C,SAASC,GAAWC,EAAK,GAAI,CAE3B,GAAIA,GAAM,KACR,MAAO,GAIT,IAAMC,EAAU,OAAOD,CAAE,EACtB,YAAY,EACZ,QAAQ,UAAW,EAAE,EAGxB,GAAIC,EAAQ,SAAW,EACrB,MAAO,GAIT,IAAMC,EAAOD,EAAQ,UAAU,EAAG,CAAC,EAC7BE,EAAgBF,EAAQ,UAAU,CAAC,EAazC,GAVI,CAAC,UAAU,KAAKC,CAAI,GAKpB,CAAC,UAAU,KAAKC,CAAa,GAK7B,cAAc,KAAKD,CAAI,EACzB,MAAO,GAgBT,IAAME,EAAa,GAVPF,EACT,MAAM,EAAE,EACR,OAAO,CAACG,EAAKC,EAAOC,IACZF,EAAO,OAAOC,CAAK,EAAIR,GAAWS,CAAK,EAC7C,CAAC,EAGkB,GAMpBC,EAEJ,OAAIJ,IAAe,GAEjBI,EAAkB,IACTJ,IAAe,GAExBI,EAAkB,IAGlBA,EAAkB,OAAOJ,CAAU,EAI9BI,IAAoBL,CAC7B,CAGAN,GAAO,QAAUE,KClGjB,IAAAU,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAAAA,GAAO,QAAU,CACf,kBAAmB,KACnB,YAAa,KACb,iBAAkB,KAClB,YAAa,KACb,aAAc,KACd,YAAa,KACb,cAAe,KACf,oBAAqB,KACrB,gBAAiB,KACjB,sBAAuB,KACvB,WAAY,IACd,ICZA,IAAAC,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAAAA,GAAO,QAAU,CACf,yBAA0B,IAC1B,0BAA2B,IAC3B,uBAAwB,IAC1B,ICJA,IAAAC,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAAAA,GAAO,QAAU,CACf,KAAM,CACJ,SAAU,GACZ,EACA,UAAW,IACX,OAAQ,IACR,OAAQ,CACN,GAAI,CACF,UAAW,CACT,yBAA0B,IAC1B,0BAA2B,IAC3B,uBAAwB,IAC1B,CACF,EACA,WAAY,KACZ,cAAe,IACjB,EACA,QAAS,KACT,MAAO,KACP,WAAY,KACZ,GAAG,KACH,GAAG,KACH,GAAG,KACH,GAAG,KACH,GAAG,IACH,GAAG,IACH,WAAY,KACZ,cAAe,IACjB","names":["require_bufferConcatenate","__commonJSMin","exports","module","bufferConcatenate","buffer1","buffer2","view1","view2","resultView","require_convertECDSAASN1Signature","__commonJSMin","exports","module","bufferConcatenate","convertECDSAASN1Signature","asn1Signature","elements","readASN1IntegerSequence","s","normalizeECDSAComponent","component","length","normalized","padding","input","sequenceLength","position","sequenceEnd","elementLength","elementValue","require_base64To","__commonJSMin","exports","module","base64To","text","fromFormat","base64String","input","binaryString","require_base64FromBuffer","__commonJSMin","exports","module","base64To","base64FromBuffer","buffer","bytes","CHUNK_SIZE","chunks","chunk","require_getAuthenticationAuthData","__commonJSMin","exports","module","base64FromBuffer","getAuthenticationAuthData","assertion","id","rawId","type","response","authData","getAuthDataFromAuthentication","dataView","pointer","rpIdHash","flagsBuf","flagsInt","flags","counterBuf","counter","attestationResult","parseAttestedCredentialData","extensionsData","parseExtensionData","aaguid","credentialIdLength","credentialId","credentialPublicKey","require_getRegistrationAuthData","__commonJSMin","exports","module","cbor","base64FromBuffer","parseAuthenticatorData","attestationObjectBuffer","attestationObject","authData","ATTESTED_CREDENTIAL_DATA_OFFSET","AAGUID_LENGTH","CREDENTIAL_ID_LENGTH_BYTES","CREDENTIAL_ID_LENGTH_OFFSET","CREDENTIAL_ID_OFFSET","idLenBytes","credentialIdLength","credentialId","publicKeyBytes","getRegistrationAuthData","credential","response","parsedAuthData","clientDataJSONDecoded","require_getWebAuthnAuthenticationAssertion","__commonJSMin","exports","module","validateAuthenticationOptions","props","cred","getWebAuthnAuthenticationAssertion","callback","assertion","require_getWebAuthnRegistrationCredential","__commonJSMin","exports","module","validateCreationOptions","props","param","getWebAuthnRegistrationCredential","callback","credential","require_base64ToBuffer","__commonJSMin","exports","module","base64ToBuffer","base64String","nodeBuffer","binaryString","len","bytes","require_bufferCompare","__commonJSMin","exports","module","bufferCompare","buffer1","buffer2","buf1","buf2","view1_32","view2_32","i","remainingOffset","view1_8","view2_8","require_bufferFromString","__commonJSMin","exports","module","bufferFromString","txtString","encoding","require_getCrypto","__commonJSMin","exports","module","getCrypto","require_validateRPID","__commonJSMin","exports","module","base64ToBuffer","bufferCompare","bufferFromString","getCrypto","validateRPID","originalRPID","verifyRPID","algorithm","crypto","originalRPIDBuffer","digestOfOriginalRPID","digestToVerify","require_verifySignature","__commonJSMin","exports","module","getCrypto","verifySignature","algorithm","key","signature","data","require_importCryptoKey","__commonJSMin","exports","module","getCrypto","importCryptoKey","format","keyData","algorithm","extractable","keyUsages","require_isNumber","__commonJSMin","exports","module","isNumber","value","require_base64From","__commonJSMin","exports","module","base64From","text","binaryString","bytes","i","require_validateAuthentication","__commonJSMin","exports","module","verifySignature","importCryptoKey","validateRPID","isNumber","base64ToBuffer","base64From","bufferConcatenate","convertECDSAASN1Signature","getImportPublicKeyAlgorithm","publicKeyAlgorithm","getAlgorithmVerifySignatureParam","generateDataToVerify","assertion","authenticatorDataBuffer","clientDataJSONBuffer","clientDataJSONHash","validateAuthentication","credential","expectedProps","incomingProps","publicKeyProps","convertECDSignature","counterCredential","counterAssertion","clientDataJSON","assertionChallenge","importAlgo","verifyAlgo","publicKey","signature","dataToVerify","require_validateRegistration","__commonJSMin","exports","module","base64ToBuffer","cbor","validateRegistration","credential","expectedProps","clientDataJSON","attestationObjectBuffer","attestationObject","require_webauthn","__commonJSMin","exports","module","require_constants","__commonJSMin","exports","module","require_bufferToString","__commonJSMin","exports","module","bufferToString","buffer","encoding","require_decrypt","__commonJSMin","exports","module","getCrypto","bufferToString","base64ToBuffer","importCryptoKey","decrypt","privateKey","encryptedMessage","props","format","algorithm","extractable","keyUsages","padding","crypto","cleanedPrivateKey","binaryPrivateKey","importedKey","encryptedData","decryptedBuffer","require_encrypt","__commonJSMin","exports","module","getCrypto","bufferFromString","base64FromBuffer","importCryptoKey","base64ToBuffer","encrypt","publicKey","message","props","crypto","cleanedPublicKey","binaryPublicKey","importedKey","messageBuffer","encryptedBuffer","require_digest","__commonJSMin","exports","module","getCrypto","digest","algorithm","data","binaryData","crypto","hashBuffer","nodeAlgorithm","hash","require_crypto","__commonJSMin","exports","module","require_isInstanceOf","__commonJSMin","exports","module","isInstanceOf","object","instanceType","require_stringToDate","__commonJSMin","exports","module","DATE_ISO_FORMAT","parse","isInstanceOf","stringToDate","stringDate","stringFormat","defaultDate","dateToProcess","parsedDate","timezoneOffsetMillis","require_dateFirstHourOfDay","__commonJSMin","exports","module","isInstanceOf","dateFirstHourOfDay","date","newDate","require_dateLastHourOfDay","__commonJSMin","exports","module","isInstanceOf","dateLastHourOfDay","date","newDate","require_setConditionsBetweenDates","__commonJSMin","exports","module","DATE_BR_FORMAT_D","stringToDate","dateFirstHourOfDay","dateLastHourOfDay","setConditionBetweenDates","object","fromFormat","key","beforeKey","afterKey","resetHMS","conditions","fromDate","finalDate","untilDate","require_setConditionsBetweenValues","__commonJSMin","exports","module","setConditionBetweenValues","object","key","beforeKey","afterKey","conditions","require_setConditionStringLike","__commonJSMin","exports","module","setConditionStringLike","object","key","insensitive","operator","value","require_waitPlugin","__commonJSMin","exports","module","WaitPlugin","name","isSuccessful","returnParam","waitItem","error","resolve","reject","promise","res","rej","allWaitKeys","key","WP","require_defaultNumeric","__commonJSMin","exports","module","defaultNumeric","checkValue","defaultValue","num","require_bulkProcessor","__commonJSMin","exports","module","defaultNumeric","BulkProcessor","#buffer","#limit","#maxBufferSize","#maxConcurrentFlushes","#activeFlushes","#isEnding","#logger","#payload","#serviceContext","#retries","#retryDelayMs","#flushTimeoutMs","#callbacks","arg1","arg2","arg3","options","payload","callbackFunctions","otherOptions","userLimit","maxBufferSize","maxConcurrentFlushes","flushTimeoutMs","retries","retryDelayMs","logger","serviceContext","onFlush","onAdd","onEnd","onBackpressure","onFlushFailure","item","error","resolve","syncError","batch","#executeFlush","lastError","attempt","timeoutId","timeoutPromise","_","reject","failureCallbackError","forceTimeoutMs","endStartTime","require_dateCompareAsc","__commonJSMin","exports","module","dateCompareAsc","dateA","dateB","options","finalOptions","paramName","timeA","timeB","error","require_dateCompareDesc","__commonJSMin","exports","module","dateCompareDesc","dateA","dateB","options","finalOptions","timeA","timeB","error","require_defaultValue","__commonJSMin","exports","module","defaultValue","checkValue","require_isObject","__commonJSMin","exports","module","isObject","object","require_helpers","__commonJSMin","exports","module","require_assign","__commonJSMin","exports","module","deepClone","source","map","clone","key","assign","target","throwsError","clonedTarget","clonedSource","error","require_base64FromBase64URLSafe","__commonJSMin","exports","module","base64FromBase64URLSafe","urlSafeBase64","base64","requiredPadding","require_toString","__commonJSMin","exports","module","toString","textObj","objectToJSON","initialString","require_base64URLEncode","__commonJSMin","exports","module","toString","base64To","base64URLEncode","text","fromFormat","require_calculateSecondsInTime","__commonJSMin","exports","module","calculateSecondsInTime","seconds","add","offsetInMilliseconds","require_currencyBRToFloat","__commonJSMin","exports","module","toString","isNumber","currencyBRToFloat","moneyValue","cleanedString","result","require_dateToFormat","__commonJSMin","exports","module","DATE_BR_FORMAT_D","format","isInstanceOf","dateToFormat","date","stringFormat","require_debouncer","__commonJSMin","exports","module","debouncer","callback","timeout","timer","args","context","require_deleteKeys","__commonJSMin","exports","module","isObject","deleteKeys","object","keys","newObject","key","require_generateSimpleId","__commonJSMin","exports","module","toString","generateSimpleId","id","separator","randomBytes","randomHex","byte","parts","idString","require_generateRandomString","__commonJSMin","exports","module","CHAR_SETS","generateRandomString","size","options","finalOptions","validChars","randomValues","result","i","randomIndex","require_getExecutionTime","__commonJSMin","exports","module","getExecutionTime","time","diffNanos","require_JSONFrom","__commonJSMin","exports","module","JSONFrom","text","throwsError","error","require_JSONTo","__commonJSMin","exports","module","JSONTo","object","throwsError","error","require_messageEncryptToChunks","__commonJSMin","exports","module","encrypt","base64To","messageEncryptToChunks","publicKey","message","props","message64","chunkSize","chunks","i","encryptionPromises","chunk","require_messageDecryptFromChunks","__commonJSMin","exports","module","decrypt","base64From","messageDecryptFromChunks","privateKey","messageChunks","props","decryptionPromises","chunk","finalBase64","require_normalize","__commonJSMin","exports","module","isNumber","normalize","text","require_pickKeys","__commonJSMin","exports","module","pickKeys","sourceObject","keysToPick","newObj","key","require_pushLogMessage","__commonJSMin","exports","module","pushLogMessage","logObj","message","more_info","newEntry","require_regexDigitsOnly","__commonJSMin","exports","module","toString","regexDigitsOnly","text","require_regexReplaceTrim","__commonJSMin","exports","module","toString","regexReplaceTrim","text","regex","replacement","trim","stringValue","allowedChars","replacementValue","filterRegex","result","require_regexLettersOnly","__commonJSMin","exports","module","toString","regexLettersOnly","text","require_removeDuplicatedStrings","__commonJSMin","exports","module","toString","isObject","removeDuplicatedStrings","text","splitString","caseInsensitive","separator","array","v","seenIndexes","item","index","indexesToKeep","_item","require_sleep","__commonJSMin","exports","module","sleep","milliseconds","returnValue","throwError","error","resolve","reject","require_split","__commonJSMin","exports","module","split","text","char","require_stringCompress","__commonJSMin","exports","module","compressSync","strToU8","stringCompress","text","options","finalOptions","inputBuffer","compressedBuffer","binary","len","i","require_stringDecompress","__commonJSMin","exports","module","decompressSync","strFromU8","stringDecompress","compressedData","options","finalOptions","inputBuffer","binaryString","len","bytes","i","decompressedBuffer","require_stringToDateToFormat","__commonJSMin","exports","module","DATE_ISO_FORMAT","DATE_BR_HOUR_FORMAT_D","stringToDate","dateToFormat","stringToDateToFormat","stringDate","fromFormat","toFormat","dateObject","timezoneOffsetMillis","localDate","require_stringToFormat","__commonJSMin","exports","module","toString","regexDigitsOnly","STRING_FORMAT_CNPJ","stringToFormat","text","pattern","options","finalOptions","processedText","requiredSize","charIndex","require_stringZLibCompress","__commonJSMin","exports","module","zlibSync","strToU8","stringZLibCompress","text","options","finalOptions","inputBuffer","compressedBuffer","binary","len","i","require_stringZLibDecompress","__commonJSMin","exports","module","unzlibSync","strFromU8","stringZLibDecompress","compressedData","options","finalOptions","inputBuffer","binaryString","len","bytes","i","decompressedBuffer","require_throttle","__commonJSMin","exports","module","throttle","callback","wait","inCooldown","args","require_timestamp","__commonJSMin","exports","module","timestamp","format","now","tokens","token","require_uint8ArrayFromString","__commonJSMin","exports","module","uint8ArrayFromString","text","joinChar","uint8Array","require_uint8ArrayToString","__commonJSMin","exports","module","uint8ArrayToString","uint8Array","splitChar","bufferSource","bytes","s","require_utils","__commonJSMin","exports","module","require_validateCADICMSPR","__commonJSMin","exports","module","_calculateVerifierDigit","digits","weights","remainder","acc","digit","index","validateCADICMSPR","cadicms","digitsOnly","CADICMS_LENGTH","paddedCadicms","WEIGHTS_DV1","firstEightDigits","expectedFirstVerifier","firstVerifier","WEIGHTS_DV2","firstNineDigits","expectedSecondVerifier","secondVerifier","require_validateCEP","__commonJSMin","exports","module","validateCEP","cep","require_validateCNPJ","__commonJSMin","exports","module","DEFAULT_WEIGHTS","_getCharValue","char","_calculateVerifierDigits","baseCnpj","weights","getDigit","sum","remainder","sum1","sum2","i","value","dv1","dv2","validateCNPJ","cnpj","options","processedCnpj","finalOptions","baseDigits","verifierDigits","calculatedVerifierDigits","require_validateCPF","__commonJSMin","exports","module","_calculateVerifierDigit","baseDigits","initialWeight","remainder","acc","digit","index","validateCPF","cpf","digitsOnly","CPF_LENGTH","paddedCpf","baseDv1","baseDv2","require_validateEmail","__commonJSMin","exports","module","EMAIL_REGEX","validateEmail","email","emailAsString","require_validateChavePix","__commonJSMin","exports","module","validateCNPJ","validateCPF","validateEmail","UUID_V4_REGEX","PIX_PHONE_REGEX","validateChavePix","chave","keyAsString","require_validateCNH","__commonJSMin","exports","module","CNH_WEIGHTS_DV1","CNH_WEIGHTS_DV2","validateCNH","cnh","digitsOnly","base","verifierDigits","remainder1","acc","digit","index","remainder2","require_validatePISPASEPNIT","__commonJSMin","exports","module","PIS_WEIGHTS","validatePISPASEPNIT","pis","digitsOnly","base","verifierDigit","remainder","acc","digit","index","calculatedDigit","require_validateRenavam","__commonJSMin","exports","module","RENAVAM_WEIGHTS","validateRENAVAM","renavam","digitsOnly","base","verifierDigit","remainder","acc","digit","index","calculatedDigit","require_validateTituloEleitor","__commonJSMin","exports","module","TITULO_WEIGHTS_DV1","validateTituloEleitor","titulo","digitsOnly","base","stateCode","verifierDigits","remainder1","acc","digit","index","calculatedDv1","digit1","digit2","remainder2","calculatedDv2","require_validateRG","__commonJSMin","exports","module","RG_WEIGHTS","validateRG","rg","cleanRG","base","verifierDigit","complement","acc","digit","index","calculatedDigit","require_validators","__commonJSMin","exports","module","require_sequelize","__commonJSMin","exports","module","require_index","__commonJSMin","exports","module"]}