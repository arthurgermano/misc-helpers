const base64ToBuffer = require("../../utils/base64ToBuffer");
const bufferConcatenate = require("../../utils/bufferConcatenate");
const NF = require("node-forge");

// ------------------------------------------------------------------------------------------------

function validateAuthentication(
  expectedProps = {},
  registrationProps = {},
  authenticationProps = {}
) {
  validateExpectedData(expectedProps, authenticationProps);

  validateRPID(
    registrationProps.authData.rpIdHash,
    authenticationProps.authData.rpIdHash
  );

  validateFlags(authenticationProps.authData.flags);

  validateSignature(registrationProps.publicKey, authenticationProps.response);
}

// ------------------------------------------------------------------------------------------------

function validateExpectedData(expectedProps, authenticationProps) {
  const clientDataJSON = JSON.parse(
    authenticationProps.response.clientDataJSON
  );
  if (expectedProps.origin != clientDataJSON.origin) {
    throw new Error(
      `Origin does not match. Expected: ${expectedProps.origin} Actual: ${clientDataJSON.origin}`
    );
  }

  if (expectedProps.challenge != clientDataJSON.challenge) {
    throw new Error(
      `Challenge does not match. Provided challenge: ${expectedProps.challenge}.`
    );
  }
}

// ------------------------------------------------------------------------------------------------

function validateRPID(expectedRPID, actualRPID) {
  if (expectedRPID != actualRPID) {
    throw new Error(
      `Registration RPID does not match the authentication RPID.`
    );
  }
}

// ------------------------------------------------------------------------------------------------

function validateFlags(flags) {
  if (!flags.up) {
    throw new Error(`User Present is required for authentication.`);
  }

  if (!flags.uv) {
    throw new Error(`User Verified is required for authentication.`);
  }
}

// ------------------------------------------------------------------------------------------------

function validateSignature(publicKey64, authResponse) {  

  // Creating the signature to be compared with the one generated by the authenticator
  const authenticatorDataBuffer = base64ToBuffer(
    authResponse.authenticatorData
  );
  const clientDataJSONSHA256Data = NF.md.sha256.digest(
    NF.util.createBuffer(authResponse.clientDataJSON)
  );
  const signatureBaseBuffer = bufferConcatenate(
    authenticatorDataBuffer,
    clientDataJSONSHA256Data
  );

  // the signatureBaseBuffer is ready to be verified
  const dataToVerify = NF.util.createBuffer(
    new Uint8Array(signatureBaseBuffer)
  );

  // Transforming the signature generated by the authenticator
  const forgeSignature = NF.util.createBuffer(new Uint8Array(authResponse.signature));
  
  // Transforming the public key
  const publicKey = base64ToBuffer(publicKey64);
  const forgePublicKey = NF.pki.publicKeyFromPem(publicKey);

  // Verify the signature
  const valid = forgePublicKey.verify(dataToVerify, forgeSignature.getBytes());
  return valid;
}

// ------------------------------------------------------------------------------------------------

module.exports = validateAuthentication;

// ------------------------------------------------------------------------------------------------
