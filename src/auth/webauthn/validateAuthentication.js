const verifySignature = require("../../crypto/verifySignature");
const importCryptoKey = require("../../crypto/importCryptoKey");
const validateRPID = require("./validateRPID");
const isNumber = require("../../helpers/isNumber");
const base64ToBuffer = require("../../utils/base64ToBuffer");
const base64From = require("../../utils/base64From");
const bufferConcatenate = require("../../utils/bufferConcatenate");
const convertECDSAASN1Signature = require("./convertECDSAASN1Signature");

// ------------------------------------------------------------------------------------------------
/**
 * Asynchronously validates a WebAuthn authentication assertion against the expected properties and the provided credential.
 *
 * @param {Object} credential - The WebAuthn credential object.
 * @param {string} credential.id - The credential ID.
 * @param {string} credential.rawId - The raw credential ID.
 * @param {string} credential.type - The credential type, expected to be "public-key".
 * @param {number} credential.publicKeyAlgorithm - The algorithm used for the public key.
 * @param {string} credential.publicKey - The public key in base64 format.
 *
 * @param {Object} assertion - The WebAuthn assertion object.
 * @param {string} assertion.id - The assertion ID.
 * @param {string} assertion.rawId - The raw assertion ID.
 * @param {string} assertion.type - The assertion type, expected to be "public-key".
 * @param {Object} assertion.response - The response from the authenticator.
 * @param {string} assertion.response.clientDataJSONDecoded - The decoded client data JSON.
 * @param {string} assertion.response.authenticatorDataDecoded - The decoded authenticator data.
 * @param {ArrayBuffer} assertion.response.signature - The signature generated by the authenticator.
 *
 * @param {Object} [expectedProps={}] - The expected properties for validation.
 * @param {string} [expectedProps.challenge] - The expected challenge.
 * @param {string} [expectedProps.origin] - The expected origin.
 * @param {string} [expectedProps.type] - The expected type.
 * @param {string} [expectedProps.rpID] - The expected relying party ID.
 * @param {number} [expectedProps.counterCredential] - The expected credential counter.
 *
 * @param {Object} [incomingProps={}] - The incoming properties for validation.
 * @param {number} [incomingProps.counterAssertion] - The incoming assertion counter.
 *
 * @param {Object} [publicKeyProps={}] - The properties for importing the public key.
 * @param {Object} [publicKeyProps.importKey] - The import key properties.
 * @param {string} [publicKeyProps.importKey.format] - The format of the key, default is "spki".
 * @param {boolean} [publicKeyProps.importKey.extractable] - Whether the key is extractable, default is false.
 *
 * @returns {Promise<boolean>} Returns true if the validation is successful.
 * @throws Will throw an error if validation fails.
 */
async function validateAuthentication(
  credential,
  assertion,
  expectedProps = {},
  incomingProps = {},
  publicKeyProps = {},
  convertECDSignature = true
) {
  try {
    validateCounters(expectedProps, incomingProps);
    validateRequestParams(assertion, expectedProps);
    validateFlags(assertion);
    validateCredentialProps(credential);
    validateAssertionProps(assertion);
    validateCredentialAssertion(credential, assertion);
    validateRPID(expectedProps.rpID, assertion.authData.rpIdHash);

    const importCryptoKeyAlgorithm = getImportPublicKeyAlgorithm(
      credential.response.publicKeyAlgorithm
    );
    const publicKey = await importCryptoKey(
      publicKeyProps?.importKey?.format || "spki",
      base64ToBuffer(credential.response.publicKey),
      importCryptoKeyAlgorithm,
      publicKeyProps?.importKey?.extractable || false,
      ["verify"]
    );

    const algorithm = getAlgorithmVerifySignatureParam(
      credential.response.publicKeyAlgorithm
    );

    let signature = new Uint8Array(
      base64ToBuffer(assertion.response.signature)
    );
    if (convertECDSignature && credential.response.publicKeyAlgorithm === -7) {
      signature = convertECDSAASN1Signature(signature);
    }

    const dataToVerify = await generateHashFromAssertion(crypto, assertion);
    return await verifySignature(algorithm, publicKey, signature, dataToVerify);
  } catch (error) {
    throw error;
  }
}

// ------------------------------------------------------------------------------------------------
/**
 * Validates counters for the expected and incoming properties.
 *
 * @param {Object} expectedProps - The expected properties.
 * @param {number} expectedProps.counterCredential - The expected credential counter.
 * @param {Object} incomingProps - The incoming properties.
 * @param {number} incomingProps.counterAssertion - The incoming assertion counter.
 *
 * @throws Will throw an error if the counter validation fails.
 * @returns {boolean} Returns true if the counters are valid.
 */
function validateCounters(expectedProps, incomingProps) {
  if (
    !isNumber(expectedProps.counterCredential) ||
    expectedProps.counterCredential < 0
  ) {
    throw new Error(
      "counterCredential must be a number greater than or equal to zero"
    );
  }

  if (
    !isNumber(incomingProps.counterAssertion) ||
    incomingProps.counterAssertion < 0
  ) {
    throw new Error(
      "counterAssertion must be a number greater than or equal to zero"
    );
  }

  if (expectedProps.counterCredential <= incomingProps.counterAssertion) {
    throw new Error("counterCredential must be greater than counterAssertion");
  }
  return true;
}

// ------------------------------------------------------------------------------------------------
/**
 * Validates the flags in the assertion.
 *
 * @param {Object} assertion - The assertion object.
 *
 * @throws Will throw an error if the flags validation fails.
 */
function validateFlags(assertion) {
  if (!assertion.authData.flags.up) {
    throw new Error(`User Present is required for authentication.`);
  }

  if (!assertion.authData.flags.uv) {
    throw new Error(`User Verified is required for authentication.`);
  }
}

// ------------------------------------------------------------------------------------------------
/**
 * Validates the properties of the credential.
 *
 * @param {Object} credential - The credential object.
 *
 * @throws Will throw an error if the credential validation fails.
 * @returns {boolean} Returns true if the credential properties are valid.
 */
function validateCredentialProps(credential) {
  if (!credential) {
    throw new Error("Missing credential");
  }
  if (!credential.id) {
    throw new Error("Missing credential ID");
  }
  if (!credential.rawId) {
    throw new Error("Ḿissing credential rawId");
  }
  if (!credential.type || credential.type != "public-key") {
    throw new Error(
      "Ḿissing credential type or credential type is not public-key"
    );
  }
  return true;
}

// ------------------------------------------------------------------------------------------------
/**
 * Validates the properties of the assertion.
 *
 * @param {Object} assertion - The assertion object.
 *
 * @throws Will throw an error if the assertion validation fails.
 * @returns {boolean} Returns true if the assertion properties are valid.
 */
function validateAssertionProps(assertion) {
  if (!assertion) {
    throw new Error("Missing assertion");
  }
  if (!assertion.id) {
    throw new Error("Missing assertion ID");
  }
  if (!assertion.rawId) {
    throw new Error("Ḿissing assertion rawId");
  }
  if (!assertion.type || assertion.type != "public-key") {
    throw new Error(
      "Ḿissing assertion type or assertion type is not public-key"
    );
  }
  return true;
}

// ------------------------------------------------------------------------------------------------
/**
 * Validates the request parameters in the assertion against the expected properties.
 *
 * @param {Object} assertion - The assertion object.
 * @param {Object} [expectedProps={}] - The expected properties.
 * @param {string} [expectedProps.challenge] - The expected challenge.
 * @param {string} [expectedProps.origin] - The expected origin.
 * @param {string} [expectedProps.type] - The expected type.
 *
 * @throws Will throw an error if the request parameters validation fails.
 * @returns {boolean} Returns true if the request parameters are valid.
 */
function validateRequestParams(assertion, expectedProps = {}) {
  const clientDataJSON = JSON.parse(assertion.response.clientDataJSONDecoded);
  const assertionChallenge = base64From(clientDataJSON?.challenge || "");
  if (expectedProps.challenge != assertionChallenge) {
    throw new Error("Challenge provided does not match assertion challenge.");
  }

  if (expectedProps.origin != clientDataJSON?.origin) {
    throw new Error(
      `Origin does not match. Expected: ${expectedProps.origin} Actual: ${
        clientDataJSON?.origin || "none"
      }`
    );
  }

  if (expectedProps.type != clientDataJSON?.type) {
    throw new Error(
      `Type does not match. Expected: ${expectedProps.type} Actual: ${
        clientDataJSON?.type || "none"
      }`
    );
  }
  return true;
}

// ------------------------------------------------------------------------------------------------
/**
 * Validates that the credential ID and raw ID match the assertion ID and raw ID.
 *
 * @param {Object} credential - The credential object.
 * @param {Object} assertion - The assertion object.
 *
 * @throws Will throw an error if the credential and assertion IDs do not match.
 * @returns {boolean} Returns true if the credential and assertion IDs match.
 */
function validateCredentialAssertion(credential, assertion) {
  if (credential.id != assertion.id) {
    throw new Error("Credential ID does not match assertion ID");
  }
  if (credential.rawId != assertion.rawId) {
    throw new Error("Credential rawId does not match assertion rawId");
  }
  return true;
}

// ------------------------------------------------------------------------------------------------
/**
 * Retrieves the key import algorithm parameters based on the public key algorithm.
 *
 * @param {number} publicKeyAlgorithm - The public key algorithm.
 *
 * @throws Will throw an error if the public key algorithm is not supported.
 * @returns {Object} The key import algorithm parameters.
 */
function getImportPublicKeyAlgorithm(publicKeyAlgorithm) {
  if (publicKeyAlgorithm === -7) {
    return {
      name: "ECDSA",
      namedCurve: "P-256",
    };
  }
  if (publicKeyAlgorithm === -257) {
    return {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" },
    };
  }
  if (publicKeyAlgorithm === -8) {
    throw new Error("Ed25519 is not supported by crypto.subtle directly");
  }
  throw new Error(`Unsupported algorithm: ${publicKeyAlgorithm}`);
}

// ------------------------------------------------------------------------------------------------
/**
 * Retrieves the algorithm parameters for verifying a signature based on the public key algorithm.
 *
 * @param {number} publicKeyAlgorithm - The public key algorithm identifier.
 * @returns {Object} The algorithm parameters for verifying the signature.
 * @throws Will throw an error if the public key algorithm is not supported.
 */
function getAlgorithmVerifySignatureParam(publicKeyAlgorithm) {
  if (publicKeyAlgorithm === -7) {
    return {
      name: "ECDSA",
      hash: { name: "SHA-256" },
    };
  }
  if (publicKeyAlgorithm === -257) {
    return {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" },
    };
  }
  if (publicKeyAlgorithm === -8) {
    throw new Error(
      "Ed25519 is not supported by crypto.subtle. Use an external library."
    );
  }
  throw new Error(`Unsupported algorithm: ${publicKeyAlgorithm}`);
}

// ------------------------------------------------------------------------------------------------
/**
 * Generates a hash from the authenticator data and client data JSON of the assertion.
 *
 * @param {Crypto} crypto - The crypto object for cryptographic operations.
 * @param {Object} assertion - The WebAuthn assertion object.
 * @returns {Promise<ArrayBuffer>} The concatenated hash of the authenticator data and client data JSON.
 * @throws Will throw an error if there's an issue generating the hash.
 */
async function generateHashFromAssertion(crypto, assertion) {
  try {
    // Creating the signature to be compared with the one generated by the authenticator
    const authenticatorDataBuffer = base64ToBuffer(
      assertion.response.authenticatorData
    );
    const clientDataJSONSHA256Data = await crypto.subtle.digest(
      "SHA-256",
      base64ToBuffer(assertion.response.clientDataJSON)
    );

    return bufferConcatenate(authenticatorDataBuffer, clientDataJSONSHA256Data);
  } catch (error) {
    throw error;
  }
}

// ------------------------------------------------------------------------------------------------

module.exports = validateAuthentication;

// ------------------------------------------------------------------------------------------------
