const verifySignature = require("../../crypto/verifySignature");
const importKey = require("../../crypto/importPublicKey");
const validateRPID = require("./validateRPID");
const isNumber = require("../../helpers/isNumber");
const base64ToBuffer = require("../../utils/base64ToBuffer");
const bufferConcatenate = require("../../utils/bufferConcatenate");
const convertECDSAASN1Signature = require("./convertECDSAASN1Signature");

// ------------------------------------------------------------------------------------------------
/**
 * Asynchronously validates a WebAuthn authentication assertion against the expected properties and the provided credential.
 *
 * @param {Object} credential - The WebAuthn credential object.
 * @param {string} credential.id - The credential ID.
 * @param {string} credential.rawId - The raw credential ID.
 * @param {string} credential.type - The credential type, expected to be "public-key".
 * @param {number} credential.publicKeyAlgorithm - The algorithm used for the public key.
 * @param {string} credential.publicKey - The public key in base64 format.
 *
 * @param {Object} assertion - The WebAuthn assertion object.
 * @param {string} assertion.id - The assertion ID.
 * @param {string} assertion.rawId - The raw assertion ID.
 * @param {string} assertion.type - The assertion type, expected to be "public-key".
 * @param {Object} assertion.response - The response from the authenticator.
 * @param {string} assertion.response.clientDataJSONDecoded - The decoded client data JSON.
 * @param {string} assertion.response.authenticatorDataDecoded - The decoded authenticator data.
 * @param {ArrayBuffer} assertion.response.signature - The signature generated by the authenticator.
 *
 * @param {Object} [expectedProps={}] - The expected properties for validation.
 * @param {string} [expectedProps.challenge] - The expected challenge.
 * @param {string} [expectedProps.origin] - The expected origin.
 * @param {string} [expectedProps.type] - The expected type.
 * @param {string} [expectedProps.rpID] - The expected relying party ID.
 * @param {number} [expectedProps.counterCredential] - The expected credential counter.
 *
 * @param {Object} [incomingProps={}] - The incoming properties for validation.
 * @param {number} [incomingProps.counterAssertion] - The incoming assertion counter.
 *
 * @param {Object} [publicKeyProps={}] - The properties for importing the public key.
 * @param {Object} [publicKeyProps.importKey] - The import key properties.
 * @param {string} [publicKeyProps.importKey.format] - The format of the key, default is "spki".
 * @param {boolean} [publicKeyProps.importKey.extractable] - Whether the key is extractable, default is false.
 *
 * @returns {Promise<boolean>} Returns true if the validation is successful.
 * @throws Will throw an error if validation fails.
 */
async function validateAuthentication(
  credential,
  assertion,
  expectedProps = {},
  incomingProps = {},
  publicKeyProps = {},
  convertECDSignature = true
) {
  try {
    validateCounters(expectedProps, incomingProps);
    validateRequestParams(assertion, expectedProps);
    validateFlags(assertion);
    validateCredentialProps(credential);
    validateAssertionProps(assertion);
    validateCredentialAssertion(credential, assertion);
    validateRPID(expectedProps.rpID, assertion.authData.rpIdHash);

    const importPublicKeyAlgorithm = getImportPublicKeyAlgorithm(
      credential.response.publicKeyAlgorithm
    );
    const publicKey = await importKey(
      publicKeyProps?.importKey?.format || "spki",
      base64ToBuffer(credential.response.publicKey, false),
      importPublicKeyAlgorithm,
      publicKeyProps?.importKey?.extractable || false,
      ["verify"]
    );

    const algorithm = getAlgorithmVerifySignatureParam(
      credential.response.publicKeyAlgorithm
    );

    let signature = new Uint8Array(
      base64ToBuffer(assertion.response.signature, false)
    );
    if (convertECDSignature && credential.response.publicKeyAlgorithm === -7) {
      signature = convertECDSAASN1Signature(signature);
    }

    const dataToVerify = await generateHashFromAssertion(crypto, assertion);
    return await verifySignature(algorithm, publicKey, signature, dataToVerify);
  } catch (error) {
    throw error;
  }
}

// ------------------------------------------------------------------------------------------------

function validateCounters(expectedProps, incomingProps) {
  if (
    !isNumber(expectedProps.counterCredential) ||
    expectedProps.counterCredential < 0
  ) {
    throw new Error(
      "counterCredential must be a number greater than or equal to zero"
    );
  }

  if (
    !isNumber(incomingProps.counterAssertion) ||
    incomingProps.counterAssertion < 0
  ) {
    throw new Error(
      "counterAssertion must be a number greater than or equal to zero"
    );
  }

  if (expectedProps.counterCredential <= incomingProps.counterAssertion) {
    throw new Error("counterCredential must be greater than counterAssertion");
  }
  return true;
}

// ------------------------------------------------------------------------------------------------

function validateFlags(assertion) {
  if (!assertion.authData.flags.up) {
    throw new Error(`User Present is required for authentication.`);
  }

  if (!assertion.authData.flags.uv) {
    throw new Error(`User Verified is required for authentication.`);
  }
}

// ------------------------------------------------------------------------------------------------

function validateCredentialProps(credential) {
  if (!credential) {
    throw new Error("Missing credential");
  }
  if (!credential.id) {
    throw new Error("Missing credential ID");
  }
  if (!credential.rawId) {
    throw new Error("Ḿissing credential rawId");
  }
  if (!credential.type || credential.type != "public-key") {
    throw new Error(
      "Ḿissing credential type or credential type is not public-key"
    );
  }
  return true;
}

// ------------------------------------------------------------------------------------------------

function validateAssertionProps(assertion) {
  if (!assertion) {
    throw new Error("Missing assertion");
  }
  if (!assertion.id) {
    throw new Error("Missing assertion ID");
  }
  if (!assertion.rawId) {
    throw new Error("Ḿissing assertion rawId");
  }
  if (!assertion.type || assertion.type != "public-key") {
    throw new Error(
      "Ḿissing assertion type or assertion type is not public-key"
    );
  }
  return true;
}

// ------------------------------------------------------------------------------------------------

function validateRequestParams(assertion, expectedProps = {}) {
  const clientDataJSON = JSON.parse(assertion.response.clientDataJSONDecoded);
  if (expectedProps.challenge != clientDataJSON?.challenge) {
    throw new Error(
      `Challenge does not match. Provided challenge: ${
        clientDataJSON?.challenge || "none"
      }.`
    );
  }

  if (expectedProps.origin != clientDataJSON?.origin) {
    throw new Error(
      `Origin does not match. Expected: ${expectedProps.origin} Actual: ${
        clientDataJSON?.origin || "none"
      }`
    );
  }

  if (expectedProps.type != clientDataJSON?.type) {
    throw new Error(
      `Type does not match. Expected: ${expectedProps.type} Actual: ${
        clientDataJSON?.type || "none"
      }`
    );
  }
  return true;
}

// ------------------------------------------------------------------------------------------------

function validateCredentialAssertion(credential, assertion) {
  if (credential.id != assertion.id) {
    throw new Error("Credential ID does not match assertion ID");
  }
  if (credential.rawId != assertion.rawId) {
    throw new Error("Credential rawId does not match assertion rawId");
  }
  return true;
}

// ------------------------------------------------------------------------------------------------

function getImportPublicKeyAlgorithm(publicKeyAlgorithm) {
  if (publicKeyAlgorithm === -7) {
    return {
      name: "ECDSA",
      namedCurve: "P-256",
    };
  }
  if (publicKeyAlgorithm === -257) {
    return {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" },
    };
  }
  if (publicKeyAlgorithm === -8) {
    throw new Error("Ed25519 is not supported by crypto.subtle directly");
  }
  throw new Error(`Unsupported algorithm: ${publicKeyAlgorithm}`);
}

// ------------------------------------------------------------------------------------------------

function getAlgorithmVerifySignatureParam(publicKeyAlgorithm) {
  if (publicKeyAlgorithm === -7) {
    return {
      name: "ECDSA",
      hash: { name: "SHA-256" },
    };
  }
  if (publicKeyAlgorithm === -257) {
    return {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" },
    };
  }
  if (publicKeyAlgorithm === -8) {
    throw new Error(
      "Ed25519 is not supported by crypto.subtle. Use an external library."
    );
  }
  throw new Error(`Unsupported algorithm: ${publicKeyAlgorithm}`);
}

// ------------------------------------------------------------------------------------------------

async function generateHashFromAssertion(crypto, assertion) {
  try {
    // Creating the signature to be compared with the one generated by the authenticator
    const authenticatorDataBuffer = base64ToBuffer(
      assertion.response.authenticatorData,
      false
    );
    const clientDataJSONSHA256Data = await crypto.subtle.digest(
      "SHA-256",
      base64ToBuffer(assertion.response.clientDataJSON, false)
    );

    return bufferConcatenate(authenticatorDataBuffer, clientDataJSONSHA256Data);
  } catch (error) {
    throw error;
  }
}

// ------------------------------------------------------------------------------------------------

module.exports = validateAuthentication;

// ------------------------------------------------------------------------------------------------
